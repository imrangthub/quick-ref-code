#################################################
#                 JAVA                          #
#################################################

=>java -version
=>echo %JAVA_HOME%
jvisualvm
Soft:
Xmanager_Enterprise_v5.0.1249r_Incl_Keygen_v1.0_DFoX_URET

=>java -jar -DMYSQL_HOST=127.0.0.1 arif-travel-agency-0.0.1-SNAPSHOT.jar



=>jps
=>ps -fC java
Show all java running applicaton

=================================================
#        Java Compiler                                       
================================================= 
=>javac -cp /usr/local/Cellar/tomcat/9.0.6/libexec/lib/servlet-api.jar HelloServlet.java
=>javac -cp .;"C:\Users\User Name\Tomcat\apache-tomcat-7.0.108\lib\servlet-api.jar" HelloServlet.java
=>javac -classpath "c:\Program Files\Apache Software Foundation\Tomcat 6.0\lib\servlet-api.jar" yourfile.java .









=================================================
##jvm operation | JVM | JVM-MONITORING
=================================================
=>jps
=>ps -fC java
Show all java running applicaton

=>jcmd pId
Show all availabel jvm command

=>java -XX:+PrintFlagsFinal
=>java -XX:+PrintFlagsFinal -version | grep HeapSize
Show all curretn(defautl) JVM setting with flag 


=>jcmd 29286 VM.version
=>jcmd 6056 VM.flags
=>jcmd pId VM.flags
Show runtime parameters that were used when starting for a specific Java process (Memory Unit Show In Byte)

=>jstat -gc 6056
Show garbage collection statistics, including the heap sizes.

=>java -XX:+PrintFlagsFinal -version | grep HeapSize
To find default Heap size in current java or jvm

=>top  (then press e for change mm unit)
=>top -p pID
=>ps -p 29286 -o rss= -o vsz= -o %mem= -o %cpu= -o comm=
Show Memory and CPU uses by process pId



Find the Process ID (PID):
=>jps -v

Get Thread Dump:
=>jcmd <PID> Thread.print > thread_dump.txt


jconsole
----------------------------------------------------
=>jconsole
For visual representation jvm

For visualVM
----------------------------------------------------
Download and run it



GC:
-----------------------------------------------------
In JDK 8 
-verbose:gc

YoungGeneartion=Eden
OldGneration=OldGen
jdk17
java -Xlog:gc*:file=gc.log -jar your-application.jar
Quick show Gurbase collecton, add this flag on VM argument




Check JVM flag (if not set, its show default flag)
------------------------------------------

=>jinfo -flag UseAdapptiveSizePolicy pId
=>jinfo -flag UseAdapptiveSizePolicy 224323
Check curretn gc Policy

=>jinfo -flag NewRation PID
=>jinfo -flag NewRation 23223
Show the ration of Young and Old Generation GC ration

to set a new Ration add VM flag:
-XX:NewRation=1


=>jinfo -flag ServivorRation PID
Show YouGC ration

Set Servibe Ration in YGC add flag
-XX:ServivorRation=5





Java memory footprint of process | application
=================================================
In Jvm Runtime the primary MemoryConsumer:
- Java Heap
- Class Loadeing
- JIT Compiler
- Threads


=>=>jps -v
=>top -o%MEM
Show the process info, here `RES` show the req  phical-ram taken by thie process like 5gb.
Not all (VIRT)Virtual Memory is in Physical RAM: The amount shown in the VIRT column does not 
mean that all of it is actively occupying physical RAM. 


=>pmap -x pid
Now the RES 5gb in details, show with this command.
Every single class,jar, .os file etc. what is consume how much mamory showing using this command.


=>jmap -histo:live pid 
=>jmap -histo:live 26202 | grep com.imranmadbar
=>jmap -histo:live 169638 | grep 'com.imranmadbar'
=>jmap -histo:live 258096 | grep 'Connecti'
=>jmap -histo:live 262119 | grep 'com.mysql.cj.jdbc.ConnectionImpl'
=>jmap -histo:live <PID> | awk 'NR>3 {print $1, $2, $3, $4, $3/1024/1024 " MB", $3/1024/1024/1024 " GB"}'
Find Class/package using pid show details memory uses

Columns Explained jmap command-output:
	num: The ranking of the class by the number of instances or memory usage (descending order).
	#instances: The number of instances of each class that are currently alive in memory.
	#bytes: The total amount of memory (in bytes) used by all instances of that class.
	class name: The name of the class or type of object.
The output will display a list of classes and their memory usage, which helps identify the classes consuming the most memory.



=>jcmd PID VM.classloader_status
show how many class load and which class load

=>jcmd PID GC.class_status
Which class, field consume how much memory




Java Thread Analysis
=================================================
=>jstack pid
=>jstack 262119 | grep 'connect'
Generate a Thread Dump


=>jstack <pid> > thread_dump.txt
Get thread dump
Analyze Thread States:
	RUNNABLE: Threads that are actively executing code.
	BLOCKED: Threads waiting for a lock held by another thread.
	WAITING: Threads waiting indefinitely for another thread to perform a particular action (e.g., Object.wait()).
	TIMED_WAITING: Threads waiting for another thread to perform an action for up to a specified waiting time.


=>jstack 262119 | grep 'WAITING'
=>jstack 262119 | grep -C 2 'WAITING'


Control Thread Counts:
	Use -Xss to limit stack size and control thread usage:
	-Xss512k




=>jstack 354107 | grep 'MyCustomThread'
get running thread





VisualVM | Remote connect
=================================================
/app/apihub/jdks/jdk-17.0.7/bin/java -Dcom.sun.management.jmxremote.port=9991  -Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.management.jmxremote.authenticate=false  -Xms1024m -Xmx1024m -jar integration-svc1-0.0.1-SNAPSHOT.jar

java -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=8090 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar integration-svc1-0.0.1-SNAPSHOT.jar

MaveBuildConnamd 
mvn spring-boot:run -Dspring-boot.run.jvmArguments="-Xdebug -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=9010 -Dcom.sun.management.jmxremote.rmi.port=9010 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=localhost"

java -Dcom.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.port=6001 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=192.168.251.9 -Dcom.sun.management.jmxremote.rmi.port=6001 -jar integration-svc1-0.0.1-SNAPSHOT.jar
/app/apihub/jdks/jdk-17.0.7/bin/java -Dcom.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.port=6001 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Djava.rmi.server.hostname=172.16.254.122 -Dcom.sun.management.jmxremote.rmi.port=6001 -jar integration-svc1-0.0.1-SNAPSHOT.jar



How to set up remote visual VM
We need set the below properties while running jar

    -Dcom.sun.management.jmxremote=true 
    -Dcom.sun.management.jmxremote.port=<PORT> 
    -Dcom.sun.management.jmxremote.authenticate=false 
    -Dcom.sun.management.jmxremote.ssl=false 
    -Djava.rmi.server.hostname=<SEVER IP_ADDRESS> 
    -Dcom.sun.management.jmxremote.rmi.port=<PORT>








JVM Tuning
=================================================
Each time you run a command like java -jar, it starts a new JVM instance, even though all those instances 
come from the same JDK installed on your machine.

How it Works:
	Single JDK: The JDK provides the tools (like java command) and libraries needed to run JVMs.
	New JVM per Command: Each time you run java -jar, a separate JVM process is created with its own memory, 
	garbage collector, and configuration.

	Isolated JVMs: These JVMs are independent, so one JVM’s settings or performance doesn’t affect the others.


Example JVM Tuning Command
java -Xms512m -Xmx2048m -Xss1m -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -Xlog:gc*:file=gc.log:time,uptime -Dcom.sun.management.jmxremote -jar YourApplication.jar



Best Practices for Running Multiple JVMs on One Host:
Resource Management (CPU, Memory)
	Divide Memory Appropriately:
	Ensure that the total memory allocated to all JVMs doesn’t exceed the system’s RAM to avoid swapping.

Limit CPU Usage:
	Use taskset or cgroups (on Linux) to pin specific applications to certain CPU cores:
	taskset -c 0-3 java -jar App1.jar
	taskset -c 4-7 java -jar App2.jar


4. Control Thread Counts
	JVMs create multiple threads, which can exhaust the system’s thread pool.
	Use -Xss to limit stack size and control thread usage:
	-Xss512k


5. File Descriptors and Ports
	Each JVM uses sockets and open files. Increase ulimit to avoid "too many open files" errors:
	ulimit -n 65536


6. Logging Configuration
Ensure that logs are written to different files per application to avoid conflict and manage disk space.
Example:
bash
Copy code
-Xlog:gc*:file=/var/log/app1/gc.log





Running multiple JVMs on the same host requires proper resource allocation (memory, CPU, and threads), 
different GC strategies, and monitoring tools to maintain performance. 




Potential Issues Without Tuning:
==============================================
	OutOfMemoryError if multiple apps exhaust the available memory.
		Memory Allocation:
		Default Heap Size: The JVM sets heap size based on the host machine’s RAM (around 25% of total memory).
		Initial Heap (-Xms): ~256 MB.
		Max Heap (-Xmx): Up to 1/4 of available memory (in your case ~8 GB per JVM if not limited).
	With 10 apps, the cumulative memory demand can exceed your 32 GB limit, leading to OutOfMemoryErrors or OS-level swapping.

	High CPU usage due to multiple GC operations across all apps.
	G1 GC is the default in Java 17.
		Use G1 GC (default) or Parallel GC for CPU-heavy apps
		java -XX:+UseParallelGC -Xms256m -Xmx512m -jar app3.jar

	Too many open threads leading to "too many open files" errors.
		Limit Thread Usage
		Reduce stack size to prevent thread exhaustion:-Xss512k
		java -Xss512k -jar app1.jar


	Limit File Descriptors:
	ulimit -n 65536


    Monitor Your JVMs:
		java -Dcom.sun.management.jmxremote.port=9010 -Dcom.sun.management.jmxremote -jar app1.jar

Example Optimized Command for Each App:
	java -Xms512m -Xmx1024m -Xss512k -XX:+UseG1GC -Xlog:gc*:file=gc.log:time,uptime -Dcom.sun.management.jmxremote.port=9010 -jar app1.jar







=================================================
##jar operation | .jar Extract
=================================================

=>unzip yourfile.jar -d /path/to/extract
open using IntelliJIDEA




=================================================
#         Convater | Param  | Json                                        
================================================= 

@Id
@GeneratedValue(strategy = GenerationType.AUTO)



#Object to Json
-------------------------------------------------
  ObjectMapper Obj = new ObjectMapper();
  String jsonStr = Obj.writeValueAsString(request);
  log.info("PURCHASE OFFER REQUEST PARAM: " + jsonStr);
	  
	  
	  
#From Json
-------------------------------------------------

JSONObject json = new JSONObject(reqObj);
Date appointDate = Def.getDate(json, "appointDate", "dd/MM/yyyy");
Long doctorNo = Def.getLong(json, "doctorNo");
Long shiftNo = Def.getLong(json, "shiftNo");



#From HttpParam | request.getParameter | Parameter
-------------------------------------------------
String companyNoStr = request.getParameter("companyNo");
if (companyNoStr != null && !companyNoStr.isEmpty()) {
	Long companyNo = Long.valueOf(companyNoStr);
	if (companyNo > 0) {
		viewPathSamplePendingCollectionEntity.setCompanyNo(companyNo);
	}
}

String hospitalNumber = request.getParameter("hospitalNumber");
if (hospitalNumber != null && !hospitalNumber.isEmpty()) {
	isSearch = true;
	int setHpNoRs = setKParamPdSetHospitalNo(hospitalNumber);
	viewPathSamplePendingCollectionEntity.setHospitalNumber(hospitalNumber);
}

String fromDateStr = request.getParameter("fromDate");
String toDateStr = request.getParameter("toDate");

Date fromDate = deateParse(fromDateStr, "dd/MM/yyyy");
Date toDate = deateParse(toDateStr, "dd/MM/yyyy");

if (fromDate != null && toDate != null) {
	isSearch = true;
	viewPathSamplePendingCollectionEntity.setFromDate(fromDate);
	viewPathSamplePendingCollectionEntity.setToDate(toDate);

	int setInvoiceFrmDateRs = setKParamPdSetInvoiceDateFrom(
			viewPathSamplePendingCollectionEntity.getFromDate());
	int setInvoiceToDateRs = setKParamPdSetInvoiceDateTo(viewPathSamplePendingCollectionEntity.getToDate());

}


public class DbssData<T extends Attributes> implements Serializable {

  private String id;

  private DataType type;

  private T attributes;
  
  
================================================
#  Object Mapping | List | Filter |Stream|Short                                       
================================================= 
Row:
import com.fasterxml.jackson.databind.ObjectMapper;
default <T> T objectMapperReadValue(String content, Class<T> valueType) {
	ObjectMapper objectMapper = new ObjectMapper();
	try {

		return objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false).readValue(content,
				valueType);

	} catch (JsonParseException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
		return null;
	} catch (JsonMappingException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
		return null;
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
		return null;
	}
	// return null;
}
@SuppressWarnings("unchecked")
default <T> List<T> objectMapperReadArrayValue(String mapperArrStr, Class<T> clazz) {
	ObjectMapper objectMapper = new ObjectMapper();
	try {

		return (List<T>) objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
				.readValue(mapperArrStr, TypeFactory.defaultInstance().constructCollectionType(List.class, clazz));

	} catch (JsonParseException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
		return null;
	} catch (JsonMappingException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
		return null;
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
		return null;
	}
}
	
#List From Response Obj
-------------------------------------------------
response = resultEntryTemplateAuthorInfo.getConsultantInfo();
if (response.isSuccess() && response.getItems() != null) {
	consultationInfoList = copyPropertiesEntityListToDtoList(response.getItems(),
			ResultEntryTemplateAuthorInfoDto.class);
	resMap.put("consultationInfoList", consultationInfoList);
}
			
List<ViewDepartmentEntity> departmentList = new ArrayList<>();	
	
if (response.isSuccess() && !CollectionUtils.isEmpty(response.getItems())) {
departmentList = getListFromObject(response.getItems(), ViewDepartmentEntity.class);


Response response = baseFindById(criteriaQuery(userFeatureEntity));
 if (response.isSuccess() && response.getObj()!=null) {
  return getValueFromObject(response.getObj(), ShareUserFeatureEntity.class);
}

if (dataStr != null && !dataStr.equals("{}")) {
	passKioskRes = new PassportKioskResDto();
	passKioskRes = objectMapperReadValue(dataStr, PassportKioskResDto.class);
}

String clinicalHistoryListStr = Def.getArrayString(json, "clinicalHistoryList");
String daycareServiceListStr = Def.getArrayString(json, "daycareServiceList");

Map<String, Object> prescriptionData = new HashMap<String, Object>();

if (prescriptionStr != null && !prescriptionStr.equals("{}")) {
	prescriptionEntity = objectMapperReadValue(prescriptionStr, PrescriptionEntityMedicareNew.class);
	if (prescriptionEntity != null) {
		prescriptionData.put("prescriptionEntity", prescriptionEntity);
	}

}
if (vitalStr != null && !vitalStr.equals("[]")) {
	vitalList = objectMapperReadArrayValue(vitalStr, PrescriptionDetailsEntityMedicareNew.class);
	if (vitalList != null) {
		prescriptionData.put("vitalList", vitalList);
	}
}



String personalInfoStr = Def.getString(json, "personalInfo");
if (personalInfoStr != null && !personalInfoStr.equals("{}")) {
	StudentPersonalInfoEntity personalInfo = null;
	personalInfo = objectMapperReadValue(personalInfoStr, StudentPersonalInfoEntity.class);
	personalInfo.setStudentNo(studentObj.getId());
	response = personalInfoService.saveObj(personalInfo);
	if (!response.isSuccess()) {
		porcContinueFlg = false;
		response.setSuccess(false);
		response.setObj(personalInfo);
		response.setMessage("Personal Info save failed !");
		return response;
	}
}

String familyInfoListStr = Def.getString(json, "familyInfoList");
if (familyInfoListStr != null && !familyInfoListStr.equals("[]")) {
	List<StudentFamilyInfoEntity> familyInfoList = null;
	familyInfoList = objectMapperReadArrayValue(familyInfoListStr, StudentFamilyInfoEntity.class);
	if (familyInfoList != null) {
		boolean isSave = familyInfoService.saveFamilyMember(familyInfoList, studentObj.getId());
		if (!isSave) {
			porcContinueFlg = false;
			response.setSuccess(false);
			response.setObj(familyInfoList);
			response.setMessage("Family Info save failed !");
			return response;
		}
	}
}				
				
#List Short by Name
-------------------------------------------------
departmentList = departmentList.stream().sorted((a1, a2) -> a1.getBuName().compareTo(a2.getBuName()))
					.collect(Collectors.toList());	





#Filter a list of object by its list field
-------------------------------------------------

List<Student> productsDataList =
       dbssList.getData().stream()
           .filter(t -> t.getAttributes().getProductCode() != null)
           .collect(Collectors.toList());


Return Object Value:
String firstName = simpleList.stream()
	  .filter(obj -> obj.getAttributes().getCategory().equals("consumer"))
	  .findFirst()
	  .get()
	  .getAttributes()
	  .getFirstName()
									  
-------------------------------------------------
public class Student {
    List<Course> courses;
    ...
}
public class Course {
    String name;
    ...
}

boolean IsContainValue = objList.getData().stream().anyMatch(obj -> obj.getAttributes().getMsisdn().equals(myVal));
List<Student> studentList;
List<Student> algorithmsCourseStudentList = 
    studentList.stream()
               .filter(a -> a.getCourses()
                             .stream()
                             .anyMatch(c -> c.getCourseName().equals("Algorithms")))
               .collect(Collectors.toList());

			   
allMatch will only give you Students that all their Courses are named "Algorithms".

anyMatch will give you all Students that have at least one Course named "Algorithms"


Person matchingObject = objects.stream().
filter(p -> p.email().equals("testemail")).
findAny().orElse(null);

#Concate List
------------------------------------------------
List<String> str1 = new ArrayList<String>();
str1.add("A");
str1.add("B");
str1.add("C");
str1.add("D");

List<String> str2 = new ArrayList<String>();
str2.add("D");
str2.add("E");

List<String> str3 = str1.stream()
                        .filter(item -> !str2.contains(item))
                        .collect(Collectors.toList());

str1 // ["A", "B", "C", "D"]
str2 // ["D", "E"]
str3 // ["A", "B", "C"]

=================================================
# Date | Time | DateTime | Timestramp|Zon|UTC                                
================================================= 


#Time Zone operation for Local time
-------------------------------------
import java.time.ZonedDateTime,ZoneId ;
private ZonedDateTime activatedAt;

UTC to zone time
-------------------------------------
public ZonedDateTime getActivatedAt() {
return activatedAt != null
	? activatedAt.toOffsetDateTime().atZoneSameInstant(ZoneId.of("GMT+6"))
	: null;
}
  
UTC time to +6 Zone Time
-------------------------------------
public ZonedDateTime getActivatedDateTime() {

return null == activatedDateTime
	? null
	: activatedDateTime.toOffsetDateTime().plusHours(6).atZoneSameInstant(ZoneId.of("GMT+06"));
}

Set Local Max Time
------------------
  public ZonedDateTime getExpiryDateTime() {
    if (expiryDateTime == null) {
      return null;
    } else {
      if (expiryDateTime.toString().contains("T12:00Z")) {
        expiryDateTime = expiryDateTime.toOffsetDateTime().atZoneSameInstant(ZoneId.of("GMT+06"));
        expiryDateTime = expiryDateTime.with(LocalTime.MAX);
        return expiryDateTime =
            ZonedDateTime.parse(
                DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX")
                    .format(expiryDateTime.withZoneSameInstant(ZoneId.of("Asia/Dhaka"))));
      } else {
        return expiryDateTime =
            expiryDateTime.toOffsetDateTime().atZoneSameInstant(ZoneId.of("GMT+6"));
      }
    }
  }


=================================================
#         Query | sql call                                      
================================================= 

public static String getScheduleByDoctorNoDateShiftNo(Long doctorNo, Long shiftNo ) {
	StringBuilder sqlQuery = new StringBuilder();
	sqlQuery.append("select * from hpms_doc_schedule ");
	sqlQuery.append("where doctor_no = 137 ");
	sqlQuery.append("and shiftdtl_no = 2 ");
	sqlQuery.append("wand trunc(empschedule_dt) between '31-may-2021' and '31-may-2021' ");
	System.out.println("getScheduleByDoctorNoDateShiftNo: "+sqlQuery.toString());
	return sqlQuery.toString();
}


public LabReportSaCompanyFlgDto getLabReportSaCompanyFlag(Long companyNo) {
	boolean errorFlag = false;
	LabReportSaCompanyFlgDto labReportSaCompanyFlg = new LabReportSaCompanyFlgDto();
	Connection con = null;
	ResultSet rs = null;
	Statement stm = null;
	List<LabReportSaCompanyFlgDto> labReportSaCompanyFlgList = new ArrayList<LabReportSaCompanyFlgDto>();
	try {
		con = getOraConnection();
		stm = con.createStatement();
		rs = stm.executeQuery(ReportStatement.getLabReportSaCompanyFlagQuery(companyNo, isEnbRpGnConLog()));
		while (rs.next()) {
			LabReportSaCompanyFlgDto obj = new LabReportSaCompanyFlgDto();

			obj.setRepPreparedPrompt(rs.getString("REP_PREPARED_PROMPT"));
			obj.setRepVerifyPrompt(rs.getString("REP_VERIFY_PROMPT"));
			obj.setRepConsultantPrompt(rs.getString("REP_CONSULTANT_PROMPT"));
			obj.setCollTimeFlg(rs.getLong("COLL_TIME_FLAG"));
			obj.setReceiveTimeFlg(rs.getLong("RECEIVE_TIME_FLAG"));
			obj.setResultEntryTimeFlg(rs.getLong("RESULT_ENTRY_TIME_FLAG"));
			obj.setRepSlogan(rs.getString("REP_SLOGAN"));
			obj.setRepEndText(rs.getString("REP_END_TEXT"));

			labReportSaCompanyFlgList.add(obj);
		}
		if (!labReportSaCompanyFlgList.isEmpty()) {
			labReportSaCompanyFlg = labReportSaCompanyFlgList.get(0);
		}
	} catch (SQLException e) {
		e.printStackTrace();
		errorFlag = true;
	} finally {
		finalyConStmRs(con, stm, rs);
	}
	if (errorFlag) {
		return null;
	}
	return labReportSaCompanyFlg;
}


-------------------------------------------------

public Response checkIsSplitableByLabNo(Long labNo) {
		if (labNo == null) {
			return getErrorResponse("labId Not Found!");
		}
		StringBuilder sqlString = new StringBuilder();
		sqlString.append("select count(item_no) item from path_invoicedtl ");
		sqlString.append(" where lab_no = '" + labNo + "' and nvl(cancel_flag,0) = 0");
		System.out.println("sqlString:" + sqlString);

		Query query = entityManager.createNativeQuery(sqlString.toString());
		Response response = null;
		try {
			List<BigDecimal> resultList = query.getResultList();
			BigDecimal result = resultList.get(0);
			response = new Response();
			if (result.longValue() > 1) {
				response.setValid(true);
			}
			response.setObj(result.longValue());
			response.setSuccess(true);

		} catch (NoResultException e) {
			response = new Response();
			response.setSuccess(false);
			response.setMessage("No entity's found!");
		}
		return response;
	}
-------------------------------------------------


==================================================
#Function | Procedure Call|OracleCallableStatement                        
==================================================

ST01
====
public Response collectionStepUpdateByLabId(String labId) {
		Boolean executeFlag = null;
		try {
			StoredProcedureQuery query = entityManager.createStoredProcedureQuery("K_LAB.PD_STEP_UPDATE_WEB")

					.registerStoredProcedureParameter(1, String.class, ParameterMode.IN)
					.registerStoredProcedureParameter(2, Long.class, ParameterMode.IN)
					.registerStoredProcedureParameter(3, Long.class, ParameterMode.IN)
					.registerStoredProcedureParameter(4, String.class, ParameterMode.IN)
					.setParameter(1, labId).setParameter(2, userDetails().getUserId())
					.setParameter(3, userDetails().getSessionNo()).setParameter(4, "PSCC");

			executeFlag = query.execute();

		} catch (Exception e) {
			System.out.println(e);
			return getErrorResponse("Sample Collection fail !!");
		}
		return getSuccessResponse("Sample Collection Successfully");
}

STO2
====
public Response sampleCollectionProcessByInvoiceId(String invoiceId) {

		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("K_VARIFICATION.PD_INVOICE_SAM_PRO")

				.registerStoredProcedureParameter(1, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(2, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(3, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(4, Long.class, ParameterMode.OUT)
				.registerStoredProcedureParameter(5, Long.class, ParameterMode.OUT)
				.registerStoredProcedureParameter(6, String.class, ParameterMode.OUT)

				.setParameter(1, invoiceId).setParameter(2, userDetails().getOrganizationNo())
				.setParameter(3, userDetails().getCompanyNo());

		query.execute();

		Long invoiceNo = query.getOutputParameterValue(4) != null ? (Long) query.getOutputParameterValue(4) : null;
		Long action = query.getOutputParameterValue(5) != null ? (Long) query.getOutputParameterValue(5) : null;
		String message = query.getOutputParameterValue(6) != null ? (String) query.getOutputParameterValue(6) : "";

		Response response = new Response();
		Map<String, Object> resMap = new HashMap<String, Object>();
		resMap.put("invoiceNo", invoiceNo);
		resMap.put("action", action);
		resMap.put("message", message);

		response.setObj(resMap);

		return response;
}

STO3
====
public Response sampleCollSplit(String reqStr) {

		Map<String, Object> result = new HashMap<>();
		Response response = new Response();
		Connection dbConnection = null;
		OracleCallableStatement orcs = null;
		SampleCollectionSplitProcDto sampleCollectionSplitProcDto = new SampleCollectionSplitProcDto();

		if (reqStr != null && !reqStr.equals("[]")) {
			sampleCollectionSplitProcDto = objectMapperReadValue(reqStr, SampleCollectionSplitProcDto.class);
		}

		try {
			int indexPosition = 0;
			dbConnection = getOraConnection();
			orcs = (OracleCallableStatement) dbConnection.prepareCall(procedureQuery("K_LAB.PD_NEW_LABNO", 7));

			Def.setStringArray(++indexPosition, sampleCollectionSplitProcDto.getSplitableLabNoArr(), orcs);
			orcs.setLong(++indexPosition, sampleCollectionSplitProcDto.getSplitableLabNoArr().length);
			orcs.setLong(++indexPosition, sampleCollectionSplitProcDto.getDeliveryStatus());
			orcs.setLong(++indexPosition, userDetails().getUserId());
			orcs.setLong(++indexPosition, userDetails().getSessionNo());
			orcs.setLong(++indexPosition, userDetails().getCompanyNo());

			int errMessageIndex = ++indexPosition;
			orcs.registerOutParameter(errMessageIndex, OracleTypes.VARCHAR);

			orcs.execute();
			result.put("errMessage", orcs.getString(errMessageIndex));

		} catch (SQLException e) {
			e.printStackTrace();
			System.out.println("Error : " + e);
		} finally {
			Def.connectionClose(dbConnection, orcs);
		}
		if (result.get("errMessage") == null) {
			response.setMessage("Split Successfully");
			return response;
		}
		return getErrorResponse("Sample Collection Split fail !!");

	}
STO4
====
public Response getPatientDetailsByRegNo(Long regNo) {

		Response res = new Response();
		ResultSet rs = null;

		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("pd_reg_pat_details_info_web");
		query.registerStoredProcedureParameter(1, Long.class, ParameterMode.IN);
		query.registerStoredProcedureParameter(2, Void.class, ParameterMode.REF_CURSOR);
		query.setParameter(1, regNo);
		query.execute();

		try {
			rs = (ResultSet) query.getOutputParameterValue(2);
			while (rs.next()) {
				PatientDetailsInfoDTO pathInfo = new PatientDetailsInfoDTO();

				pathInfo.setRegNo(rs.getLong("reg_no"));
				pathInfo.setHospitalNumber(rs.getString("hospital_number"));
				pathInfo.setRegDate(rs.getDate("reg_date"));
				pathInfo.setPatientName(rs.getString("patient_name"));
				pathInfo.setGenderData(rs.getString("gender_data"));
				pathInfo.setMaritalStatus(rs.getString("m_status_data"));
				pathInfo.setDob(rs.getDate("dob"));
				pathInfo.setAge(rs.getString("age"));

				res.setObj(pathInfo);
			}
			res.setMessage("Data Found");
		} catch (SQLException e) {
			res.setSuccess(false);
			res.setMessage("Data not Found!");
			e.printStackTrace();
		} finally {
			finalyRs(rs);
		}
		return res;
	}
	
	
STO5
====
public Response getRegSummaryDataList(String reqObj) {
		
		JSONObject json = new JSONObject(reqObj);
		Date startDate 	= Def.getDate(json, "startDate");
		Date endDate 	= Def.getDate(json, "endDate");
		
		Response res = new Response();
		ResultSet rs = null;
		
		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("PD_REG_SW_SUM_REP_WEB");
		query.registerStoredProcedureParameter(1, Date.class, ParameterMode.IN);	//	p_st_date         DATE,
		query.registerStoredProcedureParameter(2, Date.class, ParameterMode.IN);	//  p_end_date        DATE,
		query.registerStoredProcedureParameter(3, Void.class, ParameterMode.REF_CURSOR);
		
		query.setParameter(1, addMinTime(startDate));
		query.setParameter(2, addMaxTime(endDate));
		
		query.execute();

		try {
			List<RegSummaryRptDTO> rptDataList = new ArrayList<RegSummaryRptDTO>();
			
			rs = (ResultSet) query.getOutputParameterValue(3);
			while (rs.next()) {
				RegSummaryRptDTO regSum = new RegSummaryRptDTO();
				
				regSum.setRegDate(rs.getDate("reg_date"));
				regSum.setMorning(rs.getLong("morning"));
				regSum.setEvening(rs.getLong("evening"));
				regSum.setTotReg(rs.getLong("tot_reg"));

				rptDataList.add(regSum);
			}
			res.setItems(rptDataList);
			res.setMessage("Data Found");
		} catch (SQLException e) {
			res.setSuccess(false);
			res.setMessage("Data not Found!");
			e.printStackTrace();
		} finally {
			finalyRs(rs);
		}
		return res;
	}
		
	
MORE
====
	public String storedProcedureGenerateId(Long companyNo, String prefix) {
		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("K_GENERAL.PD_GENARATE_ID")

				.registerStoredProcedureParameter(1, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(2, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(3, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(4, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(5, String.class, ParameterMode.OUT)

				.setParameter(1, prefix).setParameter(2, "OPD_REGISTRATION").setParameter(3, "HOSPITAL_NUMBER")
				.setParameter(4, companyNo);

		return (String) query.getOutputParameterValue(5);
	}

	public String storedProcedureGenerateId(Long companyNo, String prefix, String tableName, String columnName) {
		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("K_GENERAL.PD_GENARATE_ID")

				.registerStoredProcedureParameter(1, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(2, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(3, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(4, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(5, String.class, ParameterMode.OUT)

				.setParameter(1, prefix).setParameter(2, tableName).setParameter(3, columnName)
				.setParameter(4, companyNo);

		return (String) query.getOutputParameterValue(5);
	}

	public Long storedProcedureGenerateNo(Long companyNo, String sequenceName) {

		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("K_GENERAL.PD_GENARATE_NO")

				.registerStoredProcedureParameter(1, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(2, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(3, Long.class, ParameterMode.OUT)
				.registerStoredProcedureParameter(4, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(5, Long.class, ParameterMode.IN)

				.setParameter(1, sequenceName).setParameter(2, companyNo).setParameter(4, "YY").setParameter(5, 10l);
		try {
			query.execute();
		} catch (Exception e) {
			System.err.println("sequenceName: " + sequenceName);
		}

		return (Long) query.getOutputParameterValue(3);
	}

	public Long functionFdAutoNo(Long companyNo, String tableName, String columnName, Long dataLength) {
		BigDecimal maxValue = null;
		maxValue = (BigDecimal) entityManager
				.createNativeQuery("SELECT FD_AUTO_NO(:pTable,:pColumn,:pCompanyNo,:pDataLength) FROM DUAL")
				.setParameter("pTable", tableName).setParameter("pColumn", columnName)
				.setParameter("pCompanyNo", companyNo).setParameter("pDataLength", dataLength).getSingleResult();

		if (maxValue == null) {
			return null;
		}
		return maxValue.longValue();

	}

	public String functionFdUserName(Long userno) {
		String usrName = null;
		usrName = (String) entityManager.createNativeQuery("SELECT FD_USER_NAME(:pUserNo) FROM DUAL")
				.setParameter("pUserNo", userno).getSingleResult();
		if (usrName == null) {
			return null;
		}
		return usrName;
	}

	public Response storedProcedureCreateAnonymousUser(Long regNo, String HN, String gender, Long companyNo,
			Long sessionNo, String encodPassword, String plainPassord, String defaultPageLink, String featureCoad,
			String phoneNo, String patientName, Long userNo) throws AppRuntimeException {

		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("pd_anonymous_user")

				.registerStoredProcedureParameter(1, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(2, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(3, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(4, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(5, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(6, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(7, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(8, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(9, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(10, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(11, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(12, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(13, Long.class, ParameterMode.OUT)
				.registerStoredProcedureParameter(14, String.class, ParameterMode.OUT)

				.setParameter(1, regNo).setParameter(2, HN).setParameter(3, gender).setParameter(4, phoneNo)
				.setParameter(5, patientName).setParameter(6, userNo).setParameter(7, companyNo)
				.setParameter(8, sessionNo).setParameter(9, encodPassword).setParameter(10, plainPassord)
				.setParameter(11, defaultPageLink).setParameter(12, featureCoad);

		query.execute();

		Long action = query.getOutputParameterValue(13) != null ? (Long) query.getOutputParameterValue(13) : null;
		String message = query.getOutputParameterValue(14) != null ? (String) query.getOutputParameterValue(14) : "";

		Response response = new Response();
		Map<String, Object> resMap = new HashMap<String, Object>();

		resMap.put("action", action);
		resMap.put("message", message);

		response.setObj(resMap);

		if (action.longValue() == 1L) {
			throw new AppRuntimeException().anonymousUserCreationException("User Creation fail!! " + message);
		}

		return response;
	}

	public String functionPatientAge(Date fromDate, Date toDate) {
		String from = null;
		String to = null;
		String age = null;

		SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");
		if (null != fromDate) {
			from = dateFormat.format(fromDate);
		}
		if (null != toDate) {
			to = dateFormat.format(toDate);
		}

		age = (String) entityManager.createNativeQuery("SELECT fnc_cal_age_web(:from,:to) FROM DUAL")
				.setParameter("from", from).setParameter("to", to).getSingleResult();

		if (age == null) {
			return null;
		}
		return age;
	}
	
MORE
====

public Response getRegPatientReportDataList(String reqObj) {
		
		JSONObject json = new JSONObject(reqObj);
		Date startDate 	= Def.getDate(json, "startDate");
		Date endDate 	= Def.getDate(json, "endDate");
		Long userNo 	= Def.getLong(json, "userNo");
		Long patTypeNo 	= Def.getLong(json, "patTypeNo");
		String phoneNo 	= Def.getString(json, "phoneNo");
		Long corClintNo 	  = Def.getLong(json, "corClintNo");
		Integer corporateFlag = Def.getInteger(json, "corporateFlag");
		Integer emailFlag 	  = Def.getInteger(json, "emailFlag");
		
		Integer inActiveFlag    = Def.getInteger(json, "inActiveFlag");
		Integer blacklistedFlag = Def.getInteger(json, "blacklistedFlag");
		Integer chronicFlag     = Def.getInteger(json, "chronicFlag");
		
		Response res = new Response();
		ResultSet rs = null;
		
		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("pd_reg_pat_report_web");
		query.registerStoredProcedureParameter(1, Date.class, ParameterMode.IN);	//	p_st_date         DATE,
		query.registerStoredProcedureParameter(2, Date.class, ParameterMode.IN);	//  p_end_date        DATE,
		query.registerStoredProcedureParameter(3, Long.class, ParameterMode.IN);	//  p_user_no         NUMBER,
		query.registerStoredProcedureParameter(4, Long.class, ParameterMode.IN);	//  p_pat_type_no     NUMBER,
		query.registerStoredProcedureParameter(5, Integer.class, ParameterMode.IN);	//  p_email_flag      NUMBER,
		query.registerStoredProcedureParameter(6, String.class, ParameterMode.IN);	//  p_active_stat     NUMBER,
		query.registerStoredProcedureParameter(7, Long.class, ParameterMode.IN);	//  p_cor_client_no   NUMBER,
		query.registerStoredProcedureParameter(8, Integer.class, ParameterMode.IN);	//	p_cor_flag        NUMBER,
		query.registerStoredProcedureParameter(9, Integer.class, ParameterMode.IN);	//	p_cor_flag        NUMBER,
		query.registerStoredProcedureParameter(10, Integer.class, ParameterMode.IN);	//	p_cor_flag        NUMBER,
		query.registerStoredProcedureParameter(11, Integer.class, ParameterMode.IN);	//	p_cor_flag        NUMBER,
		query.registerStoredProcedureParameter(12, Void.class, ParameterMode.REF_CURSOR);
		
		query.setParameter(1, addMinTime(startDate));
		query.setParameter(2, addMaxTime(endDate));
		query.setParameter(3, userNo);
		query.setParameter(4, patTypeNo);
		query.setParameter(5, emailFlag);
		query.setParameter(6, phoneNo);
		query.setParameter(7, corClintNo);
		query.setParameter(8, corporateFlag);
		query.setParameter(9, inActiveFlag);
		query.setParameter(10, blacklistedFlag);
		query.setParameter(11, chronicFlag);
		
		query.execute();

		try {
			List<PatientDetailsInfoDTO> rptDataList = new ArrayList<PatientDetailsInfoDTO>();
			rs = (ResultSet) query.getOutputParameterValue(12);
			while (rs.next()) {
				PatientDetailsInfoDTO pathInfo = new PatientDetailsInfoDTO();

				pathInfo.setRegNo(rs.getLong("reg_no"));
				pathInfo.setHospitalNumber(rs.getString("hospital_number"));
				pathInfo.setSsModifiedOn(rs.getDate("ss_modified_on"));	
				
				if(inActiveFlag!=null && inActiveFlag.equals(1)) {
					pathInfo.setFlagType("Inactive");
				} else if(blacklistedFlag!=null && blacklistedFlag.equals(1)) {
					pathInfo.setFlagType("Blacklist");
				} else if(chronicFlag!=null && chronicFlag.equals(1)) {
					pathInfo.setFlagType("Chronic");
				}

				rptDataList.add(pathInfo);
			}
			res.setItems(rptDataList);
			res.setMessage("Data Found");
		} catch (SQLException e) {
			res.setSuccess(false);
			res.setMessage("Data not Found!");
			e.printStackTrace();
		} finally {
			finalyRs(rs);
		}
		return res;
	}
	
	public Response getRegMedCampaignDataList(String reqObj) {
		
		JSONObject json = new JSONObject(reqObj);
		Date startDate 	= Def.getDate(json, "startDate");
		Date endDate 	= Def.getDate(json, "endDate");
		Long userNo 	= Def.getLong(json, "userNo");
		Long campaignNo = Def.getLong(json, "campaignNo");
		
		Response res = new Response();
		ResultSet rs = null;
		
		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("PD_REG_CAMPAIGN_RPT_WEB");
		query.registerStoredProcedureParameter(1, Date.class, ParameterMode.IN);	//	p_st_date         DATE,
		query.registerStoredProcedureParameter(2, Date.class, ParameterMode.IN);	//  p_end_date        DATE,
		query.registerStoredProcedureParameter(3, Long.class, ParameterMode.IN);	//  p_user_no         NUMBER,
		query.registerStoredProcedureParameter(4, Long.class, ParameterMode.IN);	//  p_campaign_no     NUMBER,
		query.registerStoredProcedureParameter(5, Void.class, ParameterMode.REF_CURSOR);
		
		query.setParameter(1, addMinTime(startDate));
		query.setParameter(2, addMaxTime(endDate));
		query.setParameter(3, userNo);
		query.setParameter(4, campaignNo);
		
		query.execute();

		try {
			List<PatientDetailsInfoDTO> rptDataList = new ArrayList<PatientDetailsInfoDTO>();
			rs = (ResultSet) query.getOutputParameterValue(5);
			while (rs.next()) {
				PatientDetailsInfoDTO pathInfo = new PatientDetailsInfoDTO();

				pathInfo.setRegNo(rs.getLong("reg_no"));
				pathInfo.setHospitalNumber(rs.getString("hospital_number"));
				pathInfo.setCampaignNo(rs.getLong("campaign_no"));
				pathInfo.setCampaignName(rs.getString("campaign_name"));				

				rptDataList.add(pathInfo);
			}
			res.setItems(rptDataList);
			res.setMessage("Data Found");
		} catch (SQLException e) {
			res.setSuccess(false);
			res.setMessage("Data not Found!");
			e.printStackTrace();
		} finally {
			finalyRs(rs);
		}
		return res;
	}
	

	
	
	public DoctorScheduleDto getScheduleByDocNoAndDateShiftNo(Long doctorNo, Long shiftNo, String schecduleDate) {
		boolean errorFlag = false;
		DoctorScheduleDto docScheduleObj = null;
		Connection con = null;
		ResultSet rs = null;
		Statement stm = null;
		List<DoctorScheduleDto> docScheduleObjList = new ArrayList<DoctorScheduleDto>();
		try {
			con = getOraConnection();
			stm = con.createStatement();
			rs = stm.executeQuery(DiagnosticStatement.getScheduleByDoctorNoDateShiftNo(doctorNo, shiftNo, schecduleDate));
			while (rs.next()) {
				DoctorScheduleDto obj = new DoctorScheduleDto();

				obj.setDoctorNo(rs.getLong("DOCTOR_NO"));
				obj.setBuNo(rs.getLong("BU_NO"));
				obj.setEmpscheduleDt(rs.getString("EMPSCHEDULE_DT"));
				obj.setEmpscheduleNo(rs.getLong("EMPSCHEDULE_NO"));
				obj.setShiftdtlNo(rs.getLong("SHIFTDTL_NO"));


				docScheduleObjList.add(obj);
			}
			if (!docScheduleObjList.isEmpty()) {
				docScheduleObj = docScheduleObjList.get(0);
			}
		} catch (SQLException e) {
			e.printStackTrace();
			errorFlag = true;
		} finally {
			finalyConStmRs(con, stm, rs);
		}
		if (errorFlag) {
			return null;
		}
		return docScheduleObj;
	}

	public Response regMRNCardFeeBillProcedure(Long regNo, Long billFor, MyUserDetails user) {
		
		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("pd_reg_mrn_card_bill_save_web");

		query.registerStoredProcedureParameter(1, Long.class, ParameterMode.IN);
		query.registerStoredProcedureParameter(2, Long.class, ParameterMode.IN);
		query.registerStoredProcedureParameter(3, Long.class, ParameterMode.IN);
		query.registerStoredProcedureParameter(4, Long.class, ParameterMode.IN);
		query.registerStoredProcedureParameter(5, Long.class, ParameterMode.IN);
		query.registerStoredProcedureParameter(6, Long.class, ParameterMode.IN);
		
		query.registerStoredProcedureParameter(7, Long.class, ParameterMode.OUT);
		query.registerStoredProcedureParameter(8, String.class, ParameterMode.OUT);
		query.registerStoredProcedureParameter(9, Long.class, ParameterMode.OUT);
		query.registerStoredProcedureParameter(10, String.class, ParameterMode.OUT);

		query.setParameter(1, regNo);
		query.setParameter(2, billFor); //1=Reg_FeeBill, 2=MRN_CardFeeBill
		query.setParameter(3, user.getUserId());
		query.setParameter(4, user.getSessionNo());
		query.setParameter(5, user.getOrganizationNo());
		query.setParameter(6, user.getCompanyNo());

		query.execute();

		Long invoiceNo = query.getOutputParameterValue(7) != null ? (Long) query.getOutputParameterValue(7) : null;
		String invoiceId = query.getOutputParameterValue(8) != null ? (String) query.getOutputParameterValue(8) : "";
		Long action = query.getOutputParameterValue(9) != null ? (Long) query.getOutputParameterValue(9) : null;
		String message = query.getOutputParameterValue(10) != null ? (String) query.getOutputParameterValue(10) : "";

		Response response = new Response();
		Map<String, Object> resMap = new HashMap<String, Object>();
		resMap.put("invoiceNo", invoiceNo);
		resMap.put("invoiceId", invoiceId);
		resMap.put("action", action);
		resMap.put("message", message);

		response.setSuccess(action.equals(1L)?true:false);
		response.setMessage(action.equals(1L)?"Sucessfully Bill Saved.":"Failed to Save Bill!");
		response.setModel(resMap);

		return response;
	}
	
	
	public Response kLabPdStepUpdate(KLabPdStepUpdateProsdArgDto paramObj) {

		Boolean executeFlag = null;
		String genId = null;
		try {
			ProcedureCall procedureCall = entityManager.unwrap(Session.class)
					.createStoredProcedureCall("K_LAB.PD_STEP_UPDATE");
			procedureCall.registerParameter(1, Long.class, ParameterMode.IN);
			procedureCall.registerParameter(2, Long.class, ParameterMode.IN);
			procedureCall.registerParameter(3, Date.class, ParameterMode.IN);
			procedureCall.registerParameter(4, Long.class, ParameterMode.IN);
			procedureCall.registerParameter(5, Long.class, ParameterMode.IN);
			procedureCall.registerParameter(6, Long.class, ParameterMode.IN);
			procedureCall.registerParameter(7, String.class, ParameterMode.IN);
			procedureCall.registerParameter(8, Long.class, ParameterMode.IN);
			procedureCall.registerParameter(9, Long.class, ParameterMode.IN);
			procedureCall.registerParameter(10, Long.class, ParameterMode.IN).enablePassingNulls(true);
			procedureCall.registerParameter(11, Long.class, ParameterMode.IN);
			procedureCall.registerParameter(12, Date.class, ParameterMode.IN);
			procedureCall.registerParameter(13, Long.class, ParameterMode.IN).enablePassingNulls(true);
			procedureCall.registerParameter(14, Date.class, ParameterMode.IN).enablePassingNulls(true);
			procedureCall.registerParameter(15, Long.class, ParameterMode.IN).enablePassingNulls(true);
			procedureCall.registerParameter(16, Date.class, ParameterMode.IN).enablePassingNulls(true);
			procedureCall.registerParameter(17, Long.class, ParameterMode.IN).enablePassingNulls(true);
			procedureCall.registerParameter(18, Date.class, ParameterMode.IN).enablePassingNulls(true);
			procedureCall.registerParameter(19, String.class, ParameterMode.IN);

			procedureCall.setParameter(1, paramObj.getStampNo());
			procedureCall.setParameter(2, paramObj.getEntryBy());
			procedureCall.setParameter(3, paramObj.getEntryDate());
			procedureCall.setParameter(4, paramObj.getSessionNo());
			procedureCall.setParameter(5, paramObj.getBuNo());
			procedureCall.setParameter(6, paramObj.getTempNo());
			procedureCall.setParameter(7, paramObj.getReportGroup());
			procedureCall.setParameter(8, paramObj.getDeliveryStatusNo());
			procedureCall.setParameter(9, paramObj.getInvoiceNo());
			procedureCall.setParameter(10, paramObj.getPathVoucherDtlNoUck());
			procedureCall.setParameter(11, paramObj.getPreparedBy());
			procedureCall.setParameter(12, paramObj.getPreparedDate());
			procedureCall.setParameter(13, paramObj.getVerifiedBy());
			procedureCall.setParameter(14, paramObj.getVerifiedDate());
			procedureCall.setParameter(15, paramObj.getFinalBy());
			procedureCall.setParameter(16, paramObj.getFinalDate());
			procedureCall.setParameter(17, paramObj.getPrintBy());
			procedureCall.setParameter(18, paramObj.getPrintDate());
			procedureCall.setParameter(19, paramObj.getTypeVal());

			executeFlag = procedureCall.execute();

		} catch (Exception e) {
			LOGGER.error("Error Procedure execude K_LAB.PD_STEP_UPDATE" + e.getStackTrace());
			System.out.println("Error Procedure execude K_LAB.PD_STEP_UPDATE" + e);
			return getErrorResponse("Error Procedure execude K_LAB.PD_STEP_UPDATE ");
		}
		return getSuccessResponse("Successfully K_LAB.PD_STEP_UPDATE execute done");
	}

	// Post Insert Process : for table PATH_TESTRESULTSTAMP
	public Response kLabPdUpdPathInvDtlStampNo(Long pInvoiceNo, String reportGroup, Long buNo, Long tempNo,
			Long stampNo, Long deliveryStatusNo) {

		Boolean executeFlag = null;
		try {
			StoredProcedureQuery query = entityManager.createStoredProcedureQuery("k_lab.PD_UPD_PATH_INV_DTL_STAMP_NO")

					.registerStoredProcedureParameter(1, Long.class, ParameterMode.IN)
					.registerStoredProcedureParameter(2, String.class, ParameterMode.IN)
					.registerStoredProcedureParameter(3, Long.class, ParameterMode.IN)
					.registerStoredProcedureParameter(4, Long.class, ParameterMode.IN)
					.registerStoredProcedureParameter(5, Long.class, ParameterMode.IN)
					.registerStoredProcedureParameter(6, Long.class, ParameterMode.IN)

					.setParameter(1, pInvoiceNo).setParameter(2, reportGroup).setParameter(3, buNo)
					.setParameter(4, tempNo).setParameter(5, stampNo).setParameter(6, deliveryStatusNo);

			executeFlag = query.execute();

		} catch (Exception e) {
			LOGGER.error("Pathology Error Found for execute pros PD_UPD_PATH_INV_DTL_STAMP_NO: " + e.getStackTrace());
			System.out.println("Pathology Error Found for execute pros PD_UPD_PATH_INV_DTL_STAMP_NO" + e);
			return getErrorResponse("Pathology Error Found for execute pros PD_UPD_PATH_INV_DTL_STAMP_NO !!");
		}
		return getSuccessResponse("Successfully PD_UPD_PATH_INV_DTL_STAMP_NO pros execute done");
	}

	public List<Long> getItemNoListForResultEntry(Long invoiceNo, Long tempNo, Long buNo, String reportGroup,
			Long deliveryStatusNo, Long stampNo) {

		List<Long> itemNoList = new ArrayList<Long>();
		StringBuilder sqlString = new StringBuilder();

		sqlString.append("SELECT a.item_no FROM in_item a, path_invoicedtl b  ");
		sqlString.append(" WHERE DECODE (NVL (a.report_group, 'I'),'I', TO_CHAR (a.item_no), a.report_group) = NVL ('"
				+ reportGroup + "', 'I') ");
		sqlString.append(" AND a.bu_no = " + buNo);
		sqlString.append(" AND a.test_temp_no = " + tempNo);
		sqlString.append(" AND a.item_no = b.item_no ");
		sqlString.append(" AND b.delivery_status_no = NVL (" + deliveryStatusNo + ", 1) ");
		sqlString.append(" AND NVL (b.stamp_no, -1) = NVL (" + stampNo + ", -1) ");
		sqlString.append(" AND b.invoice_no = " + invoiceNo);
		sqlString.append(" AND NVL (b.lab_rcv_from_sp_key_flag, 0) = 1 ");
		System.out.println("PathResultEntryItemNoListQuery:" + sqlString);

		Query query = entityManager.createNativeQuery(sqlString.toString());
		Response response = null;
		try {
			List<BigDecimal> resultList = query.getResultList();
			for (BigDecimal value : resultList) {
				itemNoList.add(value.longValue());
			}
		} catch (Exception e) {
			LOGGER.error("Pathology Error Found when getItemNoListForResultEntry : " + e.getStackTrace());
			System.err.println("Pathology Error Found when getItemNoListForResultEntry " + e);
			e.printStackTrace();
			return null;
		}
		return itemNoList;
	}

	public String getGenaratedId(String tableName, String columnName) {

		Boolean executeFlag = null;
		String genId = null;
		try {
			ProcedureCall procedureCall = entityManager.unwrap(Session.class)
					.createStoredProcedureCall("K_GENERAL.PD_GENARATE_ID");

			procedureCall.registerParameter(1, StringType.class, ParameterMode.IN).enablePassingNulls(true);
			procedureCall.registerParameter(2, String.class, ParameterMode.IN);
			procedureCall.registerParameter(3, String.class, ParameterMode.IN);
			procedureCall.registerParameter(4, Long.class, ParameterMode.IN);
			procedureCall.registerParameter(5, String.class, ParameterMode.OUT);

			procedureCall.setParameter(1, null);
			procedureCall.setParameter(2, tableName);
			procedureCall.setParameter(3, columnName);
			procedureCall.setParameter(4, userDetails().getCompanyNo());

			executeFlag = procedureCall.execute();

			genId = procedureCall.getOutputParameterValue(5) != null ? (String) procedureCall.getOutputParameterValue(5)
					: null;

		} catch (Exception e) {
			LOGGER.error("Pathology Error Found when getGenaratedId: " + e.getStackTrace());
			System.err.println("Pathology Error Found when getGenaratedId " + e);
			return null;
		}
		return genId;
	}

	public Long getGenIdForPathInvoiceDtl() {
		return storedProcedureGenerateNo(userDetails().getCompanyNo(), "SEQ_PATHINVOICEDTL_NO");
	}

	public Long getGenIdForTestResult() {
		return storedProcedureGenerateNo(userDetails().getCompanyNo(), "SEQ_TESTRESULT_NO");
	}

	public Long getGenIdForTestResultStamp() {
		return storedProcedureGenerateNo(userDetails().getCompanyNo(), "SEQ_STAMP_NO");
	}

	// getStampNoByStampId
	public Response getStampNoByStampId(String stampId) {
		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("PD_GET_STAMP_NO")
				.registerStoredProcedureParameter(1, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(2, String.class, ParameterMode.IN)
				.registerStoredProcedureParameter(3, Long.class, ParameterMode.OUT).setParameter(1, stampId)
				.setParameter(2, "P");

		query.execute();

		Long stampNo = query.getOutputParameterValue(3) != null ? (Long) query.getOutputParameterValue(3) : null;
		Response response = new Response();
		response.setObj(stampNo);
		return response;
	}

	public MyUserDetails userDetails() {
		MyUserDetails myUserDetails = userPrincipal();

		Map<String, Object> details = resourceTokenStore.readAccessToken(accessToken()).getAdditionalInformation();
		if (null != details.get("sessionNo")) {
			myUserDetails.setSessionNo(((Long) details.get("sessionNo")).longValue());
		}
		return myUserDetails;
	}

	public Response pdReportViewLogWeb(Long testTempNo, Long invoiceNo, String reportType, Long buNo, String accessType,
			Long stampNo) {

		Boolean executeFlag = null;
		Response response = new Response();
		Map<String, Object> resMap = new HashMap<String, Object>();
		try {
			StoredProcedureQuery query = entityManager.createStoredProcedureQuery("pd_report_view_log_web");

			query.registerStoredProcedureParameter(1, Long.class, ParameterMode.IN);
			query.registerStoredProcedureParameter(2, Long.class, ParameterMode.IN);
			query.registerStoredProcedureParameter(3, String.class, ParameterMode.IN);
			query.registerStoredProcedureParameter(4, Long.class, ParameterMode.IN);
			query.registerStoredProcedureParameter(5, String.class, ParameterMode.IN);
			query.registerStoredProcedureParameter(6, Long.class, ParameterMode.IN);
			query.registerStoredProcedureParameter(7, Long.class, ParameterMode.IN);
			query.registerStoredProcedureParameter(8, Long.class, ParameterMode.IN);
			query.registerStoredProcedureParameter(9, Long.class, ParameterMode.IN);
			query.registerStoredProcedureParameter(10, Long.class, ParameterMode.OUT);
			query.registerStoredProcedureParameter(11, String.class, ParameterMode.OUT);

			query.setParameter(1, testTempNo);
			query.setParameter(2, invoiceNo);
			query.setParameter(3, reportType);
			query.setParameter(4, buNo);
			query.setParameter(5, accessType);
			query.setParameter(6, stampNo);
			query.setParameter(7, userDetails().getUserId());
			query.setParameter(8, userDetails().getSessionNo());
			query.setParameter(9, userDetails().getCompanyNo());

			executeFlag = query.execute();
			Long action = query.getOutputParameterValue(10) != null ? (Long) query.getOutputParameterValue(10) : null;
			String message = query.getOutputParameterValue(11) != null ? (String) query.getOutputParameterValue(11)
					: "";

			resMap.put("action", action);
			resMap.put("message", message);

			if (action != 0) {
				response.setSuccess(false);
			}
			response.setObj(resMap);

		} catch (Exception e) {
			e.printStackTrace();
			LOGGER.error("Pathology Error Found when pdReportViewLogWeb Procesur Call: " + e.getStackTrace());
			System.err.println("Pathology Error Found when pdReportViewLogWeb Procesur Call" + e);
			return getErrorResponse("ReportViewLogWeb fail !!");
		}
		return response;
	}

	public List<LabReportResultDto> getLabReportResultList(Long stampNo) {
		boolean errorFlag = false;
		Connection con = null;
		ResultSet rs = null;
		Statement stm = null;
		List<LabReportResultDto> labReportResultList = new ArrayList<LabReportResultDto>();
		try {
			con = getOraConnection();
			stm = con.createStatement();
			rs = stm.executeQuery(ReportStatement.getLabReportResultList(stampNo, isEnbRpGnConLog()));
			while (rs.next()) {
				LabReportResultDto obj = new LabReportResultDto();

				obj.setStampId(rs.getString("stamp_id"));
				// obj.setStampNo(rs.getLong("stamp_no"));
				obj.setResultThree(rs.getString("result3"));
				obj.setInterpretationTest(rs.getString("INTERPRETATION_TEST"));
				obj.setNormalValue(rs.getString("normal_value"));
				obj.setAttribGroup(rs.getString("attribgroup"));
				obj.setAttribGroupOne(rs.getString("attribgroup_1"));
				// obj.setInterpretationTest(rs.getString("interpretation_test"));
				// obj.setSlNo(rs.getLong("sl_no"));
				obj.setGroupTxt(rs.getString("GROUP_TXT"));
				obj.setTestGroupNo(rs.getLong("TEST_GROUP_NO"));
				obj.setUnit(rs.getString("unit"));

				labReportResultList.add(obj);
			}

		} catch (SQLException e) {
			e.printStackTrace();
			errorFlag = true;
		} finally {
			finalyConStmRs(con, stm, rs);
		}

		if (errorFlag) {
			return null;
		}

		return labReportResultList;
	}

	public LabReportSaCompanyFlgDto getLabReportSaCompanyFlag(Long companyNo) {
		boolean errorFlag = false;
		LabReportSaCompanyFlgDto labReportSaCompanyFlg = new LabReportSaCompanyFlgDto();
		Connection con = null;
		ResultSet rs = null;
		Statement stm = null;
		List<LabReportSaCompanyFlgDto> labReportSaCompanyFlgList = new ArrayList<LabReportSaCompanyFlgDto>();
		try {
			con = getOraConnection();
			stm = con.createStatement();
			rs = stm.executeQuery(ReportStatement.getLabReportSaCompanyFlagQuery(companyNo, isEnbRpGnConLog()));
			while (rs.next()) {
				LabReportSaCompanyFlgDto obj = new LabReportSaCompanyFlgDto();

				obj.setRepPreparedPrompt(rs.getString("REP_PREPARED_PROMPT"));
				obj.setRepVerifyPrompt(rs.getString("REP_VERIFY_PROMPT"));
				obj.setRepConsultantPrompt(rs.getString("REP_CONSULTANT_PROMPT"));
				obj.setCollTimeFlg(rs.getLong("COLL_TIME_FLAG"));
				obj.setReceiveTimeFlg(rs.getLong("RECEIVE_TIME_FLAG"));
				obj.setResultEntryTimeFlg(rs.getLong("RESULT_ENTRY_TIME_FLAG"));
				obj.setRepSlogan(rs.getString("REP_SLOGAN"));
				obj.setRepEndText(rs.getString("REP_END_TEXT"));

				labReportSaCompanyFlgList.add(obj);
			}
			if (!labReportSaCompanyFlgList.isEmpty()) {
				labReportSaCompanyFlg = labReportSaCompanyFlgList.get(0);
			}
		} catch (SQLException e) {
			e.printStackTrace();
			errorFlag = true;
		} finally {
			finalyConStmRs(con, stm, rs);
		}
		if (errorFlag) {
			return null;
		}
		return labReportSaCompanyFlg;
	}

	
-------------------------------------------------


================================================
# Repository Example|                                     
================================================= 


@Repository
@Transactional
public class ViewPathSamplePendingCollectionRepository extends DiagnosticBaseRepository {

	private static final Logger LOGGER = LoggerFactory.getLogger(ViewPathSamplePendingCollectionRepository.class);

	public Response getPathSamplePendingCollectionList(String viewPathSamplePendingCollectionStr) {
		ViewPathSamplePendingCollectionEntity viewPathSamplePendingCollection = objectMapperReadValue(
				viewPathSamplePendingCollectionStr, ViewPathSamplePendingCollectionEntity.class);
		return baseList(criteriaQuery(viewPathSamplePendingCollection));
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Response gridList(HttpServletRequest request) {

		boolean isSearch = false; // If empty of those foure field then search will be false
		DataTableResults<ViewPathSamplePendingCollectionEntity> dataTableResults = null;
		Response response = new Response();
		ViewPathSamplePendingCollectionEntity viewPathSamplePendingCollectionEntity = new ViewPathSamplePendingCollectionEntity();

		String fromDateStr = request.getParameter("fromDate");
		String toDateStr = request.getParameter("toDate");

		Date fromDate = deateParse(fromDateStr, "dd/MM/yyyy");
		Date toDate = deateParse(toDateStr, "dd/MM/yyyy");

		if (fromDate != null && toDate != null) {
			isSearch = true;
			viewPathSamplePendingCollectionEntity.setFromDate(fromDate);
			viewPathSamplePendingCollectionEntity.setToDate(toDate);

			int setInvoiceFrmDateRs = setKParamPdSetInvoiceDateFrom(
					viewPathSamplePendingCollectionEntity.getFromDate());
			int setInvoiceToDateRs = setKParamPdSetInvoiceDateTo(viewPathSamplePendingCollectionEntity.getToDate());

		}
		String patientFrom = request.getParameter("patientFrom");
		if (null != patientFrom && !patientFrom.isEmpty()) {
			viewPathSamplePendingCollectionEntity.setPatientFrom(patientFrom);
		}

		String departmentNoStr = request.getParameter("departmentNumbrer");
		if (null != departmentNoStr && !departmentNoStr.isEmpty()) {
			Long departmentNo = Long.valueOf(departmentNoStr);
			if (departmentNo > 0) {
				viewPathSamplePendingCollectionEntity.setDepartmentNo(departmentNo);
			}
		}

		String priorityNumberStr = request.getParameter("priorityNumber");
		if (priorityNumberStr != null && !priorityNumberStr.isEmpty()) {
			Long priorityNo = Long.valueOf(priorityNumberStr);
			if (priorityNo > 0) {
				viewPathSamplePendingCollectionEntity.setDeliveryStatusNo(priorityNo);
			}
		}

		String companyNoStr = request.getParameter("companyNo");
		if (companyNoStr != null && !companyNoStr.isEmpty()) {
			Long companyNo = Long.valueOf(companyNoStr);
			if (companyNo > 0) {
				viewPathSamplePendingCollectionEntity.setCompanyNo(companyNo);
			}
		}

		String hospitalNumber = request.getParameter("hospitalNumber");
		if (hospitalNumber != null && !hospitalNumber.isEmpty()) {
			isSearch = true;
			int setHpNoRs = setKParamPdSetHospitalNo(hospitalNumber);
			viewPathSamplePendingCollectionEntity.setHospitalNumber(hospitalNumber);
		}

		String admissionId = request.getParameter("admissionId");
		if (admissionId != null && !admissionId.isEmpty()) {
			isSearch = true;
			int setAdmissionNoRs = setKParamPdSetAdmissionId(admissionId);
			viewPathSamplePendingCollectionEntity.setAdmissionId(admissionId);
		}

		String invoiceId = request.getParameter("invoiceId");
		if (invoiceId != null && !invoiceId.isEmpty()) {
			isSearch = true;
			int setInvoiceIdRs = setKParamPdSetInvoiceId(invoiceId);
			viewPathSamplePendingCollectionEntity.setInvoiceId(invoiceId);
		}
		String labId = request.getParameter("labId");
		if (labId != null && !labId.isEmpty()) {
			isSearch = true;
			int setLabIdRs = setKParamPdSetLabId(labId);
			viewPathSamplePendingCollectionEntity.setLabId(labId);
		}

		DataTableRequest dataTableInRQ = new DataTableRequest(request);
		Long totalRowCount = totalCount(viewPathSamplePendingCollectionEntity);

		List gridList = new ArrayList<>();
		if (isSearch) {
			response = baseList(typedQuery(viewPathSamplePendingCollectionEntity, dataTableInRQ));
		}
		if (response.isSuccess()) {
			if (response.getItems() != null) {
				gridList = response.getItems();
			}

			dataTableResults = dataTableResults(dataTableInRQ, gridList, gridList, totalRowCount);

		}
		response.setItems(null);
		response.setObj(dataTableResults);
		return response;
	}

	public Response list(String reqObj) {
		ViewPathSamplePendingCollectionEntity viewPathSamplePendingCollectionEntity = new ViewPathSamplePendingCollectionEntity();
		if (reqObj != null) {
			viewPathSamplePendingCollectionEntity = objectMapperReadValue(reqObj,
					ViewPathSamplePendingCollectionEntity.class);
		}
		return baseList(criteriaQuery(viewPathSamplePendingCollectionEntity));
	}

	// Non API
	@SuppressWarnings({ "rawtypes", "unchecked" })
	private CriteriaQuery criteriaQuery(ViewPathSamplePendingCollectionEntity filter) {
		init();
		List<Predicate> p = new ArrayList<Predicate>();
		p = criteriaCondition(filter, null, null);

		if (!CollectionUtils.isEmpty(p)) {
			Predicate[] pArray = p.toArray(new Predicate[] {});
			Predicate predicate = builder.and(pArray);
			criteria.where(predicate);
		}
		return criteria;
	}

	@SuppressWarnings({ "rawtypes" })
	private <T> TypedQuery typedQuery(ViewPathSamplePendingCollectionEntity filter, DataTableRequest<T> dataTableInRQ) {
		init();
		List<Predicate> pArrayJoin = new ArrayList<Predicate>();
		List<Predicate> pConjunction = criteriaCondition(filter, null, null);
		List<Predicate> pDisJunction = dataTablefilter(dataTableInRQ);

		Predicate predicateAND = null;
		Predicate predicateOR = null;

		if (!CollectionUtils.isEmpty(pConjunction)) {
			Predicate[] pArray = pConjunction.toArray(new Predicate[] {});
			predicateAND = builder.and(pArray);
		}

		if (!CollectionUtils.isEmpty(pDisJunction)) {
			Predicate[] pArray = pDisJunction.toArray(new Predicate[] {});
			predicateOR = builder.or(pArray);
		}
		if (predicateAND != null) {
			pArrayJoin.add(predicateAND);
		}

		if (predicateOR != null) {
			pArrayJoin.add(predicateOR);
		}
		if (dataTableInRQ.getOrder().getName() != null && !dataTableInRQ.getOrder().getName().isEmpty()) {
			if (dataTableInRQ.getOrder().getSortDir().equals("ASC")) {
				criteria.orderBy(builder.asc(root.get(dataTableInRQ.getOrder().getName())));
			} else {
				criteria.orderBy(builder.desc(root.get(dataTableInRQ.getOrder().getName())));
			}
		}

		criteria.where(pArrayJoin.toArray(new Predicate[0]));

		return baseTypedQuery(criteria, dataTableInRQ);
	}

	private Long totalCount(ViewPathSamplePendingCollectionEntity filter) {
		CriteriaBuilder builder = criteriaBuilder();
		CriteriaQuery<Long> criteriaQuery = longCriteriaQuery(builder);
		Root<ViewPathSamplePendingCollectionEntity> root = from(ViewPathSamplePendingCollectionEntity.class,
				criteriaQuery);
		return totalCount(builder, criteriaQuery, root, criteriaCondition(filter, builder, root));

	}

	@SuppressWarnings({ "unchecked" })
	private List<Predicate> criteriaCondition(ViewPathSamplePendingCollectionEntity filter, CriteriaBuilder builder,
			Root<ViewPathSamplePendingCollectionEntity> root) {

		if (builder == null) {
			builder = super.builder;
		}
		if (root == null) {
			root = super.root;
		}

		List<Predicate> p = new ArrayList<Predicate>();

		if (filter != null) {

			if (filter.getInvoiceId() != null && !filter.getInvoiceId().isEmpty()) {
				Predicate condition = builder.equal(root.get("invoiceId"), filter.getInvoiceId());
				p.add(condition);
			}
			if (filter.getAdmissionId() != null && !filter.getAdmissionId().isEmpty()) {
				Predicate condition = builder.equal(root.get("admissionId"), filter.getAdmissionId());
				p.add(condition);
			}
			if (filter.getLabId() != null && !filter.getLabId().isEmpty()) {
				Predicate condition = builder.equal(root.get("labId"), filter.getLabId());
				p.add(condition);
			}

			if (filter.getHospitalNumber() != null && !filter.getHospitalNumber().isEmpty()) {
				Predicate condition = builder.equal(root.get("hospitalNumber"), filter.getHospitalNumber());
				p.add(condition);
			}

			if (filter.getInvoiceNo() != null && filter.getInvoiceNo() > 0) {
				Predicate condition = builder.equal(root.get("invoiceNo"), filter.getInvoiceNo());
				p.add(condition);
			}

			if (filter.getAdmissionNo() != null && filter.getAdmissionNo() > 0) {
				Predicate condition = builder.equal(root.get("admissionNo"), filter.getAdmissionNo());
				p.add(condition);
			}
			if (filter.getLabNo() != null && filter.getLabNo() > 0) {
				Predicate condition = builder.equal(root.get("labNo"), filter.getLabNo());
				p.add(condition);
			}
			if (filter.getPatientFrom() != null) {
				Predicate condition = builder.equal(root.get("patientFrom"), filter.getPatientFrom());
				p.add(condition);
			}
			if (filter.getFromDate() != null && filter.getToDate() != null) {
				Date fromDate = addHourMinutesSeconds(00, 00, 00, filter.getFromDate());
				Date toDate = addHourMinutesSeconds(23, 59, 59, filter.getToDate());
				Predicate condition = builder.between(root.get("invoiceDateTime"), fromDate, toDate);
				p.add(condition);
			}
			if (filter.getDepartmentNo() != null && filter.getDepartmentNo() > 0) {
				Predicate condition = builder.equal(root.get("departmentNo"), filter.getDepartmentNo());
				p.add(condition);
			}
			if (filter.getDeliveryStatusNo() != null && filter.getDeliveryStatusNo() > 0) {
				Predicate condition = builder.equal(root.get("deliveryStatusNo"), filter.getDeliveryStatusNo());
				p.add(condition);
			}
			if (filter.getCompanyNo() != null && filter.getCompanyNo() > 0) {
				Predicate condition = builder.equal(root.get("companyNo"), filter.getCompanyNo());
				p.add(condition);
			}
			
						
			Predicate regTypecondition1 = builder.isNotNull(root.get("regType"));
			p.add(regTypecondition1);
			
			Predicate regTypecondition2 = builder.notEqual(root.get("regType"), 11);
			p.add(regTypecondition2);

		}

		return p;
	}

	@SuppressWarnings({ "unused", "rawtypes" })
	private void init() {
		initEntityManagerBuilderCriteriaQueryRoot(ViewPathSamplePendingCollectionEntity.class);
		CriteriaBuilder builder = super.builder;
		CriteriaQuery criteria = super.criteria;
		Root root = super.root;
	}

}

Repo2
=====

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.Month;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.persistence.EntityManager;
import javax.persistence.ParameterMode;
import javax.persistence.StoredProcedureQuery;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.servlet.http.HttpServletRequest;

import org.apache.commons.lang.StringUtils;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;


import oracle.jdbc.OracleCallableStatement;
import oracle.jdbc.OracleTypes;

@Repository
@Transactional
public class OpdRegistrationRepositoryGlobal extends BaseRepository {

//	@Autowired
//	OpdRegistrationOthersGlobalRepository opdOtherRepository;
	@Autowired
	private CoreOpdRegistrationPhotoService opdRegistrationPhotoService;

	@Autowired
	private OpdRegistrationOthersGlobalRepository opdRegistrationOthersGlobalRepository;

//	@Autowired
//	private CoreCompanyService coreCompanyService;

	@Autowired
	private EntityManager entityManager;

	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Response gridList(HttpServletRequest request) {

		List<OpdRegistrationEntityGlobal> opdRegistrationEntityList;
		DataTableResults<OpdRegistrationEntityGlobal> dataTableResults = null;
		OpdRegistrationEntityGlobal opdRegistrationEntityGlobal = new OpdRegistrationEntityGlobal();

		String fromDateStr = request.getParameter("fromDate");
		String toDateStr = request.getParameter("toDate");
		String regPoint = request.getParameter("regPoint");
		String mobileNo = request.getParameter("mobileNo");

		String filterDob = request.getParameter("filterDob");

		try {

			if (regPoint != null && !regPoint.isEmpty()) {
				opdRegistrationEntityGlobal.setRegPoint(Integer.parseInt(regPoint));
			}

			Date fromDate = null;
			Date toDate = null;
			if (fromDateStr != null && toDateStr != null) {
				fromDate = clearTime(new SimpleDateFormat("dd/MM/yyyy").parse(fromDateStr));
				toDate = clearTime(new SimpleDateFormat("dd/MM/yyyy").parse(toDateStr));
			}
			if (fromDate != null && toDate != null) {
				opdRegistrationEntityGlobal.setFromDate(fromDate);
				opdRegistrationEntityGlobal.setToDate(toDate);
			}
			if (mobileNo != null) {
				opdRegistrationEntityGlobal.setPhoneMobile(mobileNo);
			}
			Date dob = null;
			if (filterDob != null) {
				dob = clearTime(new SimpleDateFormat("dd/MM/yyyy").parse(filterDob));
			}
			if (dob != null) {
				opdRegistrationEntityGlobal.setDob(dob);
			}
		} catch (Exception e) {
			System.err.println(e);
		}

		Response response = new Response();

		DataTableRequest dataTableInRQ = new DataTableRequest(request);
		Long totalRowCount = totalCount(opdRegistrationEntityGlobal);

		List gridList = new ArrayList<>();

		response = baseList(typedQuery(opdRegistrationEntityGlobal, dataTableInRQ));

		if (response.isSuccess()) {

			if (response.getItems() != null) {
				opdRegistrationEntityList = getListFromObject(response.getItems(), OpdRegistrationEntityGlobal.class);
				for (OpdRegistrationEntityGlobal opdReg : opdRegistrationEntityList) {

					if (opdReg.getPatientPhoto() != null && !opdReg.getPatientPhoto().isEmpty()
							&& !StringUtils.isBlank(opdReg.getPatientPhoto())) {
						Response responsePhoto = opdRegistrationPhotoService.findByPhotoName(opdReg.getPatientPhoto());
						if (responsePhoto.isSuccess() && responsePhoto.getObj() != null) {
							opdReg.setPhoto((String) responsePhoto.getObj());
						}
					}
					Response resRegOthers = opdRegistrationOthersGlobalRepository.findById(opdReg.getId());
					if (resRegOthers.isSuccess() && resRegOthers.getObj() != null) {
						OpdRegistrationOtherEntityGlobal regOthers = getValueFromObject(resRegOthers.getObj(),
								OpdRegistrationOtherEntityGlobal.class);
						opdReg.setBlackListPatient(regOthers.getBlackListPatient());
						opdReg.setVipPatientFlag(regOthers.getVipPatient());
						opdReg.setActiveStatus(regOthers.getActiveStatus());
					}
					// === added for card bill ======
					if (opdReg != null) {
						opdReg.setCardBilledStatus(findCardBillPaidStatus(opdReg.getId()));
					}
					// ==============================
					gridList.add(opdReg);
				}
			}
			dataTableResults = dataTableResults(dataTableInRQ,
					countTypedQuery(opdRegistrationEntityGlobal, dataTableInRQ), gridList, totalRowCount);
		}

		response.setItems(null);
		response.setObj(dataTableResults);
		return response;
	}

	public Response list(String reqObj) {
		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();
		if (null == reqObj) {
			getErrorResponse("please enter  parameter");
		}
		opdRegistrationEntity = objectMapperReadValue(reqObj, OpdRegistrationEntityGlobal.class);
		return baseList(criteriaQuery(opdRegistrationEntity));
	}

	public Response typeaheadPersonalNumber(String reqObj) {
		JSONObject json = new JSONObject(reqObj);
		String personalNumber = Def.getString(json, "personalNumber");

		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();

		if (null == personalNumber) {
			return getErrorResponse("please enter  personalnumber");
		}

		Map<String, Object> searchfields = new HashMap<String, Object>();
		searchfields.put("personalNumber", personalNumber);
		searchfields.put("coid", personalNumber);
		searchfields.put("personalId", personalNumber);

		return baseList(typedQuery(opdRegistrationEntity, searchfields));
	}

	public Response searchByHospitalNumber(String hospitalNumber) {

		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();

		if (isNullOrEmptyOrBlank(hospitalNumber)) {
			return getErrorResponse("please enter  hospital number");
		}

		opdRegistrationEntity.setLikeHospitalNumber(hospitalNumber);

		Response response = baseList(criteriaQuery(opdRegistrationEntity));

		if (response.isSuccess() && !CollectionUtils.isEmpty(response.getItems())) {
			List<OpdRegistrationEntityGlobal> registrationList = getListFromObject(response.getItems(),
					OpdRegistrationEntityGlobal.class);
			registrationList.stream().forEach(u -> u.setAge(functionPatientAge(u.getDob(), new Date())));

			Response filteredReponse = new Response();
			filteredReponse.setItems(registrationList);

			return filteredReponse;
		}
		return getSuccessResponse("Patient Not Found");
	}

	public Response patientInfoWithImageByMrn(String mrn) {

		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();

		if (isNullOrEmptyOrBlank(mrn)) {
			return getErrorResponse("please enter  hospital number");
		}

		opdRegistrationEntity.setHospitalNumber(mrn);

		Response response = baseSingleObject(criteriaQuery(opdRegistrationEntity));

		if (response.isSuccess() && response.getObj() != null) {
			OpdRegistrationEntityGlobal registration = getValueFromObject(response.getObj(),
					OpdRegistrationEntityGlobal.class);

			registration.setAge(functionPatientAge(registration.getDob(), new Date()));

			if (registration.getPatientPhoto() != null && !registration.getPatientPhoto().isEmpty()
					&& !StringUtils.isBlank(registration.getPatientPhoto())) {
				Response responsePhoto = opdRegistrationPhotoService.findByPhotoName(registration.getPatientPhoto());
				if (responsePhoto.isSuccess() && responsePhoto.getObj() != null) {
					registration.setPhoto((String) responsePhoto.getObj());
				}
			}

			Response finalReponse = new Response();
			finalReponse.setObj(registration);
			return getSuccessResponse("Patient Information Found.", finalReponse);

		}

		return getSuccessResponse("Patient Not Found");
	}

	public Response findById(Long id) {

		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();
		opdRegistrationEntity.setId(id);
		Response response = baseFindById(criteriaQuery(opdRegistrationEntity));
		if (response.isSuccess()) {
			return response;
		}
		return getErrorResponse("Record not Found !!");
	}

	public Response findByCriteria(String searchCriteria) {
		JSONObject searchCriteriaObj = new JSONObject(searchCriteria);

		Long id = Def.getLong(searchCriteriaObj, "id");
//		String personalNumber = Def.getString(searchCriteriaObj, "personalNumber");
//		String personalId = Def.getString(searchCriteriaObj, "personalId");

		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();
		opdRegistrationEntity.setId(id);

		Response response = baseFindById(criteriaQuery(opdRegistrationEntity));

		if (response.isSuccess() && response.getObj() != null) {
			return response;
		}
		return getErrorResponse("Data Not Found.");
	}

	public Response isExistence(Long id) {

		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();
		if (id != null) {
			opdRegistrationEntity.setNotEqualId(id);
		}
		Response response = baseFindById(criteriaQuery(opdRegistrationEntity));

		if (response.isSuccess() && response.getObj() != null) {
			return response;
		}
		return getErrorResponse("Data Not Exist.");
	}

	public Response registraionValidation(String reqObj) {
//
//        JSONObject json = new JSONObject(reqObj);
//
//        String checkingId = Def.getString(json, "checkingId");
//        String checkingType = Def.getString(json, "checkingType");
//        Long lookupdtlNo = Def.getLong(json, "lookupdtlNo");
//        Response reponse = storedProcedureRegitValidate(checkingId, checkingType, lookupdtlNo);
//
//        Map<String, Object> validationMap = (Map<String, Object>) reponse.getObj();
//
////        validationMap.put("serviceHolderDetails", findByPersonalNo(checkingId));
//
//        reponse.setObj(validationMap);
//
//        return reponse;
		return null;
	}

	public Response save(String userCreate, String opdRegistrationStr, UserSignInContainter userDetails,
			String hospitalId, Long regNo) {

		JSONObject json = new JSONObject(opdRegistrationStr);
		String opdReg = Def.getString(json, "opdReg");
		String opdRegOthers = Def.getString(json, "opdRegOthers");

		OpdRegistrationOtherEntityGlobal opdRegOther = new OpdRegistrationOtherEntityGlobal();
		OpdRegistrationEntityGlobal opdRegistrationEntity = objectMapperReadValue(opdReg,
				OpdRegistrationEntityGlobal.class);
		opdRegOther = objectMapperReadValue(opdRegOthers, OpdRegistrationOtherEntityGlobal.class);

		opdRegistrationEntity.setDob(clearTime(opdRegistrationEntity.getDob()));
		opdRegistrationEntity.setSsCreator(userDetails.getUserId());
		opdRegistrationEntity.setSsCreatedOn(new Date());
		opdRegistrationEntity.setSsCreateSession(userDetails.getSessionNo());
		// for sorting the worklist by latest edit
		opdRegistrationEntity.setSsModifier(userDetails.getUserId());
		opdRegistrationEntity.setSsModifiedOn(new Date());
		opdRegistrationEntity.setSsModifiedSession(userDetails.getSessionNo());

		opdRegistrationEntity.setHospitalNumber(hospitalId);
		opdRegistrationEntity.setId(regNo);
		opdRegistrationEntity.setRegDate(new Date());
		opdRegistrationEntity.setCompanyNo(userDetails.getCompanyNo());

		Response response = baseOnlySave(opdRegistrationEntity);

		if (response.isSuccess()) {
			OpdRegistrationEntityGlobal savedEntity = getValueFromObject(response.getObj(),
					OpdRegistrationEntityGlobal.class);

			opdRegOther.setSsCreatedOn(new Date());
			opdRegOther.setSsCreateSession(userDetails.getSessionNo());
			opdRegOther.setSsCreator(userDetails.getUserId());
			opdRegOther.setCompanyNo(userDetails.getCompanyNo());
			opdRegOther.setId(savedEntity.getId());

			Response response2 = baseOnlySave(opdRegOther);

			if (response2.isSuccess()) {
				if (userCreate != null && userCreate.equals("true")) {
					System.out.println("User create done when Registration !");
					storedProcedureCreateAnonymousUser(regNo, hospitalId, opdRegistrationEntity.getGender(),
							userDetails.getCompanyNo(), userDetails.getSessionNo(), userDetails.getEcodPass(),
							userDetails.getPlainPass(), "external-service/patient-portal/patient-report", "ES01-PP",
							opdRegistrationEntity.getPhoneMobile(), opdRegistrationEntity.getFname(),
							userDetails.getUserId());
				}
			}
		} else {
			return getErrorResponse("Registration creation failed initially");
		}
		return response;
	}

	public Response saveWithImage(String isUserCreate, MultipartFile file, String opdRegistrationStr,
			UserSignInContainter userDetails, String hospitalId, Long regNo) {

		Response response = new Response();
		JSONObject json = new JSONObject(opdRegistrationStr);
		String opdReg = Def.getString(json, "opdReg");
		String opdRegOthers = Def.getString(json, "opdRegOthers");

		OpdRegistrationEntityGlobal opdRegistrationEntity = objectMapperReadValue(opdReg,
				OpdRegistrationEntityGlobal.class);

		// ==== for checking passport number exist or not ======================
		if (isPassportTimeLimitCheck() && !StringUtils.isEmpty(opdRegistrationEntity.getPassportNo())
				&& opdRegistrationEntity.getIsPassportNoApproved() == 0) {
			OpdRegistrationEntityGlobal opdRegistrationObj = checkPassport(opdRegistrationEntity.getPassportNo());

			if (opdRegistrationObj != null) {
				Long hours = findDifferenceTwoDate(new Date(), opdRegistrationObj.getSsCreatedOn());

				if (hours.longValue() < passportTimePeriodHR().longValue()) {
					return getErrorResponse("Invalid");
				}
			}
		}
		// =======================================================================

		OpdRegistrationOtherEntityGlobal opdRegOther = new OpdRegistrationOtherEntityGlobal();
		opdRegOther = objectMapperReadValue(opdRegOthers, OpdRegistrationOtherEntityGlobal.class);

		opdRegistrationEntity.setDob(clearTime(opdRegistrationEntity.getDob()));

		opdRegistrationEntity.setSsCreator(userDetails.getUserId());
		opdRegistrationEntity.setSsCreatedOn(new Date());
		opdRegistrationEntity.setSsCreateSession(userDetails.getSessionNo());
		// for sorting the worklist by latest edit
		opdRegistrationEntity.setSsModifier(userDetails.getUserId());
		opdRegistrationEntity.setSsModifiedOn(new Date());
		opdRegistrationEntity.setSsModifiedSession(userDetails.getSessionNo());

		opdRegistrationEntity.setHospitalNumber(hospitalId);
		opdRegistrationEntity.setId(regNo);
		opdRegistrationEntity.setRegDate(new Date());
		opdRegistrationEntity.setCompanyNo(userDetails.getCompanyNo());

		// Image file
		if (file != null) {
			opdRegistrationEntity.setPatientPhoto(Def.customFileName(file, opdRegistrationEntity.getHospitalNumber()));
		}

		response = baseOnlySave(opdRegistrationEntity);

		if (response.isSuccess()) {
			OpdRegistrationEntityGlobal savedEntity = getValueFromObject(response.getObj(),
					OpdRegistrationEntityGlobal.class);

			if (file != null) {
				opdRegistrationPhotoService.storePhotoToFile(file, opdRegistrationEntity.getHospitalNumber());
			}

			opdRegOther.setSsCreatedOn(new Date());
			opdRegOther.setSsCreateSession(userDetails.getSessionNo());
			opdRegOther.setSsCreator(userDetails.getUserId());
			opdRegOther.setCompanyNo(userDetails.getCompanyNo());
			opdRegOther.setId(savedEntity.getId());

			Response response2 = baseOnlySave(opdRegOther);

			if (response2.isSuccess() && response2.getObj() != null) {

				if (isUserCreate != null && isUserCreate.equals("true")) {

					storedProcedureCreateAnonymousUser(regNo, hospitalId, opdRegistrationEntity.getGender(),
							userDetails.getCompanyNo(), userDetails.getSessionNo(), userDetails.getEcodPass(),
							userDetails.getPlainPass(), "external-service/patient-portal/patient-report", "ES01-PP",
							opdRegistrationEntity.getPhoneMobile(), opdRegistrationEntity.getFname(),
							userDetails.getUserId());
				}
			}
		} else {
			return getErrorResponse("Registration creation failed initially");
		}
		return response;
	}

	private OpdRegistrationEntityGlobal checkPassport(String passportNo) {

		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();
		opdRegistrationEntity.setPassportNo(passportNo);
		Response response = baseTop1(criteriaQuery(opdRegistrationEntity, "DESC", "ssCreatedOn"));

		if (response.isSuccess() && response.getObj() != null) {
			return getValueFromObject(response.getObj(), OpdRegistrationEntityGlobal.class);
		}
		return null;
	}

	public Response updateWithImage(MultipartFile file, String opdRegistrationStr, UserSignInContainter userDetails) {

		JSONObject json = new JSONObject(opdRegistrationStr);
		String opdReg = Def.getString(json, "opdReg");
		String opdRegOthers = Def.getString(json, "opdRegOthers");

		OpdRegistrationEntityGlobal opdRegistrationEntity = objectMapperReadValue(opdReg,
				OpdRegistrationEntityGlobal.class);
		OpdRegistrationOtherEntityGlobal opdRegOther = objectMapperReadValue(opdRegOthers,
				OpdRegistrationOtherEntityGlobal.class);

		Response response = findById(opdRegistrationEntity.getId());
		OpdRegistrationEntityGlobal obj = getValueFromObject(response.getObj(), OpdRegistrationEntityGlobal.class);

		if (obj != null) {
			opdRegistrationEntity.setDob(clearTime(opdRegistrationEntity.getDob()));
			opdRegistrationEntity.setSsModifier(userDetails.getUserId());
			opdRegistrationEntity.setSsModifiedSession(userDetails.getSessionNo());
			opdRegistrationEntity.setSsModifiedOn(new Date());

			// Image file
			if (file != null) {
				opdRegistrationEntity
						.setPatientPhoto(Def.customFileName(file, opdRegistrationEntity.getHospitalNumber()));
			}

			response = baseSaveOrUpdate(opdRegistrationEntity);

			if (response.isSuccess() && file != null) {
				opdRegistrationPhotoService.storePhotoToFile(file, opdRegistrationEntity.getHospitalNumber());
			}

			opdRegOther.setId(opdRegistrationEntity.getId());
			opdRegOther.setSsModifiedOn(new Date());
			opdRegOther.setSsModifiedSession(userDetails.getSessionNo());
			opdRegOther.setSsModifier(userDetails.getUserId());

			Response otherDataRes = baseUpdate(opdRegOther);
			if (otherDataRes.isSuccess()) {
				return response;
			} else {
				return getErrorResponse("Update Failed !!");
			}
		}
		return getErrorResponse("Record not Found !!");
	}

	public Response update(String opdRegistrationStr, UserSignInContainter userDetails) {
		JSONObject json = new JSONObject(opdRegistrationStr);
		String opdReg = Def.getString(json, "opdReg");
		String opdRegOthers = Def.getString(json, "opdRegOthers");

		OpdRegistrationEntityGlobal opdRegistrationEntity = objectMapperReadValue(opdReg,
				OpdRegistrationEntityGlobal.class);
		OpdRegistrationOtherEntityGlobal opdRegOther = objectMapperReadValue(opdRegOthers,
				OpdRegistrationOtherEntityGlobal.class);

		Response response = findById(opdRegistrationEntity.getId());
		OpdRegistrationEntityGlobal obj = getValueFromObject(response.getObj(), OpdRegistrationEntityGlobal.class);

		if (obj != null) {
			opdRegistrationEntity.setDob(clearTime(opdRegistrationEntity.getDob()));
			opdRegistrationEntity.setSsModifier(userDetails.getUserId());
			opdRegistrationEntity.setSsModifiedSession(userDetails.getSessionNo());
			opdRegistrationEntity.setSsModifiedOn(new Date());

			response = baseUpdate(opdRegistrationEntity);

			opdRegOther.setId(opdRegistrationEntity.getId());
			opdRegOther.setSsModifiedOn(new Date());
			opdRegOther.setSsModifiedSession(userDetails.getSessionNo());
			opdRegOther.setSsModifier(userDetails.getUserId());

			return baseUpdate(opdRegOther);

		}
		return getErrorResponse("Record not Found !!");
	}

	public Response delete(Long id) {
		Response response = new Response();
		response = findById(id);
		OpdRegistrationEntityGlobal opdMain = getValueFromObject(response.getObj(), OpdRegistrationEntityGlobal.class);
		if (opdMain == null) {
			return getErrorResponse("Record not found!");
		}
		response = findOpdOtherById(id);
		OpdRegistrationOtherEntityGlobal opdOther = getValueFromObject(response.getObj(),
				OpdRegistrationOtherEntityGlobal.class);
		if (opdOther == null) {
			return getErrorResponse("Record not found!");
		}
		response = baseDelete(opdOther);
		if (response.isSuccess()) {
			return baseDelete(opdMain);
		}
		return response;
	}

	public Response remove(Long id) {
		Response response = new Response();
		response = findById(id);
		OpdRegistrationEntityGlobal opdRegistrationEntity = getValueFromObject(response.getObj(),
				OpdRegistrationEntityGlobal.class);
		if (opdRegistrationEntity == null) {
			return getErrorResponse("Record not found!");
		}
		opdRegistrationEntity.setActiveStatus(3);
		return baseRemove(opdRegistrationEntity);
	}

	public Response findOpdOtherById(Long id) {
		return opdRegistrationOthersGlobalRepository.findById(id);
	}

	public Response findByHospitalNumber(String hospitalNumber) {

		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();

		Response HNresponse = null;

		System.err.println("Is Digit ==> " + strStartWithDigit(hospitalNumber));
		if (strStartWithDigit(hospitalNumber)) {
			System.err.println("hospitalNumber ==> " + hospitalNumber);
			HNresponse = advanceSearchByHN(hospitalNumber);
		}

		if (null != HNresponse && HNresponse.isSuccess()) {

			@SuppressWarnings("unchecked")
			HashMap<String, Object> hnMap = (HashMap<String, Object>) HNresponse.getObj();
			hospitalNumber = (String) hnMap.get("hospitalNumber");

			System.err.println("Return HospitalNumber ==> " + hospitalNumber);
		}
		opdRegistrationEntity.setHospitalNumber(hospitalNumber);

		// Response response = baseFindById(criteriaQuery(opdRegistrationEntity));
		Response response = baseFindByIdReadOnly(criteriaQuery(opdRegistrationEntity));

		if (response.isSuccess() && response.getObj() != null) {

			OpdRegistrationEntityGlobal opdRegistrationEntityGlobal = getValueFromObject(response.getObj(),
					OpdRegistrationEntityGlobal.class);
			opdRegistrationEntityGlobal.setAge(functionPatientAge(opdRegistrationEntityGlobal.getDob(), new Date()));

			response.setObj(opdRegistrationEntityGlobal);

			return response;
		}
		return getErrorResponse("Record not Found !!");
	}

	public Response advanceSearchByHN(String hospitalNumber) {

		return baseAdvanceSearchByHN(hospitalNumber);

	}

	public OpdRegistrationEntityGlobal findObjByHospitalNumber(String hospitalNumber) {

		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();
		opdRegistrationEntity.setHospitalNumber(hospitalNumber);

		// Response response = baseFindById(criteriaQuery(opdRegistrationEntity));
		Response response = baseFindByIdReadOnly(criteriaQuery(opdRegistrationEntity));

		if (response.isSuccess() && response.getObj() != null) {
			OpdRegistrationEntityGlobal opdRegistrationEntityGlobal = getValueFromObject(response.getObj(),
					OpdRegistrationEntityGlobal.class);
			opdRegistrationEntityGlobal.setAge(functionPatientAge(opdRegistrationEntityGlobal.getDob(), new Date()));
			return opdRegistrationEntityGlobal;
		}
		return null;
	}

	public Response findByPhoneNo(String phoneMobile) {
		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();
		opdRegistrationEntity.setPhoneMobile(phoneMobile);
		Response response = baseList(criteriaQuery(opdRegistrationEntity));

		if (response.isSuccess() && response.getItems() != null) {
//			List<OpdRegistrationEntityGlobal> opdRegistrationList = new ArrayList<OpdRegistrationEntityGlobal>();
			List<OpdRegistrationEntityGlobal> opdRegistrationEntityList = getListFromObject(response.getItems(),
					OpdRegistrationEntityGlobal.class);
			for (OpdRegistrationEntityGlobal opdRegistrationEntityGlobal : opdRegistrationEntityList) {
				opdRegistrationEntityGlobal.setAge(functionPatientAge(opdRegistrationEntity.getDob(), new Date()));
//				opdRegistrationList.add(opdRegistrationEntityGlobal);
			}
			response.setItems(opdRegistrationEntityList);
			return response;
		}
		return getErrorResponse("Record not Found !!");
	}

	public Response findByPhoneNoOrHNo(String phoneMobile) {
		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();
		opdRegistrationEntity.setPhoneOrHNo(phoneMobile);
		Response response = baseList(criteriaQuery(opdRegistrationEntity));

		if (response.isSuccess() && response.getItems() != null) {
//			List<OpdRegistrationEntityGlobal> opdRegistrationList = new ArrayList<OpdRegistrationEntityGlobal>();
			List<OpdRegistrationEntityGlobal> opdRegistrationEntityList = getListFromObject(response.getItems(),
					OpdRegistrationEntityGlobal.class);
			for (OpdRegistrationEntityGlobal opdRegistrationEntityGlobal : opdRegistrationEntityList) {
				opdRegistrationEntityGlobal.setAge(functionPatientAge(opdRegistrationEntity.getDob(), new Date()));
//				opdRegistrationList.add(opdRegistrationEntityGlobal);
			}
			response.setItems(opdRegistrationEntityList);
			return response;
		}
		return getErrorResponse("Record not Found !!");
	}

	public Response passportKioskTokenDetails(String reqObj) {
		PassportKioskResDto passKioskRes = null;
		JSONObject json = Def.getJSONObject(reqObj);
		if (reqObj == null || reqObj.equals("{}")) {
			return getErrorResponse("No Request Param found");
		}
		Response response = new Response();
		String tokenNo = Def.getString(json, "tokenNo");
		String passportNo = Def.getString(json, "passportNo");

		String filePaht = loadPassportJson();
		Map<String, Object> _mp = readPassportJsonFile(filePaht);

		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		JSONObject personJsonObject = new JSONObject();
		personJsonObject.put("api_client_id", _mp.get("api_client_id").toString());
		personJsonObject.put("secret_code", _mp.get("secret_code").toString());
//		MultiValueMap<String, String> map = new LinkedMultiValueMap<String, String>();
		HttpEntity<String> request = new HttpEntity<String>(personJsonObject.toString(), headers);
		// HttpEntity<MultiValueMap<String, String>> entity = new
		// HttpEntity<MultiValueMap<String, String>>(map, headers);
		String responseStr = null;
		responseStr = restTemplatePostCalling(_mp.get("token_url").toString(), request);
		if (responseStr != null) {
			JSONObject tokenResponse4 = Def.getJSONObject(responseStr);
			String authToken = Def.getString(tokenResponse4, "token");

			HttpHeaders headers1 = new HttpHeaders();
			headers1.setContentType(MediaType.APPLICATION_JSON);
			headers1.set("Client-Id", _mp.get("api_client_id").toString());
			headers1.set("Token-Key", authToken);

			JSONObject personJsonObject1 = new JSONObject();
			personJsonObject1.put("tokenNo", JSONObject.NULL);
			personJsonObject1.put("passportNo", JSONObject.NULL);
			if (tokenNo != null) {
				personJsonObject1.put("tokenNo", tokenNo);
			}
			if (passportNo != null) {
				personJsonObject1.put("passportNo", passportNo);
			}
			// personJsonObject1.put("tokenDate", "2021-03-08");
			HttpEntity<String> request1 = new HttpEntity<String>(personJsonObject1.toString(), headers1);
			responseStr = restTemplatePostCalling(_mp.get("token_detail_url").toString(), request1);
			if (responseStr != null) {
				JSONObject tokenResponse5 = Def.getJSONObject(responseStr);
				String dataStr = Def.getString(tokenResponse5, "data");
				if (dataStr != null && !dataStr.equals("{}")) {
					passKioskRes = new PassportKioskResDto();
					passKioskRes = objectMapperReadValue(dataStr, PassportKioskResDto.class);
				}
				if (passKioskRes.getPassportInfo() != null) {
					response.setSuccess(true);
					response.setObj(passKioskRes);
					return response;
				}
			}
		}

		return getErrorResponse("data not found");
	}

	private String restTemplatePostCalling(String url, HttpEntity<String> request) {

		String response = null;

		RestTemplate restTemplate = new RestTemplate();

		try {
			response = restTemplate.postForObject(url, request, String.class);

		} catch (HttpClientErrorException e) {

			System.out.println(e.getMessage());
		}

		return response;
	}

	public Response findByPhoneMobile(String reqObj) {
		OpdRegistrationEntityGlobal opdRegistrationEntity = new OpdRegistrationEntityGlobal();
		if (null == reqObj) {
			return getErrorResponse("please enter parameter");
		}
		opdRegistrationEntity = objectMapperReadValue(reqObj, OpdRegistrationEntityGlobal.class);
		return baseList(criteriaQuery(opdRegistrationEntity));
	}

	// ========= for OPD registration layout 2 =====================================
	public Response saveOpdRegLayout2(String reqObj, UserSignInContainter userDetails, String hospitalId, Long regNo) {

		OpdRegistrationEntityGlobal opdRegistrationEntity = objectMapperReadValue(reqObj,
				OpdRegistrationEntityGlobal.class);

		opdRegistrationEntity.setDob(clearTime(opdRegistrationEntity.getDob()));

		opdRegistrationEntity.setSsCreator(userDetails.getUserId());
		opdRegistrationEntity.setSsCreatedOn(new Date());
		opdRegistrationEntity.setSsCreateSession(userDetails.getSessionNo());
		opdRegistrationEntity.setSsModifier(userDetails.getUserId());
		opdRegistrationEntity.setSsModifiedOn(new Date());
		opdRegistrationEntity.setSsModifiedSession(userDetails.getSessionNo());
		opdRegistrationEntity.setCompanyNo(userDetails.getCompanyNo());

		opdRegistrationEntity.setHospitalNumber(hospitalId);
		opdRegistrationEntity.setId(regNo);
		opdRegistrationEntity.setRegDate(new Date());

		Response response = baseOnlySave(opdRegistrationEntity);

		if (response.isSuccess()) {
			OpdRegistrationEntityGlobal opdRegistrationEntityGlobal = getValueFromObject(response.getObj(),
					OpdRegistrationEntityGlobal.class);

			OpdRegistrationOtherEntityGlobal opdRegistrationOtherEntityGlobal = objectMapperReadValue(reqObj,
					OpdRegistrationOtherEntityGlobal.class);
			opdRegistrationOtherEntityGlobal.setId(opdRegistrationEntityGlobal.getId());

			Response finalResp = opdRegistrationOthersGlobalRepository.saveOrUpdate(opdRegistrationOtherEntityGlobal,
					userDetails);
			if (finalResp.isSuccess()) {
				return getSuccessResponse("Registration Save Successfully.", response);
			}
			return getErrorResponse("Registration Other Data Save failed!!", response);
		}
		return getErrorResponse("Registration failed!!", response);

	}

	public Response updateOpdRegLayout2(String reqObj, UserSignInContainter userDetails) {

		OpdRegistrationEntityGlobal opdRegistrationEntity = objectMapperReadValue(reqObj,
				OpdRegistrationEntityGlobal.class);

		Response response = findById(opdRegistrationEntity.getId());
		OpdRegistrationEntityGlobal obj = getValueFromObject(response.getObj(), OpdRegistrationEntityGlobal.class);

		if (obj != null) {
			opdRegistrationEntity.setSsCreator(obj.getSsCreator());
			opdRegistrationEntity.setSsCreatedOn(obj.getSsCreatedOn());
			opdRegistrationEntity.setSsCreateSession(obj.getSsCreateSession());
			opdRegistrationEntity.setCompanyNo(obj.getCompanyNo());

			opdRegistrationEntity.setDob(clearTime(opdRegistrationEntity.getDob()));
			opdRegistrationEntity.setSsModifier(userDetails.getUserId());
			opdRegistrationEntity.setSsModifiedSession(userDetails.getSessionNo());
			opdRegistrationEntity.setSsModifiedOn(new Date());

			response = baseUpdate(opdRegistrationEntity);
		}
		if (response.isSuccess()) {
			OpdRegistrationOtherEntityGlobal opdRegistrationOtherEntityGlobal = objectMapperReadValue(reqObj,
					OpdRegistrationOtherEntityGlobal.class);

			Response finalResp = opdRegistrationOthersGlobalRepository.saveOrUpdate(opdRegistrationOtherEntityGlobal,
					userDetails);
			if (finalResp.isSuccess()) {
				return getSuccessResponse("Registration Updated Successfully.", response);
			}
			return getErrorResponse("Registration Other Data Updated Failed!!");
		}
		return getErrorResponse("Record not Found !!");
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Response gridListOpdRegLayout2(HttpServletRequest request, UserSignInContainter userDetails) {

		DataTableResults<OpdRegistrationEntityGlobal> dataTableResults = null;
		OpdRegistrationEntityGlobal opdRegistrationEntityGlobal = new OpdRegistrationEntityGlobal();

		String fromDate = request.getParameter("fromDate");
		String toDate = request.getParameter("toDate");
		String filterDob = request.getParameter("filterDob");
		Long userNo = userDetails.getUserId();

		try {
			if (fromDate != null && toDate != null) {
				opdRegistrationEntityGlobal.setFromDate(clearTime(deateParse(fromDate, "dd/MM/yyyy")));
				opdRegistrationEntityGlobal.setToDate(clearTime(deateParse(toDate, "dd/MM/yyyy")));
			}
			if (filterDob != null) {
				opdRegistrationEntityGlobal.setDob(clearTime(deateParse(filterDob, "dd/MM/yyyy")));
			}
			if (userNo != null) {
				opdRegistrationEntityGlobal.setSsCreator(userNo);
			}

		} catch (Exception e) {
			System.err.println(e);
		}

		Response response = new Response();

		DataTableRequest dataTableInRQ = new DataTableRequest(request);
		Long totalRowCount = totalCount(opdRegistrationEntityGlobal);

		List gridList = new ArrayList<>();

		response = baseList(typedQuery(opdRegistrationEntityGlobal, dataTableInRQ));

		if (response.isSuccess()) {
			if (response.getItems() != null) {
				gridList = response.getItems();
			}
			dataTableResults = dataTableResults(dataTableInRQ, gridList, gridList, totalRowCount);
		}

		response.setItems(null);
		response.setObj(dataTableResults);
		return response;
	}
	// ===================================

	// ====== for save card bill =================================
	public Response saveCardBill(String reqObj, UserSignInContainter userDetails) {

		if (reqObj == null) {
			return getErrorResponse("Request data not found!!");
		}

		Map<String, Object> result = new HashMap<>();
		Response response = new Response();

		CardBillDto cardBillDto = new CardBillDto();
		cardBillDto = objectMapperReadValue(reqObj, CardBillDto.class);

		Long paidStatus = findCardBillPaidStatus(cardBillDto.getRegNo());
		if (paidStatus != null && paidStatus == 1) {
			response.setSuccess(false);
			result.put("actionFlag", 0);
			result.put("error", "MRN Card Bill Already Paid !!");
			response.setModel(result);
			return response;
		}

		Connection dbConnection = null;
		OracleCallableStatement orcs = null;

		try {
			int indexPosition = 0;
			dbConnection = getOraConnection();
			orcs = (OracleCallableStatement) dbConnection.prepareCall(procedureQuery("PD_OPD_REG_COLL_SAVE_WEB", 20));

			orcs.setBigDecimal(++indexPosition, convertLongToBigDecimmal(cardBillDto.getRegNo()));

			Def.setLongArray(++indexPosition, cardBillDto.getPayMode(), orcs);
			Def.setDoubleArray(++indexPosition, cardBillDto.getPayAmt(), orcs);
			Def.setDoubleArray(++indexPosition, cardBillDto.getGivenAmt(), orcs);
			Def.setLongArray(++indexPosition, cardBillDto.getPayTypeNo(), orcs);
			Def.setLongArray(++indexPosition, cardBillDto.getChequeNo(), orcs);
			Def.setStringArray(++indexPosition, cardBillDto.getBankName(), orcs);

			orcs.setBigDecimal(++indexPosition, convertLongToBigDecimmal(cardBillDto.getPayIndex()));
			orcs.setBigDecimal(++indexPosition, convertDoubleToBigDecimmal(cardBillDto.getDiscAmount()));
			orcs.setBigDecimal(++indexPosition, convertLongToBigDecimmal(cardBillDto.getDisctypeNo()));
			orcs.setBigDecimal(++indexPosition, convertLongToBigDecimmal(cardBillDto.getDiscAuthBy()));
			orcs.setString(++indexPosition, cardBillDto.getDiscRemarks());

			orcs.setBigDecimal(++indexPosition, convertLongToBigDecimmal(userDetails.getUserId()));
			orcs.setBigDecimal(++indexPosition, convertLongToBigDecimmal(userDetails.getSessionNo()));
			orcs.setBigDecimal(++indexPosition, convertLongToBigDecimmal(userDetails.getOrganizationNo()));
			orcs.setBigDecimal(++indexPosition, convertLongToBigDecimmal(userDetails.getCompanyNo()));

			orcs.registerOutParameter(++indexPosition, OracleTypes.NUMBER);
			orcs.registerOutParameter(++indexPosition, OracleTypes.VARCHAR);
			orcs.registerOutParameter(++indexPosition, OracleTypes.NUMBER);
			orcs.registerOutParameter(++indexPosition, OracleTypes.VARCHAR);

			orcs.execute();

			result.put("invoiceNo", orcs.getLong(17));
			result.put("invoiceId", orcs.getString(18));
			result.put("actionFlag", orcs.getLong(19));
			result.put("error", orcs.getString(20));

		} catch (SQLException e) {
			e.printStackTrace();
			System.out.println("Error : " + e);
		} finally {
			Def.connectionClose(dbConnection, orcs);
		}
		response.setModel(result);
		return response;
	}

	private Long findCardBillPaidStatus(Long regNo) {

		int index = 0;
		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("pd_opd_bill_inv_check_web")

				.registerStoredProcedureParameter(++index, Long.class, ParameterMode.IN)

				.registerStoredProcedureParameter(++index, Long.class, ParameterMode.OUT)
				.registerStoredProcedureParameter(++index, String.class, ParameterMode.OUT)

				.setParameter(1, regNo);

		query.execute();

		Long cardBillStatus = (Long) query.getOutputParameterValue(2);
		String p_error = (String) query.getOutputParameterValue(3);

		System.out.println("card bill status error ===>" + p_error);
		if (cardBillStatus == null) {
			return 2L;
		}
		return cardBillStatus;
	}

	public Response getHnCardInvoiceReportData(Long invoiceNo) {

		Map<String, Object> result = new HashMap<String, Object>();

		Response response = new Response();
//		JSONObject json = new JSONObject(reqObj);
//		Long invoiceNo = Def.getLong(json, "invoiceNo");

		ResultSet rs = null;
		ResultSet rs2 = null;

		int index = 0;

		StoredProcedureQuery query = entityManager.createStoredProcedureQuery("pd_hn_card_bill_rep_web")
				.registerStoredProcedureParameter(++index, Long.class, ParameterMode.IN)
				.registerStoredProcedureParameter(++index, Void.class, ParameterMode.REF_CURSOR)
				.registerStoredProcedureParameter(++index, Void.class, ParameterMode.REF_CURSOR)
				.setParameter(1, invoiceNo);
		query.execute();

		List<HnCardInvoiceReportDto> invoiceReportDtlList = new ArrayList<HnCardInvoiceReportDto>();
		List<HnCardInvoiceSummeryDto> invoiceReportPaymentList = new ArrayList<HnCardInvoiceSummeryDto>();

		try {

			// ================ Report Item Data ====================================
			rs = (ResultSet) query.getOutputParameterValue(2);

			while (rs != null && rs.next()) {

				HnCardInvoiceReportDto invoiceReportDtlObj = new HnCardInvoiceReportDto();
				invoiceReportDtlObj.setInvoiceNo(rs.getLong("invoice_no"));
				invoiceReportDtlObj.setInvoiceId(rs.getString("invoice_id"));
				invoiceReportDtlObj.setBarcode(rs.getString("barcode"));
				invoiceReportDtlObj.setInvoiceDateTime(rs.getTimestamp("invoice_datetime"));
				invoiceReportDtlObj.setRegNo(rs.getLong("reg_no"));
				invoiceReportDtlObj.setHospitalNumber(rs.getString("hospital_number"));
				invoiceReportDtlObj.setHnBarcode(rs.getString("hn_barcode"));
				invoiceReportDtlObj.setAdmissionNo(rs.getLong("admission_no"));
				invoiceReportDtlObj.setAdmissionId(rs.getString("admission_id"));
				invoiceReportDtlObj.setRefDocNo(rs.getLong("ref_doc_no"));
				invoiceReportDtlObj.setRefDocName(rs.getString("ref_doc_name"));
				invoiceReportDtlObj.setRemarks(rs.getString("remarks"));
				invoiceReportDtlObj.setSsCreator(rs.getLong("ss_creator"));
				invoiceReportDtlObj.setSsCreatorName(rs.getString("ss_creator_name"));
				invoiceReportDtlObj.setCorClientNo(rs.getLong("cor_client_no"));
				invoiceReportDtlObj.setCorClientCardNo(rs.getLong("cor_client_card_no"));
				invoiceReportDtlObj.setCorClient(rs.getString("cor_client"));
				invoiceReportDtlObj.setEmpNo(rs.getLong("emp_no"));
				invoiceReportDtlObj.setRelationNo(rs.getLong("relation_no"));
				invoiceReportDtlObj.setPatientname(rs.getString("patient_name"));
				invoiceReportDtlObj.setAge(rs.getString("age"));
				invoiceReportDtlObj.setGender(rs.getString("gender"));
				invoiceReportDtlObj.setPhoneMobile(rs.getString("phone_mobile"));
				invoiceReportDtlObj.setItemId(rs.getString("item_id"));
				invoiceReportDtlObj.setItemNo(rs.getLong("item_no"));
				invoiceReportDtlObj.setItemTypeNo(rs.getLong("itemtype_no"));
				invoiceReportDtlObj.setItemName(rs.getString("item_name"));
				invoiceReportDtlObj.setItemRate(rs.getDouble("item_rate"));
				invoiceReportDtlObj.setItemVat(rs.getDouble("item_vat"));
				invoiceReportDtlObj.setUrgentFee(rs.getDouble("urgent_fee"));
				invoiceReportDtlObj.setServiceCharge(rs.getDouble("service_charge"));
				invoiceReportDtlObj.setItemQty(rs.getLong("item_qty"));
				invoiceReportDtlObj.setItemRateTotal(rs.getDouble("item_rate_total"));
				invoiceReportDtlObj.setItemVatTotal(rs.getDouble("item_vat_total"));
				invoiceReportDtlObj.setUrgentFeeTotal(rs.getDouble("urgent_fee_total"));
				invoiceReportDtlObj.setServiceChargeTotal(rs.getDouble("service_charge_total"));
				invoiceReportDtlObj.setAdvance(rs.getDouble("advance"));
				invoiceReportDtlObj.setDiscAmt(rs.getDouble("disc_amt"));
				invoiceReportDtlObj.setDue(rs.getDouble("due"));

//				invoiceReportDtlObj.setDeliveryStatusNo(rs2.getLong("delivery_status_no"));
//				invoiceReportDtlObj.setPackageItemFlag(rs2.getLong("package_item_flag"));
//				invoiceReportDtlObj.setColectedByName(rs.getString("USER_NAME"));

				invoiceReportDtlList.add(invoiceReportDtlObj);
			}

			// ================ Report Payment Data ====================================

			rs2 = (ResultSet) query.getOutputParameterValue(3);

			while (rs2 != null && rs2.next()) {
				HnCardInvoiceSummeryDto invoiceReportPaymentObj = new HnCardInvoiceSummeryDto();

				invoiceReportPaymentObj.setPayNo(rs2.getLong("pay_no"));
				invoiceReportPaymentObj.setPayAmt(rs2.getDouble("pay_amt"));
				invoiceReportPaymentObj.setPayModeName(rs2.getString("pay_mode_name"));
				invoiceReportPaymentObj.setGivenAmt(rs2.getLong("given_amt"));
				invoiceReportPaymentObj.setPayTypeName(rs2.getString("pay_type_name"));
				invoiceReportPaymentObj.setColectedByName(rs2.getString("user_name"));

				invoiceReportPaymentList.add(invoiceReportPaymentObj);
			}

		} catch (SQLException e) {
			e.printStackTrace();
			response.setSuccess(false);
			response.setMessage("Data not found !");
		} finally {
			try {
				if (rs != null) {
					rs.close();
				}
				if (rs2 != null) {
					rs2.close();
				}
			} catch (SQLException e) {
				e.printStackTrace();
			}
		}

		if (!response.isSuccess()) {
			return getErrorResponse("Data not found!");
		}

		result.put("invoiceReportDtlList", invoiceReportDtlList);
		result.put("invoiceReportPaymentList", invoiceReportPaymentList);

		response.setModel(result);

		return getSuccessResponse("Data found", response);

	}

	public Response findPatByHospitalNumber(String reqObj) {

		JSONObject json = new JSONObject(reqObj);
		String hospitalNumber = Def.getString(json, "HOSPITAL_NUMBER");

		Response response = findByHospitalNumber(hospitalNumber);

		if (response.isSuccess() && response.getObj() != null) {

			OpdRegistrationEntityGlobal opdRegistrationEntityGlobal = getValueFromObject(response.getObj(),
					OpdRegistrationEntityGlobal.class);

			opdRegistrationEntityGlobal
					.setCardBilledStatus(findCardBillPaidStatus(opdRegistrationEntityGlobal.getId()));

			response.setObj(opdRegistrationEntityGlobal);

			return response;
		}

		return getErrorResponse("No data found !!", response);
	}

	// ===========================================================

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private CriteriaQuery criteriaQuery(OpdRegistrationEntityGlobal filter, String orderByDir, String orderByColumn) {
		init();

		List<Predicate> p = new ArrayList<Predicate>();
		p = criteriaCondition(filter, null, null);

		if (!CollectionUtils.isEmpty(p)) {
			Predicate[] pArray = p.toArray(new Predicate[] {});
			Predicate predicate = builder.and(pArray);
			criteria.where(predicate);
		}

		if (!StringUtils.isEmpty(orderByColumn)) {

			if (orderByDir.equalsIgnoreCase("ASC")) {
				criteria.orderBy(builder.asc(root.get(orderByColumn)));
			} else {
				criteria.orderBy(builder.desc(root.get(orderByColumn)));
			}

		}

		return criteria;
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private CriteriaQuery criteriaQuery(OpdRegistrationEntityGlobal filter) {
		init();

		List<Predicate> p = new ArrayList<Predicate>();
		p = criteriaCondition(filter, null, null);

		if (!CollectionUtils.isEmpty(p)) {
			Predicate[] pArray = p.toArray(new Predicate[] {});
			Predicate predicate = builder.and(pArray);
			criteria.where(predicate);
		}
		return criteria;
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private <T> TypedQuery typedQuery(OpdRegistrationEntityGlobal filter, DataTableRequest<T> dataTableInRQ) {
		init();
		List<Predicate> pArrayJoin = new ArrayList<Predicate>();
		List<Predicate> pConjunction = criteriaCondition(filter, null, null);
		List<Predicate> pDisJunction = dataTablefilter(dataTableInRQ, OpdRegistrationEntityGlobal.class);
		Predicate predicateAND = null;
		Predicate predicateOR = null;

		if (!CollectionUtils.isEmpty(pConjunction)) {
			predicateAND = builder.and(pConjunction.toArray(new Predicate[] {}));
		}
		if (!CollectionUtils.isEmpty(pDisJunction)) {
			predicateOR = builder.or(pDisJunction.toArray(new Predicate[] {}));
		}
		if (predicateAND != null) {
			pArrayJoin.add(predicateAND);
		}
		if (predicateOR != null) {
			pArrayJoin.add(predicateOR);
		}

//		if (dataTableInRQ.getOrder().getName() != null && !dataTableInRQ.getOrder().getName().isEmpty()) {
//
//			if (dataTableInRQ.getOrder().getSortDir().equals("ASC")) {
//				criteria.orderBy(builder.asc(root.get(dataTableInRQ.getOrder().getName())));
//			} else {
//				criteria.orderBy(builder.desc(root.get(dataTableInRQ.getOrder().getName())));
//			}
//
//		}
//		
		if (dataTableInRQ.getOrder().getName() != null && !dataTableInRQ.getOrder().getName().isEmpty()) {
			if (dataTableInRQ.getOrder().getSortDir().equals("ASC")) {
				criteria.orderBy(builder.asc(builder.coalesce(root.get(dataTableInRQ.getOrder().getName()),
						LocalDate.of(2018, Month.JANUARY, 1))));
			} else {
				criteria.orderBy(builder.desc(builder.coalesce(root.get(dataTableInRQ.getOrder().getName()),
						LocalDate.of(2018, Month.JANUARY, 1))));
			}
		}
		criteria.where(pArrayJoin.toArray(new Predicate[0]));
		return baseTypedQuery(criteria, dataTableInRQ);
	}

	private <T> Long countTypedQuery(OpdRegistrationEntityGlobal filter, DataTableRequest<T> dataTableInRQ) {

		if (dataTableInRQ.getPaginationRequest().isFilterByEmpty()) {
			return 0l;
		}

		CriteriaBuilder builder = criteriaBuilder();
		CriteriaQuery<Long> criteriaQuery = longCriteriaQuery(builder);
		Root<OpdRegistrationEntityGlobal> root = from(OpdRegistrationEntityGlobal.class, criteriaQuery);
		return totalCount(builder, criteriaQuery, root, criteriaCondition(filter, builder, root),
				dataTablefilter(dataTableInRQ, builder, root));

	}

	@SuppressWarnings({ "rawtypes" })
	private <T> TypedQuery typedQuery(OpdRegistrationEntityGlobal filter, Map<String, Object> fields) {
		init();
		List<Predicate> pConjunction = criteriaCondition(filter, null, null);
		List<Predicate> pDisJunction = basePredicate(fields);

		return typedQuery(pConjunction, pDisJunction);
	}

	private Long totalCount(OpdRegistrationEntityGlobal filter) {
		CriteriaBuilder builder = criteriaBuilder();
		CriteriaQuery<Long> criteriaQuery = longCriteriaQuery(builder);
		Root<OpdRegistrationEntityGlobal> root = from(OpdRegistrationEntityGlobal.class, criteriaQuery);
		return totalCount(builder, criteriaQuery, root, criteriaCondition(filter, builder, root));
	}

	@SuppressWarnings({ "unchecked" })
	private List<Predicate> criteriaCondition(OpdRegistrationEntityGlobal filter, CriteriaBuilder builder,
			Root<OpdRegistrationEntityGlobal> root) {
		if (builder == null) {
			builder = super.builder;
		}
		if (root == null) {
			root = super.root;
		}
		List<Predicate> p = new ArrayList<Predicate>();
		if (filter != null) {
			if (filter.getActiveStatus() != null && filter.getActiveStatus() > 0) {
				p.add(builder.equal(root.get("activeStatus"), filter.getActiveStatus()));
			}
			if (filter.getId() != null && filter.getId() > 0) {
				p.add(builder.equal(root.get("id"), filter.getId()));
			}
			if (filter.getFromDate() != null && filter.getToDate() != null) {
				p.add(builder.between(root.get("regDate"), addMinTime(filter.getFromDate()),
						addMaxTime(filter.getToDate())));
			}
			if (filter.getRegPoint() != null && filter.getRegPoint() != 0) {
				p.add(builder.equal(root.get("regPoint"), filter.getRegPoint()));
			}
			if (!StringUtils.isBlank(filter.getLikeHospitalNumber())) {
				Predicate condition = builder.like(builder.upper(root.get("hospitalNumber")),
						CommonUtils.PERCENTAGE_SIGN + filter.getLikeHospitalNumber().toUpperCase()
								+ CommonUtils.PERCENTAGE_SIGN);
				p.add(condition);
			}
			if (filter.getHospitalNumber() != null) {
				Predicate condition = builder.like(builder.upper(root.get("hospitalNumber")),
						CommonUtils.PERCENTAGE_SIGN + filter.getHospitalNumber().toUpperCase()
								+ CommonUtils.PERCENTAGE_SIGN);
				p.add(condition);
			}
//			if (!StringUtils.isBlank(filter.getHospitalNumber())) {
//				Predicate condition = builder.equal(root.get("hospitalNumber"), filter.getHospitalNumber());
//				p.add(condition);
//			}
			if (filter.getPhoneMobile() != null && !filter.getPhoneMobile().isEmpty()) {
				p.add(builder.equal(root.get("phoneMobile"), filter.getPhoneMobile()));
			}
			if (filter.getDob() != null) {
				p.add(builder.between(root.get("dob"), addMinTime(filter.getDob()), addMaxTime(filter.getDob())));
			}
			if (filter.getSsCreator() != null) {
				p.add(builder.equal(root.get("ssCreator"), filter.getSsCreator()));
			}
			if (filter.getPassportNo() != null) {
				p.add(builder.equal(root.get("passportNo"), filter.getPassportNo()));
			}
//			Predicate conditionOne = builder.greaterThan(root.get("id"), 100L);
			p.add(builder.greaterThan(root.get("id"), 100L));

			// only bringing null type RegType
//			Predicate conditionTwo = builder.isNull(root.get("regType"));
			p.add(builder.isNull(root.get("regType")));

			if (filter.getPersonalId() != null && !filter.getPersonalId().isEmpty()
					&& !filter.getPersonalId().equalsIgnoreCase("null")) {
				p.add(builder.equal(root.get("personalId"), filter.getPersonalId()));
			}
			if (filter.getPhoneOrHNo() != null) {
				Predicate p1 = builder.equal(root.get("phoneMobile"), filter.getPhoneOrHNo());
				Predicate p2 = builder.equal(root.get("hospitalNumber"), filter.getPhoneOrHNo());
				p.add(builder.or(p1, p2));
			}

		}
		return p;
	}

	private void init() {
		initEntityManagerBuilderCriteriaQueryRoot(OpdRegistrationEntityGlobal.class);
	}

}

Repo3
=====

package com.imranmadbar.core.consultation.repository;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Order;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.servlet.http.HttpServletRequest;
import javax.transaction.Transactional;

import org.json.JSONObject;
import org.springframework.stereotype.Repository;
import org.springframework.util.CollectionUtils;

import com.imranmadbar.core.base.BaseRepository;
import com.imranmadbar.core.consultation.ViewCoreConsultationEntityMedicareNew;
import com.imranmadbar.core.pagination.DataTableRequest;
import com.imranmadbar.core.pagination.DataTableResults;
import com.imranmadbar.core.util.Def;
import com.imranmadbar.core.util.Response;
import com.imranmadbar.core.util.UserSignInContainter;

@Repository
@Transactional
public class ViewCoreConsulationRepositoryMedicareNew extends BaseRepository {

	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Response gridList(HttpServletRequest request, UserSignInContainter userDetails) {

		DataTableResults<ViewCoreConsultationEntityMedicareNew> dataTableResults = null;
		Response response = new Response();
		ViewCoreConsultationEntityMedicareNew consultationEntity = new ViewCoreConsultationEntityMedicareNew();

		Long doctorNo = userDetails.getDoctorNo();
		// String consultTypeNoList = request.getParameter("consultTypeNoList");
		String shiftdtlNo = request.getParameter("shiftdtlNo");
		String fromDate = request.getParameter("fromDate");
		String toDate = request.getParameter("toDate");
		String consultTypeNo = request.getParameter("consultTypeNo");
		String appointFilter = request.getParameter("appointFilter");
		String waitingFilter = request.getParameter("waitingFilter");
		String doneFilter = request.getParameter("doneFilter");

//		if (consultTypeNoList != null && !consultTypeNoList.isEmpty()) {
//			consultationEntity = objectMapperReadValue(consultTypeNoList, ViewCoreConsultationEntityMedicareNew.class);
//		}

		if (doctorNo != null) {
			consultationEntity.setDoctorNo(doctorNo);
		}

//		if (consultTypeNoList != null && !consultTypeNoList.isEmpty()) {
//			consultationEntity.setConsultTypeNoList(consultTypeNoList);
//		}

		if (shiftdtlNo != null && !shiftdtlNo.isEmpty()) {
			consultationEntity.setShiftdtlNo(Long.parseLong(shiftdtlNo));
		}

		if (fromDate != null && !fromDate.isEmpty()) {
			consultationEntity.setFromDate(Def.DateParse(fromDate, "dd-MMM-yyyy"));
		}

		if (toDate != null && !toDate.isEmpty()) {
			consultationEntity.setToDate(Def.DateParse(toDate, "dd-MMM-yyyy"));
		}

		if (consultTypeNo != null && !consultTypeNo.isEmpty()) {
			consultationEntity.setConsultTypeNo(Long.parseLong(consultTypeNo));
		}

		if (appointFilter != null && !appointFilter.isEmpty()) {
			consultationEntity.setAppointFilter(Boolean.parseBoolean(appointFilter));
		}

		if (waitingFilter != null && !waitingFilter.isEmpty()) {
			consultationEntity.setWaitingFilter(Boolean.parseBoolean(waitingFilter));
		}

		if (doneFilter != null && !doneFilter.isEmpty()) {
			consultationEntity.setDoneFilter(Boolean.parseBoolean(doneFilter));
		}

		DataTableRequest dataTableInRQ = new DataTableRequest(request);
		Long totalRowCount = countTypedQuery(consultationEntity, dataTableInRQ);

		List gridList = new ArrayList<>();
		response = baseList(typedQuery(consultationEntity, dataTableInRQ));

		if (response.isSuccess()) {
			if (response.getItems() != null) {

				gridList = response.getItems();
			}
		}

		dataTableResults = dataTableResults(dataTableInRQ, countTypedQuery(consultationEntity, dataTableInRQ), gridList,
				totalRowCount);

		response.setItems(null);
		response.setObj(dataTableResults);
		return response;
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Response patientPortalPrescriptionGrid(HttpServletRequest request, UserSignInContainter userDetails) {

		DataTableResults<ViewCoreConsultationEntityMedicareNew> dataTableResults = null;
		Response response = new Response();
		ViewCoreConsultationEntityMedicareNew consultationEntity = new ViewCoreConsultationEntityMedicareNew();

		String userName = userDetails.getUserName();

		List gridList = new ArrayList<>();
		Long totalRowCount = 0L;
		DataTableRequest dataTableInRQ = new DataTableRequest(request);
		if (userName != null) {
			consultationEntity.setHospitalId(userName);
			dataTableInRQ = new DataTableRequest(request);
			totalRowCount = countTypedQuery(consultationEntity, dataTableInRQ);

			response = baseList(typedQuery(consultationEntity, dataTableInRQ));

			if (response.isSuccess()) {
				if (response.getItems() != null) {

					gridList = response.getItems();
				}
			}
		}

		dataTableResults = dataTableResults(dataTableInRQ, countTypedQuery(consultationEntity, dataTableInRQ), gridList,
				totalRowCount);

		response.setItems(null);
		response.setObj(dataTableResults);
		return response;
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Response nsGridList(HttpServletRequest request) {

		DataTableResults<ViewCoreConsultationEntityMedicareNew> dataTableResults = null;
		Response response = new Response();
		ViewCoreConsultationEntityMedicareNew consultationEntity = new ViewCoreConsultationEntityMedicareNew();

		String shiftdtlNo = request.getParameter("shiftdtlNo");
		String doctorNo = request.getParameter("doctorNo");
		String fromDate = request.getParameter("fromDate");
		String toDate = request.getParameter("toDate");

		if (doctorNo != null && !doctorNo.isEmpty()) {
			consultationEntity.setDoctorNo(Long.parseLong(doctorNo));
		}

		if (fromDate != null && !fromDate.isEmpty()) {
			consultationEntity.setFromDate(Def.DateParse(fromDate, "dd-MMM-yyyy"));
		}

		if (toDate != null && !toDate.isEmpty()) {
			consultationEntity.setToDate(Def.DateParse(toDate, "dd-MMM-yyyy"));
		}

		if (shiftdtlNo != null && !shiftdtlNo.isEmpty()) {
			consultationEntity.setShiftdtlNo(Long.parseLong(shiftdtlNo));
		}

		// for flag wise filter
		String consultTypeNo = request.getParameter("consultTypeNo");
		String appointFilter = request.getParameter("appointFilter");
		String waitingFilter = request.getParameter("waitingFilter");
		String doneFilter = request.getParameter("doneFilter");

		if (consultTypeNo != null && !consultTypeNo.isEmpty()) {
			consultationEntity.setConsultTypeNo(Long.parseLong(consultTypeNo));
		}

		if (appointFilter != null && !appointFilter.isEmpty()) {
			consultationEntity.setAppointFilter(Boolean.parseBoolean(appointFilter));
		}

		if (waitingFilter != null && !waitingFilter.isEmpty()) {
			consultationEntity.setWaitingFilter(Boolean.parseBoolean(waitingFilter));
		}

		if (doneFilter != null && !doneFilter.isEmpty()) {
			consultationEntity.setDoneFilter(Boolean.parseBoolean(doneFilter));
		}

		DataTableRequest dataTableInRQ = new DataTableRequest(request);
		Long totalRowCount = countTypedQuery(consultationEntity, dataTableInRQ);

		List gridList = new ArrayList<>();
		response = baseList(typedQuery(consultationEntity, dataTableInRQ));

		if (response.isSuccess() && response.getItems() != null) {
			gridList = response.getItems();
		}
		dataTableResults = dataTableResults(dataTableInRQ, countTypedQuery(consultationEntity, dataTableInRQ), gridList,
				totalRowCount);
		response.setItems(null);
		response.setObj(dataTableResults);
		return response;
	}

	public Response pharmacyGridList(HttpServletRequest request) {
		DataTableResults<ViewCoreConsultationEntityMedicareNew> dataTableResults = null;
		Response response = new Response();
		ViewCoreConsultationEntityMedicareNew consultationEntity = new ViewCoreConsultationEntityMedicareNew();

		String shiftdtlNo = request.getParameter("shiftdtlNo");
		String doctorNo = request.getParameter("doctorNo");
		String fromDate = request.getParameter("fromDate");
		String toDate = request.getParameter("toDate");

		if (doctorNo != null && !doctorNo.isEmpty()) {
			consultationEntity.setDoctorNo(Long.parseLong(doctorNo));
		}

		if (fromDate != null && !fromDate.isEmpty()) {
			consultationEntity.setFromDate(Def.DateParse(fromDate, "dd-MMM-yyyy"));
		}

		if (toDate != null && !toDate.isEmpty()) {
			consultationEntity.setToDate(Def.DateParse(toDate, "dd-MMM-yyyy"));
		}

		if (shiftdtlNo != null && !shiftdtlNo.isEmpty()) {
			consultationEntity.setShiftdtlNo(Long.parseLong(shiftdtlNo));
		}

		// for flag wise filter
		String consultTypeNo = request.getParameter("consultTypeNo");
		String appointFilter = request.getParameter("appointFilter");
		String waitingFilter = request.getParameter("waitingFilter");
		String doneFilter = request.getParameter("doneFilter");

		if (consultTypeNo != null && !consultTypeNo.isEmpty()) {
			consultationEntity.setConsultTypeNo(Long.parseLong(consultTypeNo));
		}

		if (appointFilter != null && !appointFilter.isEmpty()) {
			consultationEntity.setAppointFilter(Boolean.parseBoolean(appointFilter));
		}

		if (waitingFilter != null && !waitingFilter.isEmpty()) {
			consultationEntity.setWaitingFilter(Boolean.parseBoolean(waitingFilter));
		}

		if (doneFilter != null && !doneFilter.isEmpty()) {
			consultationEntity.setDoneFilter(Boolean.parseBoolean(doneFilter));
		}

		DataTableRequest dataTableInRQ = new DataTableRequest(request);
		Long totalRowCount = countTypedQuery(consultationEntity, dataTableInRQ);

		List gridList = new ArrayList<>();
		response = baseList(typedQuery(consultationEntity, dataTableInRQ));

		if (response.isSuccess() && response.getItems() != null) {
			gridList = response.getItems();
		}
		dataTableResults = dataTableResults(dataTableInRQ, countTypedQuery(consultationEntity, dataTableInRQ), gridList,
				totalRowCount);
		response.setItems(null);
		response.setObj(dataTableResults);
		return response;
	}

	public Response list() {
		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = null;
		return baseList(criteriaQuery(viewConsultationEntity));
	}

	public Response findByOncoConsultationId(String consultationId) {
		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = new ViewCoreConsultationEntityMedicareNew();
		viewConsultationEntity.setConsultationId(consultationId);
		return baseList(criteriaQuery(viewConsultationEntity));
	}

	public Response listWithFilter(String reqStr) {
		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = null;
		if (reqStr != null) {
			viewConsultationEntity = objectMapperReadValue(reqStr, ViewCoreConsultationEntityMedicareNew.class);
		}
		return baseList(criteriaQuery(viewConsultationEntity));
	}

	public Response doctorWiseConsultationFilter(String reqStr, UserSignInContainter userDetails) {
		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = null;
		if (reqStr != null) {
			viewConsultationEntity = objectMapperReadValue(reqStr, ViewCoreConsultationEntityMedicareNew.class);
		}
		if (viewConsultationEntity == null) {
			viewConsultationEntity = new ViewCoreConsultationEntityMedicareNew();
		}
		viewConsultationEntity.setAppointDate(clearTime(new Date()));
		viewConsultationEntity.setDoctorNo(userDetails.getDoctorNo());
		return baseList(criteriaQuery(viewConsultationEntity));
	}

	public Response findConsultationDataByConsultationId(String reqStr, UserSignInContainter userDetails) {
		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = null;
		if (reqStr != null) {
			viewConsultationEntity = objectMapperReadValue(reqStr, ViewCoreConsultationEntityMedicareNew.class);
		}
		if (viewConsultationEntity == null) {
			viewConsultationEntity = new ViewCoreConsultationEntityMedicareNew();
		}
		viewConsultationEntity.setDoctorNo(userDetails.getDoctorNo());
		return baseList(criteriaQuery(viewConsultationEntity));
	}

	public Response doctorWisePatientWorkList(String reqStr, UserSignInContainter userDetails) {
		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = null;
		if (reqStr != null) {
			viewConsultationEntity = objectMapperReadValue(reqStr, ViewCoreConsultationEntityMedicareNew.class);
		}
		if (viewConsultationEntity == null) {
			viewConsultationEntity = new ViewCoreConsultationEntityMedicareNew();
		}
		viewConsultationEntity.setConsultationNoNotNull(true);
		viewConsultationEntity.setDoctorNo(userDetails.getDoctorNo());
		return baseList(criteriaQuery(viewConsultationEntity));
	}

	public Response findByAppointmentNo(Long appointmentNo) {

		Response response = new Response();
		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = null;

		viewConsultationEntity = findById(appointmentNo);
		if (null == viewConsultationEntity) {
			return getErrorResponse("data not found");
		}

		response.setObj(viewConsultationEntity);

		return getSuccessResponse("data found", response);

	}

	public Response findByConsultationId(String consultationId) {

		Response response = new Response();

		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = new ViewCoreConsultationEntityMedicareNew();
		viewConsultationEntity.setConsultationId(consultationId);
		response = baseSingleObject(criteriaQuery(viewConsultationEntity));
		if (response.isSuccess() && response.getObj() != null) {
			return getSuccessResponse("Consultation Data Found", response);
		}
		return getErrorResponse("Data Not Found");

	}
	
	public Response getFutureAppointListFromToday(String hospitalIdStr) {
		JSONObject json = new JSONObject(hospitalIdStr);
		String hospitalId = Def.getString(json, "hospitalId");
		if (hospitalId == null) {
			return getErrorResponse("hospitalId Not Found!");
		}
		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = new ViewCoreConsultationEntityMedicareNew();
		viewConsultationEntity.setFrmAppDate(new Date());
		viewConsultationEntity.setHospitalId(hospitalId);
		return baseList(criteriaQuery(viewConsultationEntity));

	}
	
	public Response getConsultationHistory(String hospitalIdStr) {
		JSONObject json = new JSONObject(hospitalIdStr);
		String hospitalId = Def.getString(json, "hospitalId");
		if (hospitalId == null) {
			return getErrorResponse("hospitalId Not Found!");
		}
		ViewCoreConsultationEntityMedicareNew viewConsultationEntity = new ViewCoreConsultationEntityMedicareNew();
//		viewConsultationEntity.setConsultationOut(1L);
		viewConsultationEntity.setConsultationNoNotNull(true);
		viewConsultationEntity.setHospitalId(hospitalId);
		return baseList(criteriaQuery(viewConsultationEntity));

	}

	public Response maxSlNoByRoomNoAndToday(Long roomNo) {

		Response response = new Response();
		return response;
	}

	private Long totalCount(ViewCoreConsultationEntityMedicareNew filter) {
		CriteriaBuilder builder = criteriaBuilder();
		CriteriaQuery<Long> criteriaQuery = longCriteriaQuery(builder);
		Root<ViewCoreConsultationEntityMedicareNew> root = from(ViewCoreConsultationEntityMedicareNew.class,
				criteriaQuery);
		return totalCount(builder, criteriaQuery, root, criteriaCondition(filter, builder, root));
	}

	public ViewCoreConsultationEntityMedicareNew findById(Long id) {
		ViewCoreConsultationEntityMedicareNew obj = new ViewCoreConsultationEntityMedicareNew();
		obj.setId(id);
		Response response = baseFindById(criteriaQuery(obj));
		if (response.isSuccess()) {
			return (ViewCoreConsultationEntityMedicareNew) response.getObj();
		}
		return null;
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	private <T> TypedQuery typedQuery(ViewCoreConsultationEntityMedicareNew filter, DataTableRequest<T> dataTableInRQ) {
		init();
		List<Predicate> pArrayJoin = new ArrayList<Predicate>();
		List<Predicate> pConjunction = criteriaCondition(filter, null, null);
		List<Predicate> pDisJunction = dataTablefilter(dataTableInRQ, ViewCoreConsultationEntityMedicareNew.class);
		Predicate predicateAND = null;
		Predicate predicateOR = null;

		if (!CollectionUtils.isEmpty(pConjunction)) {
			Predicate[] pArray = pConjunction.toArray(new Predicate[] {});
			predicateAND = builder.and(pArray);
		}
		if (!CollectionUtils.isEmpty(pDisJunction)) {
			Predicate[] pArray = pDisJunction.toArray(new Predicate[] {});
			predicateOR = builder.or(pArray);
		}
		if (predicateAND != null) {
			pArrayJoin.add(predicateAND);
		}
		if (predicateOR != null) {
			pArrayJoin.add(predicateOR);
		}

		if (dataTableInRQ.getOrder().getName() != null && !dataTableInRQ.getOrder().getName().isEmpty()) {

			if (dataTableInRQ.getOrder().getSortDir().equals("ASC")) {
				criteria.orderBy(builder.asc(root.get(dataTableInRQ.getOrder().getName())));
			} else {
				criteria.orderBy(builder.desc(root.get(dataTableInRQ.getOrder().getName())));
			}

		} else {

			List<Order> orderList = new ArrayList();

			orderList.add(builder.asc(root.get("doctorName")));
			orderList.add(builder.asc(root.get("shiftdtlNo")));
			orderList.add(builder.asc(root.get("appointDate")));
			orderList.add(builder.asc(root.get("slotSl")));

			criteria.orderBy(orderList);
		}

//		Comparator<ViewCoreConsultationEntityMedicareNew> descShiftComp = (
//		ViewCoreConsultationEntityMedicareNew b1,
//		ViewCoreConsultationEntityMedicareNew b2) -> b1.getShiftdtlNo().compareTo(b2.getShiftdtlNo());
//Collections.sort(gridList, descShiftComp);
//
//Comparator<ViewCoreConsultationEntityMedicareNew> descDateComp = (
//		ViewCoreConsultationEntityMedicareNew b1,
//		ViewCoreConsultationEntityMedicareNew b2) -> b1.getAppointDate().compareTo(b2.getAppointDate());
//Collections.sort(gridList, descDateComp);

		criteria.where(pArrayJoin.toArray(new Predicate[0]));
		return baseTypedQuery(criteria, dataTableInRQ);
	}

	private <T> Long countTypedQuery(ViewCoreConsultationEntityMedicareNew filter, DataTableRequest<T> dataTableInRQ) {
		CriteriaBuilder builder = criteriaBuilder();
		CriteriaQuery<Long> criteriaQuery = longCriteriaQuery(builder);
		Root<ViewCoreConsultationEntityMedicareNew> root = from(ViewCoreConsultationEntityMedicareNew.class,
				criteriaQuery);
		return totalCount(builder, criteriaQuery, root, criteriaCondition(filter, builder, root),
				dataTablefilter(dataTableInRQ, builder, root, ViewCoreConsultationEntityMedicareNew.class));
	}

	// Non API
	@SuppressWarnings({ "rawtypes", "unchecked" })
	private CriteriaQuery criteriaQuery(ViewCoreConsultationEntityMedicareNew filter) {
		init();

		List<Predicate> p = new ArrayList<Predicate>();
		p = criteriaCondition(filter, null, null);

		if (!CollectionUtils.isEmpty(p)) {
			Predicate[] pArray = p.toArray(new Predicate[] {});
			Predicate predicate = builder.and(pArray);
			criteria.where(predicate);
		}

		List<Order> orderList = new ArrayList();

		orderList.add(builder.asc(root.get("appointDate")));
		orderList.add(builder.asc(root.get("shiftdtlNo")));
		orderList.add(builder.asc(root.get("slotSl")));

		criteria.orderBy(orderList);

		return criteria;
	}

	@SuppressWarnings({ "rawtypes", "unchecked", "unused" })
	private CriteriaQuery maxQuery(ViewCoreConsultationEntityMedicareNew filter, String maxColumnName) {
		init();

		List<Predicate> p = new ArrayList<Predicate>();
		p = criteriaCondition(filter, null, null);

		if (!CollectionUtils.isEmpty(p)) {
			Predicate[] pArray = p.toArray(new Predicate[] {});
			Predicate predicate = builder.and(pArray);
			criteria.where(predicate);
		}
		criteria.select(builder.max(root.get(maxColumnName)));
		return criteria;
	}

	@SuppressWarnings({ "unchecked" })
	private List<Predicate> criteriaCondition(ViewCoreConsultationEntityMedicareNew filter, CriteriaBuilder builder,
			Root<ViewCoreConsultationEntityMedicareNew> root) {

		if (builder == null) {
			builder = super.builder;
		}
		if (root == null) {
			root = super.root;
		}

		List<Predicate> p = new ArrayList<Predicate>();

		if (filter != null) {

			if (filter.getId() != null && filter.getId() > 0) {
				Predicate condition = builder.equal(root.get("id"), filter.getId());
				p.add(condition);
			}

			if (filter.getDoctorNo() != null && filter.getDoctorNo() > 0) {
				Predicate condition = builder.equal(root.get("doctorNo"), filter.getDoctorNo());
				p.add(condition);
			}

			if (filter.getHospitalId() != null) {
				Predicate condition = builder.equal(root.get("hospitalId"), filter.getHospitalId());
				p.add(condition);
			}

			if (filter.getPatientName() != null) {
				Predicate condition = builder.equal(root.get("patientName"), filter.getPatientName());
				p.add(condition);
			}

			if (filter.getGender() != null) {
				Predicate condition = builder.equal(root.get("gender"), filter.getGender());
				p.add(condition);
			}

			if (filter.getRegistrationNo() != null) {
				Predicate condition = builder.equal(root.get("registrationNo"), filter.getRegistrationNo());
				p.add(condition);
			}

			if (filter.getConsultationId() != null) {
				Predicate condition = builder.like(builder.upper(root.get("consultationId")),
						"%" + filter.getConsultationId().toUpperCase() + "%");
				p.add(condition);
			}
			if (filter.getConsultationNoNotNull()) {
				Predicate condition = builder.isNotNull(root.get("consultationNo"));
				p.add(condition);
			}
//			if (filter.getConsultTypeNo() != null) {
//				Predicate condition = builder.equal(root.get("consultTypeNo"), filter.getConsultTypeNo());
//				p.add(condition);
//			}
			if (filter.getShiftdtlNo() != null) {
				Predicate condition = builder.equal(root.get("shiftdtlNo"), filter.getShiftdtlNo());
				p.add(condition);
			}
			if (filter.getAppointDate() != null) {
				Predicate condition = builder.equal(builder.function("TRUNC", Date.class, root.get("appointDate")),
						filter.getAppointDate());
				p.add(condition);
			}

			if (filter.getFromDate() != null && filter.getToDate() != null) {
				Date fromDate = addMinTime(filter.getFromDate());
				Date toDate = addMaxTime(filter.getToDate());
				Predicate condition = builder.between(root.get("appointDate"), fromDate, toDate);
				p.add(condition);
			}
			if (filter.getConsultationOut() != null && filter.getConsultationOut() > 0) {
				Predicate condition = builder.equal(root.get("consultationOut"), filter.getConsultationOut());
				p.add(condition);
			}
			if (filter.getConsultTypeNo() != null && filter.getConsultTypeNo() > 0) {
				Predicate condition = builder.equal(root.get("consultTypeNo"), filter.getConsultTypeNo());
				p.add(condition);
			}
			if (filter.getAppointFilter()) {
				Predicate condition = builder.isNull(root.get("consultationId"));
				p.add(condition);
			}
			if (filter.getWaitingFilter()) {
				Predicate condition = builder.and(builder.isNotNull(root.get("consultationId")),
						builder.equal(root.get("consultationIn"), 1), builder.isNull(root.get("prescriptionNo")));
				p.add(condition);
			}
			if (filter.getDoneFilter()) {
				Predicate condition = builder.and(builder.isNotNull(root.get("prescriptionNo")),
						builder.equal(root.get("isPatientOut"), 1));
				p.add(condition);
			}
			if (filter.getConsultationOut() != null) {
				Predicate condition = builder.equal(root.get("consultationOut"), filter.getConsultationOut());
				p.add(condition);
			}
			if (filter.getFrmAppDate() != null) {
				Date fromDate = addMinTime(filter.getFrmAppDate());
//				Predicate condition = builder.between(root.get("appointDate"), fromDate, toDate);
				Predicate condition = builder.greaterThanOrEqualTo(root.<Date>get("appointDate"), fromDate);
				p.add(condition);
			}

			
//			if (filter.getConsultTypeNoList() != null && filter.getConsultTypeNoList().size() > 0) {
//				Expression<Long> exp = root.get("consultTypeNo");
//				Predicate condition = exp.in(filter.getConsultTypeNoList());
//				p.add(condition);
//			}

			// Predicate condition = builder.isNotNull(root.get("consultationId"));
			// p.add(condition);
		}

		return p;
	}

	@SuppressWarnings({ "unused", "rawtypes" })
	private void init() {
		initEntityManagerBuilderCriteriaQueryRoot(ViewCoreConsultationEntityMedicareNew.class);
		CriteriaBuilder builder = super.builder;
		CriteriaQuery criteria = super.criteria;
		Root root = super.root;
	}

}


-------------------------------------------------

Typeahead | autocomplete | Serverside
=================================================

WithQuery:
==========

	public static String DietItemStatement(String itemIdOrName) {
		StringBuffer sqlQuery = new StringBuffer();

		sqlQuery.append("SELECT d.item_no, m.item_id, m.item_name, ");
		sqlQuery.append("NVL (d.sales_price, m.sales_price) sales_price, d.item_qty ");
		sqlQuery.append("FROM dk_ipd_menu_category_chd d, in_item m ");
		sqlQuery.append("WHERE d.item_no = m.item_no ");
		sqlQuery.append("AND NVL (d.active_stat, 0) = 1 ");
		sqlQuery.append("AND (   m.item_id LIKE  ");
		sqlQuery.append("('" + CommonUtils.PERCENTAGE_SIGN);
		sqlQuery.append(itemIdOrName.toUpperCase());
		sqlQuery.append(CommonUtils.PERCENTAGE_SIGN + "')");
		sqlQuery.append("OR UPPER (item_name) LIKE ");
		sqlQuery.append("('" + CommonUtils.PERCENTAGE_SIGN);
		sqlQuery.append(itemIdOrName.toUpperCase());
		sqlQuery.append(CommonUtils.PERCENTAGE_SIGN + "') )");
		return sqlQuery.toString();
	}
------------
	// ================== for food item list ===========================
	public Response itemList(String reqObj) {

		JSONObject json = new JSONObject(reqObj);
		String itemNameOrId = Def.getString(json, "itemNameOrId");

		Response response = new Response();
		Connection con = null;
		ResultSet rs = null;
		Statement stm = null;
		List<DietRequistionItemDto> itemList = new ArrayList<DietRequistionItemDto>();

		try {
			con = getOraConnection();
			stm = con.createStatement();
			rs = stm.executeQuery(DietRequistionStatement.DietItemStatement(itemNameOrId));

			while (rs.next()) {
				DietRequistionItemDto itemObj = new DietRequistionItemDto();

				itemObj.setItemNo(rs.getLong("ITEM_NO"));
				itemObj.setItemId(rs.getString("ITEM_ID"));
				itemObj.setItemName(rs.getString("ITEM_NAME"));
				itemObj.setSalesPrice(rs.getLong("sales_price"));
				itemObj.setItemQty(rs.getLong("item_qty"));
				itemList.add(itemObj);

			}
		} catch (SQLException e) {
			e.printStackTrace();
		} finally {
			finalyConStmRs(con, stm, rs);
		}
		response.setItems(itemList);
		return getSuccessResponse("Item List Found", response);
	}
	
Angular:	
--------------
Html
<input type="search" placeholder="Type Name Or ID..." class="form-control" id="itemId"
[(ngModel)]="foodItemSearchText" [typeaheadAsync]="true" [typeahead]="foodItemDataSource"
(typeaheadOnSelect)="onSelectFoodItem($event)" [typeaheadOptionsLimit]="10"
typeaheadOptionField="itemName" (typeaheadLoading)="changeTypeaheadLoading($event)"
(typeaheadNoResults)="noResultsFound($event)" [typeaheadItemTemplate]="customItemTemplate">
<div class="searchLoading loading-icon-all" *ngIf="typeaheadLoading">
<i class="fas fa-spinner loading-icon"></i>
</div>

Tx:
===

 //===== For Diet Item Typeahead =================
  getFoodItemTypeHedData() {
    this.foodItemDataSource = Observable.create((observer) => {
      observer.next(this.foodItemSearchText);
    }).pipe(mergeMap((token: string) => this.getFoodItemAsObservable(token)));
  }

  getFoodItemAsObservable(token: string): Observable<any> {
    let reqObj = { itemNameOrId: token }
    return this._dietRequistionService.findFoodItemList(reqObj);
  }

  changeTypeaheadLoading(e: boolean): void {
    this.typeaheadLoading = e;
  }

  noResultsFound(event: boolean): void {
    this.noResult = event;
  }

  onSelectFoodItem(event: TypeaheadMatch) {
    if (this.foodItemList.length == 0) {
      this.foodItemList.push(event.item);
    } else {
      let dupItem = this.foodItemList.find(item => item.itemNo == event.item.itemNo);
      if (dupItem) {
        this._toastrService.warning('Item Already Added!')
      } else {
        this.foodItemList.push(event.item);
      }
    }
    this.foodItemSearchText = null;
    document.getElementById('itemId').focus();
    this.calTotalItem();
  }
  //==========================================================

/-------------------------------------------------

Typeahead2:
===========
@PostMapping("/drListByIdName")
public Response patientListByIdName(@RequestBody String reqObj) {
return doctorScheduleService.drListByIdName(reqObj);
}


public Response drListByIdName(String reqObj) {		
return consultingDocRepository.findDrListByNameOrId(reqObj);
}


public Response findDrListByNameOrId(String reqObj) {
	
	if (null == reqObj) {
		return getErrorResponse("Please enter  Doctor Name Or ID");
	}
	JSONObject json = new JSONObject(reqObj);
	String doctorId = Def.getString(json, "doctorId");
	String doctorName = Def.getString(json, "doctorName");
	
	
	ViewConsultingDocEntity consultingDocEntity = new ViewConsultingDocEntity();
	consultingDocEntity.setCompanyNo(userDetails().getCompanyNo());
	
	if (null == doctorId && doctorName == null) {
		return getErrorResponse("please enter  personalnumber");
	}

	Map<String, Object> searchfields = new HashMap<String, Object>();
	searchfields.put("doctorName", doctorName);
	searchfields.put("doctorId", doctorId);

	return baseList(typedQuery(consultingDocEntity, searchfields));

}

Html::
====
<input [(ngModel)]="selectedDoctor" name="selectedDoctor" [typeaheadAsync]="true"
[typeahead]="drDatasource" [typeaheadScrollable]="true" [typeaheadOptionsInScrollableView]="10"
(typeaheadLoading)="changeTypeaheadLoading($event)" (typeaheadOnSelect)="selectDoctor($event)"
(typeaheadNoResults)="typeaheadNoResults($event)" [typeaheadOptionsLimit]="10"
[typeaheadWaitMs]="300" typeaheadOptionField="doctorName"
[typeaheadItemTemplate]="customTemplate" #patientName placeholder="Search by ID or Name"
class="form-control" autocomplete="off" typeaheadMinLength="3">
<button type="button" *ngIf="selectedDoctor" class="btn remove-doctor-icon" title=""
(click)="onCLickRemoveDr()"><i class="fas fa-times"></i></button>
<ng-template #customTemplate let-model="item" let-index="index">
<table>
  <tr>
	<th>ID:</th>
	<td>{{model.doctorId}}</td>
  </tr>
  <tr>
	<th>Name</th>
	<td>{{model.doctorName}}</td>
  </tr>
</table>
</ng-template>

TS:
=====
  //for typeahead
  drDatasource: Observable<any>
  selectedDoctor: string;
  typeaheadLoading: boolean;
  noResult = false;
  searchObject: any = {};
  selectedDoctorNo: number;
 
    
// == method for typeahed
 changeTypeaheadLoading(e: boolean): void {
  if (this.selectedDoctor.length == 0) {
    this.selectedDoctor = null;
  }
  this.typeaheadLoading = e;
}
selectDoctor(result: any): void {
  console.log(result.item);
  this.selectedDoctorNo = result.item.doctorNo;
  this.searchObject.doctorId = result.item.doctorId;
}
typeaheadNoResults(e: boolean): void {
  this.noResult = e;
}
initiateDoctorData(): any {
  return this.drDatasource = Observable.create((observer: any) => {
    observer.next(this.selectedDoctor);

  }).pipe(mergeMap((token: string) => this.searchDoctor(token)));
}
searchDoctor(token: string): any {
  let searchObj = { "doctorId": token, "doctorName": token };
  return this.pacsIpPortService.getTypeaheadDoctorIDName(searchObj);
}

onCLickRemoveDr() {
  let result = {
    "item": {
      "doctorNo": 0,
      "doctorId": ""
    }
  }
  this.selectedDoctor = "";
  this.selectDoctor(result);
}

//== method for typeahed

 
					  
In Service:
------------
  getTypeaheadDoctorIDName(obj: any): Observable<any> {
    return this.http.post<any>(this.TYPEAHEAD_DOCTOR_ID, obj).pipe(
      map((data: any) => this.sortByregType(data.items))
    )
  }
  
  sortByregType(data){
    if(data == null){
      return data;
    }else{
      return data.sort(sortBy('regType'));
    }
  }  
  
  
//===============================================  
  
  


=================================================
#         HttpRequest | HttpServletRequest                                         
================================================= 

String remoteIpAddress1 =	userAgent().getRemoteAddress();
String clientIpAdress = userAgent().getClientIpAddress();
String macAdress = userAgent().getMacAddress();
String osName =	userAgent().getOs();
String browserName =	userAgent().getBrowser();
		
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.io.Serializable;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;

import javax.servlet.http.HttpServletRequest;

import lombok.Getter;
import lombok.Setter;
@Getter
@Setter
public class CustomHttpServletRequest implements Serializable{

	private static final long serialVersionUID = 2410847241220452549L;

	private final String remoteAddress;
	private final String clientIpAddress;
	private final String macAddress;
    private final  String os;
	private  String browser;
	private  String hostName;
	
	
	private static final String[] HEADERS_LIST = { 
		    "X-Forwarded-For",
		    "Proxy-Client-IP",
		    "WL-Proxy-Client-IP",
		    "HTTP_X_FORWARDED_FOR",
		    "HTTP_X_FORWARDED",
		    "HTTP_X_CLUSTER_CLIENT_IP",
		    "HTTP_CLIENT_IP",
		    "HTTP_FORWARDED_FOR",
		    "HTTP_FORWARDED",
		    "HTTP_VIA",
		    "REMOTE_ADDR" 
		};

	private String findClientIpAddress(HttpServletRequest request) {
		
	    for (String header : HEADERS_LIST) {
	    	
	        String ip = request.getHeader(header);
	        
	        if (ip != null && ip.length() != 0 && !"unknown".equalsIgnoreCase(ip)) {
	        	System.out.println("<<< ip >>> ");
	            return ip;
	        }
	        
	    }

	    return request.getRemoteAddr();
	}
	
	private String getClientIp(String ipAddress) {
		
		
	    if (ipAddress.equalsIgnoreCase("0:0:0:0:0:0:0:1")) {
	        InetAddress inetAddress;
			try {
				
				inetAddress = InetAddress.getLocalHost();
				ipAddress = inetAddress.getHostAddress();
				
				this.hostName = inetAddress.getHostName();
				
				 System.out.println(" client ip"+inetAddress);  
				 
			} catch (UnknownHostException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

	    }
	    
	    return ipAddress;
	}
	
	
 private InetAddress getLocalhost(String ipAddress) {
		
	   InetAddress inetAddress = null;
	    if (ipAddress.equalsIgnoreCase("0:0:0:0:0:0:0:1") || ipAddress.equalsIgnoreCase("27.0.0.1")) {
	      
			try {
				inetAddress = InetAddress.getLocalHost();
				
			} catch (UnknownHostException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

	    }
	    
	    return inetAddress;
	}
	
	
	private String getClientMACaddresses(String ipAddress) {
		
		StringBuilder sb = new StringBuilder("");
		NetworkInterface network = null;
		
		try {
			InetAddress ip = null;
			
			if (ipAddress.equalsIgnoreCase("0:0:0:0:0:0:0:1") || ipAddress.equalsIgnoreCase("27.0.0.1")) {
				
				 ip = getLocalhost(ipAddress);
				 
			} else {
				
				//sb.append(findRemoteHostMACAddress(ipAddress));
			}
		
			
			if( ip != null) {
				
				network = NetworkInterface.getByInetAddress(ip);
				
				if(network !=null) {
					byte[] hardwareAddress = network.getHardwareAddress();
					 
					if (hardwareAddress != null) {
							for (int i = 0; i < hardwareAddress.length; i++) {
								sb.append(String.format("%02X%s", hardwareAddress[i], (i < hardwareAddress.length - 1) ? "-" : ""));
							} 
					 }
				}
		
			}
		
		
			
			//System.out.println(sb.toString());
			
		} catch (SocketException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    
	    return sb.toString();
	}
	
	public String findRemoteHostMACAddress(String ipAddress) {
		
		String str = "";
		String macAddress = "";
		try {
		    Process p = Runtime.getRuntime().exec("nbtstat -A " + ipAddress);
		    InputStreamReader ir = new InputStreamReader(p.getInputStream());
		    LineNumberReader input = new LineNumberReader(ir);
		    for (int i = 1; i < 100; i++) {
		        str = input.readLine();
		        if (str != null) {
		            if (str.indexOf("MAC Address") > 1) {
		                macAddress = str.substring(
		                        str.indexOf("MAC Address") + 14, str.length());
		                break;
		            }
		        }
		    }
		} catch (IOException e) {
		    e.printStackTrace(System.out);
		}
		
		return macAddress;
	}
	
	
	
	public CustomHttpServletRequest(HttpServletRequest request) {

	    String ipAddress = getClientIp(findClientIpAddress(request));  
	    
	    this.macAddress = getClientMACaddresses(findClientIpAddress(request));
	  //  this.macAddress = "";//getClientMACaddresses(ipAddress);
	   
	    System.out.println("Client ip"+ipAddress);
	    System.out.println("Client Mac Address "+macAddress);
		
		this.clientIpAddress = ipAddress;
		this.remoteAddress      = request.getRemoteAddr();
		String  browserDetails  = request.getHeader("User-Agent");
        String  userAgent       =  browserDetails;
        String  user            =  userAgent.toLowerCase();


//        Client client = 	
   
        //================= OS =======================
         if (userAgent.toLowerCase().indexOf("windows") >= 0 )
         {
             this.os = "Windows";
         } else if(userAgent.toLowerCase().indexOf("mac") >= 0)
         {
        	 this.os = "Mac";
         } else if(userAgent.toLowerCase().indexOf("x11") >= 0)
         {
        	 this.os = "Unix";
         } else if(userAgent.toLowerCase().indexOf("android") >= 0)
         {
        	 this.os = "Android";
         } else if(userAgent.toLowerCase().indexOf("iphone") >= 0)
         {
        	 this.os = "IPhone";
         }else{
        	 this.os = "UnKnown, More-Info: "+userAgent;
         }
         //===============Browser===========================
        if (user.contains("msie"))
        {
            String substring=userAgent.substring(userAgent.indexOf("MSIE")).split(";")[0];
            this.browser=substring.split(" ")[0].replace("MSIE", "IE")+"-"+substring.split(" ")[1];
        } else if (user.contains("safari") && user.contains("version"))
        {
        	this.browser=(userAgent.substring(userAgent.indexOf("Safari")).split(" ")[0]).split("/")[0]+"-"+(userAgent.substring(userAgent.indexOf("Version")).split(" ")[0]).split("/")[1];
        } else if ( user.contains("opr") || user.contains("opera"))
        {
            if(user.contains("opera"))
            	this.browser=(userAgent.substring(userAgent.indexOf("Opera")).split(" ")[0]).split("/")[0]+"-"+(userAgent.substring(userAgent.indexOf("Version")).split(" ")[0]).split("/")[1];
        else if(user.contains("opr"))
            	this.browser=((userAgent.substring(userAgent.indexOf("OPR")).split(" ")[0]).replace("/", "-")).replace("OPR", "Opera");
        } else if (user.contains("chrome"))
        {
        	this.browser=(userAgent.substring(userAgent.indexOf("Chrome")).split(" ")[0]).replace("/", "-");
        } else if ((user.indexOf("mozilla/7.0") > -1) || (user.indexOf("netscape6") != -1)  || (user.indexOf("mozilla/4.7") != -1) || (user.indexOf("mozilla/4.78") != -1) || (user.indexOf("mozilla/4.08") != -1) || (user.indexOf("mozilla/3") != -1) )
        {
        	this.browser = "Netscape-?";

        } else if (user.contains("firefox"))
        {
        	this.browser=(userAgent.substring(userAgent.indexOf("Firefox")).split(" ")[0]).replace("/", "-");
        } else if(user.contains("rv"))
        {
        	this.browser="IE-" + user.substring(user.indexOf("rv") + 3, user.indexOf(")"));
        } else
        {
        	this.browser = "UnKnown, More-Info: "+userAgent;
        }
	}
	
	@SuppressWarnings("unused")
	private String getDeviceDetails(String userAgent) {
	   
		String deviceDetails = "UNKNOWN";
	    
//	    Client client = parser.parse(userAgent);
//	    if (Objects.nonNull(client)) {
//	        deviceDetails = client.userAgent.family
//	          + " " + client.userAgent.major + "." 
//	          + client.userAgent.minor + " - "
//	          + client.os.family + " " + client.os.major
//	          + "." + client.os.minor; 
//	    }
	    return deviceDetails;
	}
}





=================================================
#     GlobalExceptionHandler                                    
================================================= 

import java.time.LocalDateTime;
import lombok.extern.slf4j.Slf4j;
import net.banglalink.apihub.openapi.provisioning.domain.ApiName;
import net.banglalink.apihub.openapi.provisioning.domain.ServiceName;
import net.banglalink.apihub.openapi.provisioning.repository.schema.ProvisioningLogEntity;
import net.banglalink.apihub.openapi.provisioning.service.ProvisioningLogService;
import net.banglalink.apihub.openapi.provisioning.util.OpaProvCommonFunctions;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler
    implements OpaProvCommonFunctions {

  @Autowired private ProvisioningLogService provisioningLogService;

  @ExceptionHandler(value = Exception.class)
  public ResponseEntity<Object> generalExceptionHandeler(Exception ex, WebRequest request) {
    String errMsg = ex.getMessage();
    log.error("OTHER EXCEPTION OCCUR:\n" + errMsg);
    ProvisioningLogEntity provLogObj = null;
    provLogObj =
        new ProvisioningLogEntity()
            .setApiName(ApiName.PROVISIONING_PURCHASE.getValue())
            .setServiceName(ServiceName.OPENAPI_PROVISION)
            .setApiStatusDetails(errMsg)
            .setStartTime(LocalDateTime.now());

    provisioningLogService.provPurchaseLogSave(provLogObj);

    return new ResponseEntity(errMsg, HttpStatus.INTERNAL_SERVER_ERROR);
  }
}





================================================
#  X-CODE                                    
================================================

private String generatedRandomPin() {
	Random random = new Random();
	int value = ((1 + random.nextInt(2)) * 1000 + random.nextInt(1000));
	return String.valueOf(value);
}




================================================
#  Regular expression |  regx | exp                                     
================================================

Pattern offerIdPattern = Pattern.compile("(?<=^)(\\d*?)(?=\\s)");
Pattern namePattern = Pattern.compile("(?<=\\s)([a-zA-Z0-9-_/+]+\\s*?)");
Pattern rechargeAmountPattern = Pattern.compile("(?<=\\s)(\\d*?)(?=tk)");
Pattern validityInDayPattern = Pattern.compile("(?<=-)(\\d*?)(?=d)");
Pattern minPattern = Pattern.compile("(?<=-)(\\d*?)(?=min)");
Pattern ratePattern = Pattern.compile("(?<=-)(\\d*?p/min)(?=-)");
Pattern smsPattern = Pattern.compile("(?<=-)(\\d*?)(?=sms)");
Pattern dataGbPattern = Pattern.compile("(?<=-)(\\d*?)(?=gb)");
Pattern dataProductPattern = Pattern.compile("(?<=-)([a-zA-Z0-9_+]+\\s*?)");
Pattern dataMbPattern = Pattern.compile("(?<=-)(\\d*?)(?=mb)");
Pattern otherInformationPattern = Pattern.compile("(?<=\\()(\\d*?)(?=\\))");
Pattern dataGbPattern = Pattern.compile("(?<=-)(\\d.*?)(?=gb)");
		
Matcher minMatcher = minPattern.matcher(offerDetail);

if (minMatcher.find()) {
   testObj.setVoiceMin(Integer.parseInt(minMatcher.group(1)));
}
		

================================================
#  SPRING |  BASIC                                      
================================================

 ApplicationContextHolder.getContext().getBean(WalletFTVerifierService.class);
 
 
 
 ================================================
#  ResponseEntity                                      
================================================
    ObjectMapper mapper = new ObjectMapper();
	
	
 ResponseEntity<?> response =
	dbssClient.dataVolumeTransfer(
		volumeTransferRequest.getSenderSubscriptionId(), objRequest);
objResponse.setData(mapper.convertValue(response.getBody(), VolumeTransferResponse.class));




=================================================
# JavaFX | java fx | fx                                      
================================================= 



#VM Argument
-------------------------------------------------

--module-path C:\Z_MY_COMPUTER\Software\javafx18\lib 
--add-modules=javafx.controls,javafx.fxml





=================================================
# MD-R | Library | Dependency                                      
================================================= 
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.imranmadbar</groupId>
	<artifactId>myapp-web</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>pom</packaging>
	<name>myapp-web</name>
	<description>MD Web Project</description>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.0.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
		<java.version>1.8</java.version>
	</properties>

	<modules>
		<module>hrm-api</module>
		<module>myapp-core</module>
		<module>myapp-shared</module>
    	<module>crm-api</module>
    </modules>
	     <dependencies>

		<dependency>
			<groupId>one.util</groupId>
			<artifactId>streamex</artifactId>
			<version>0.6.5</version>
		</dependency>
		
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		
 	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
 	</dependency> 
		
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc7</artifactId>
			<version>12.1.0</version>
		</dependency>
		
			<dependency>
			<groupId>com.imranmadbar.report-font</groupId>
			<artifactId>Times-New-Roman</artifactId>
			<version>1.0.1</version>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>com.imranmadbar.report-font</groupId>
			<artifactId>Arial</artifactId>
			<version>1.0.1</version>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>com.imranmadbar.report-font</groupId>
			<artifactId>Arial-Narrow</artifactId>
			<version>1.0.1</version>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>com.imranmadbar.report-font</groupId>
			<artifactId>Arial-Narrow-Italic</artifactId>
			<version>1.0.1</version>
			<scope>runtime</scope>
		</dependency>


		<dependency>
			<groupId>com.imranmadbar.report-font</groupId>
			<artifactId>Nikosh</artifactId>
			<version>1.0.1</version>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>com.imranmadbar.report-font</groupId>
			<artifactId>segoeui</artifactId>
			<version>1.0.1</version>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>org.json</groupId>
			<artifactId>json</artifactId>
			<version>20180130</version>
		</dependency>

		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
		</dependency>

		<dependency>
			<groupId>net.sf.jasperreports</groupId>
			<artifactId>jasperreports</artifactId>
			<version>6.4.1</version>
			<exclusions>
				<exclusion>
					<groupId>org.olap4j</groupId>
					<artifactId>olap4j</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>net.sf.barcode4j</groupId>
			<artifactId>barcode4j</artifactId>
			<version>2.0</version>
		</dependency>
		
	 <dependency>
	    <groupId>net.sourceforge.barbecue</groupId>
	    <artifactId>barbecue</artifactId>
	    <version>1.5-beta1</version>
      </dependency>

		<dependency>
			<groupId>org.apache.xmlgraphics</groupId>
			<artifactId>batik-bridge</artifactId>
			<version>1.10</version>
		</dependency>
	
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<version>1.18.10</version><!--$NO-MVN-MAN-VER$ -->
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
		</dependency>
		
	     <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-cache</artifactId>
    </dependency>
    <dependency>
        <groupId>com.github.ben-manes.caffeine</groupId>
        <artifactId>caffeine</artifactId>
    </dependency>
	</dependencies>
	

	<build>
		<finalName>${project.artifactId}</finalName>
		<pluginManagement>
			<plugins>
				<plugin>
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-maven-plugin</artifactId>
				</plugin>
			</plugins>
		</pluginManagement>
	</build>
</project>


Shared module
------------------------------------------------
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  
  <parent>
    <groupId>com.imranmadbar</groupId>
    <artifactId>myapp-web</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  
  <groupId>com.imranmadbar.myapp-shared</groupId>
  <artifactId>myapp-shared</artifactId>
  <version>1.0.1-SNAPSHOT</version>
  <name>myapp-shared</name>
  <packaging>jar</packaging>
  <description>My shared</description>

  <dependencies>
	<dependency>
		<groupId>com.imranmadbar.myapp-core</groupId>
		<artifactId>myapp-core</artifactId>
		<version>${project.version}</version>
	</dependency>
  </dependencies>
  
</project>


Core module
------------------------------------------------
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>com.imranmadbar</groupId>
    <artifactId>myapp-web</artifactId>
    <version>0.0.1-SNAPSHOT</version>
  </parent>
  
  <groupId>com.imranmadbar.myapp-core</groupId>
  <artifactId>myapp-core</artifactId>
  <version>1.0.1-SNAPSHOT</version>
  <name>myapp-core</name>
  <packaging>jar</packaging>
  <description>My core</description>
  
</project>

Simple SERVICES1
------------------------------------------------

<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>com.imranmadbar</groupId>
		<artifactId>myapp-web</artifactId>
		<version>0.0.1-SNAPSHOT</version>
	</parent>

	<groupId>com.imranmadbar.myServicesOne</groupId>
	<artifactId>myservices-one</artifactId>
	<packaging>war</packaging>
	<version>1.0.1-SNAPSHOT</version>
	<name>myServices-one</name>
	<description>Myy Services One</description>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<oauth.version>2.3.3.RELEASE</oauth.version>
		<oauth-config.version>5.1.3.RELEASE</oauth-config.version>
		<jwt.version>1.0.9.RELEASE</jwt.version>
	</properties>

	<dependencies>

		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-config</artifactId>
			<version>${oauth-config.version}</version><!--$NO-MVN-MAN-VER$ -->
		</dependency>

		<dependency>
			<groupId>org.springframework.security.oauth</groupId>
			<artifactId>spring-security-oauth2</artifactId>
			<version>${oauth.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-jwt</artifactId>
			<version>${jwt.version}</version>
		</dependency>

		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
		</dependency>


		<dependency>
			<groupId>com.imranmadbar.myapp-shared</groupId>
			<artifactId>myapp-shared</artifactId>
			<version>${project.version}</version>
		</dependency>

		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>3.8.1</version><!--$NO-MVN-MAN-VER$ -->
			<scope>test</scope>
		</dependency>

	</dependencies>

	<build>
		<finalName>${project.artifactId}</finalName>
	</build>

</project>


Simple SERVICES2
------------------------------------------------
<project
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
	xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>com.imranmadbar</groupId>
		<artifactId>myapp-web</artifactId>
		<version>0.0.1-SNAPSHOT</version>
	</parent>

	<groupId>com.imranmadbar.myservicesTwo</groupId>
	<artifactId>myservices-two</artifactId>
	<version>1.0.1-SNAPSHOT</version>
	<packaging>war</packaging>
	<name>hospital-api</name>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<oauth.version>2.3.3.RELEASE</oauth.version>
		<oauth-config.version>5.1.3.RELEASE</oauth-config.version>
		<jwt.version>1.0.9.RELEASE</jwt.version>
	</properties>

	<dependencies>
	
	  <dependency>
    <groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
      <exclusions>
        <exclusion>
          <groupId>ch.qos.logback</groupId>
          <artifactId>logback-classic</artifactId>
        </exclusion>
      </exclusions>
    </dependency>

	    

		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-config</artifactId>
			<version>${oauth-config.version}</version><!--$NO-MVN-MAN-VER$ -->
		</dependency>

		<dependency>
			<groupId>org.springframework.security.oauth</groupId>
			<artifactId>spring-security-oauth2</artifactId>
			<version>${oauth.version}</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-jwt</artifactId>
			<version>${jwt.version}</version>
		</dependency>


		<dependency>
            <groupId>com.imranmadbar.myapp-shared</groupId>
            <artifactId>medicare-shared</artifactId>
			<version>${project.version}</version>
		</dependency>
		<dependency>
			<groupId>net.sf.jasperreports</groupId>
			<artifactId>jasperreports</artifactId>
			<version>6.4.1</version>
			<exclusions>
				<exclusion>
					<groupId>org.olap4j</groupId>
					<artifactId>olap4j</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<dependency>
			<groupId>net.sf.barcode4j</groupId>
			<artifactId>barcode4j</artifactId>
			<version>2.0</version>
		</dependency>

		<dependency>
			<groupId>org.apache.xmlgraphics</groupId>
			<artifactId>batik-bridge</artifactId>
			<version>1.10</version>
		</dependency>
	
		<dependency>
			<groupId>de.c-brell.birt.reportitem.barcode</groupId>
			<artifactId>barcode-reportitem-birt</artifactId>
			<version>1.0.1.201205022025</version>
			<scope>runtime</scope>
		</dependency>
		
		<dependency>
			<groupId>com.google.zxing</groupId>
			<artifactId>barcode-zxing-birt</artifactId>
			<version>1.0.1</version>
			<scope>runtime</scope>
		</dependency> 
	
	</dependencies>
	<build>
		<finalName>${project.artifactId}</finalName>
	</build>
</project>



DataSource
---------------------------------------------
spring.datasource.url=jdbc:oracle:thin:@192.168.1.2:1521:mydb
spring.datasource.username=dbUserName
spring.datasource.password=dbPass
spring.jpa.database-platform=org.hibernate.dialect.Oracle10gDialect
spring.jpa.hibernate.ddl-auto = validate

hibernate.dialect=org.hibernate.dialect.Oracle10gDialect
hibernate.show_sql=true
hibernate.format_sql=true
hibernate.hbm2ddl.auto=update
hibernate.proc.param_null_passing=true
hibernate.temp.use_jdbc_metadata_defaults=false
hibernate.schema_update.unique_constraint_strategy=SKIP



Config DataSource
---------------------------------------------
import javax.sql.DataSource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.core.env.Environment;
import lombok.Getter;
import lombok.Setter;

@Configuration
@ConfigurationProperties("spring.datasource")
@Getter
@Setter
public class DBConfiguration {
	
	private final Logger LOGGER = LoggerFactory.getLogger(getClass());
	
	@Autowired
	private Environment env;
	
	private String driverClassName;
	private String url;
	private String username;
	private String password;

	
	@Profile("dev")
	@Bean
	public DataSource devDataSource(){
		
		LOGGER.info("DB connection for Development");
		
		return createDataSource();
	}

	@Profile("prod")
	@Bean
	public DataSource prodDataSource(){
		LOGGER.info("DB Connection to Production");
		return createDataSource();
	}

	private DataSource createDataSource() {
		return DataSourceBuilder
				.create()
				.username(username)
				.password(password)
				.url(url)
				.driverClassName(driverClassName)
				.build();
	}

}


AppConfig
-----------------------------------------------
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;
import java.util.Properties;
import javax.sql.DataSource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Primary;
import org.springframework.core.env.Environment;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.security.oauth2.provider.token.TokenStore;
import org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;


@Configuration
public class MyAppConfig implements WebMvcConfigurer {

	@Autowired
	private Environment env;

	@Autowired
	private DataSource dataSource;

	@Bean
	public TokenStore resourcesTokenStore() {
		return new JdbcTokenStore(dataSource);
	}
	
	@Bean
	public RestTemplate getRestTemplate() {
		return new RestTemplateBuilder().build();
	}

	@Bean
	@Primary
	public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
		final LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
		em.setDataSource(dataSource);
		em.setPackagesToScan(new String[] { "com.imranmadbar.MyServicesOne",  "com.myimranmadbarsoft.shared", "com.imranmadbar.core"});
		final HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
		em.setJpaVendorAdapter(vendorAdapter);
		em.setJpaProperties(additionalProperties());
		return em;
	}
	
    protected Properties additionalProperties() {
        final Properties hibernateProperties = new Properties();
        hibernateProperties.setProperty("hibernate.hbm2ddl.auto", env.getProperty("hibernate.hbm2ddl.auto"));
        hibernateProperties.setProperty("hibernate.dialect", env.getProperty("hibernate.dialect"));
        hibernateProperties.put("hibernate.show_sql", env.getProperty("hibernate.show_sql"));
        hibernateProperties.put("hibernate.format_sql", env.getProperty("hibernate.format_sql"));
        hibernateProperties.put("hibernate.proc.param_null_passing", env.getProperty("hibernate.proc.param_null_passing"));
        hibernateProperties.put("hibernate.schema_update.unique_constraint_strategy", env.getProperty("hibernate.schema_update.unique_constraint_strategy"));
        hibernateProperties.put("hibernate.temp.use_jdbc_metadata_defaults", env.getProperty("hibernate.temp.use_jdbc_metadata_defaults"));
        return hibernateProperties;
    }

}



SPRING:


2023-09-09 15:26:56.116 DEBUG [edge-gateway,,] 26726 --- [tbeatExecutor-0] o.s.web.client.RestTemplate              : Accept=[application/json, application/*+json]
2023-09-09 15:26:56.185 DEBUG [edge-gateway,,] 26726 --- [tbeatExecutor-0] o.s.web.client.RestTemplate              : Response 200 OK
2023-09-09 15:26:57.186 DEBUG [edge-gateway,,] 26726 --- [tbeatExecutor-0] o.s.web.client.RestTemplate              : HTTP PUT http://172.16.254.122:7082/eureka/apps/EDGE-GATEWAY/192.168.1.6:edge-gateway:7081?status=UP&lastDirtyTimestamp=1694251602315




exclude dependency adn add dependency
------------------------------------------

   implementation('org.springframework.boot:spring-boot-starter-web') {
                // Exclude javax.xml.bind.JAXBElement
                exclude group: 'javax.xml.bind', module: 'jaxb-api'
            }

            // Add Jakarta XML Binding (Jakarta XML-Bind) dependencies
            implementation 'jakarta.xml.bind:jakarta.xml.bind-api:3.0.0'
            implementation 'org.glassfish.jaxb:jaxb-runtime:3.0.0'



================================================
#jdbc | connection | Hadoop |  impala | haddop                                 
================================================

Impala connection string:
	jdbc:impala://myrandomhost.imranmadbdr.net:8082;AuthMech=3;UID=werdsfdf;PWD=sfsdfsdf_dsfsdf;SSL=1;AllowSelfSignedCerts=1;
	CAIssuedCertNamesMismatch=1;TrustedCerts=/home/impala/mysec.pem;
	transportMode=HTTP;httpPath=gateway/cdp-proxy-api/impala;



haddop Connection:
    public String getHadoopConnectionString() {
        String workingDir = System.getProperty("user.dir");
        String conStr = "jdbc:phoenix:thin:url=%s://%s:%s/gateway/my-proxy-api/avatica;authentication=BASIC;ssl=true;avatica_user=%s;avatica_password=%s;truststore=%s;truststore_password=%s;serialization=PROTOBUF";
        return String.format(conStr, this.hadoopServerProtocol, this.hadoopServerIP,
                this.hadoopServerPort, this.hadoopUserUserId, this.hadoopUserPassword, workingDir + File.separator + "my-super-sec.jks", this.hadoopTruststorePassword);
    }

	



=================================================
##reactive programming | Reactive programming
=================================================

Flux — From Array/List:
	List<String> list = Arrays.asList("X", "Y", "Z").log();
	Flux<String> fluxFromList = Flux.fromIterable(list);
	fluxFromArray.subscribe(System.out::println);





Mono & Flux:
	Mono handles a single value or empty, while Flux handles multiple values.
Mono: Mono.just("Hello") - Emits a single item "Hello".
Flux: Flux.just("A", "B", "C") - Emits multiple items "A", "B", "C".





What Reactive Programming  actually:
----------------------------------------------------
Ann wants to have a party on a Friday night. She has to invite her friends, clean the apartment, and cook dinner. 

What options do we have here?

	1.Ann finishes her work and calls her friends. Then she heads to the supermarket to buy food, waits in line to pay, 
	and goes home. Once at home, she starts cooking. When dinner is ready, she cleans the apartment, gusts arrive, and 
	most likely wait till Ann finishes all the work. The party starts later.

	This is a description of a sync approach to the problem (request), as all the tasks are completed one after another. 
	As a result, it will take a long time for the party to start.


	2. Ann finishes her work and sends invitations to her friends. 
	Then she orders food delivery online and heads home to clean the apartment. By the time the apartment is clean, 
	food is delivered. Ann is having dinner without her friends.
	This is an example of the async approach.

	3. Ann finishes her work and sends invitations to her friends. She orders food delivery online and heads home to 
	clean the apartment. She finishes cleaning and gets the delivery. 
	But this time she waits for her friends to arrive and start the party.

	The last option is a description of the reactive approach. That is to say. 
	The RP is when you wait for async actions to complete (make a change) to proceed with further steps.


In comparison with reactive and imperative programming:
	 In imperative programming, you pull the data while in reactive, you push it.






How Reactive Programming Works:
	Define Data Streams (Observables):
		For example, you might create a data stream for clicks on a button or a data feed from a sensor. 
		Each stream emits data whenever there’s a new event.

	Subscribe to Streams (Observers):
		Observers subscribe to these streams. For example, a UI element might subscribe to a stream of data from an 
		API so that it can display updated information whenever it arrives.

	Apply Transformations (Operators):
		You can use operators to transform the data before it reaches the Observers. For example, you might 
		filter out certain values, merge multiple streams, or throttle the frequency of updates.

	Handle Emissions and React to Changes:
		When an event occurs (such as a new data item in the stream), Observers react immediately, executing their defined 
		callback functions. This approach eliminates the need for polling, reducing CPU usage and improving responsiveness.


Example:Stock prices Monitor App
	1. Observables: The Stream of Stock Prices
		Stock Price Observable: 100 -> 101 -> 102 -> 103 ...
		Each price (100, 101, 102, etc.) is an event in this stream. This Observable is a source of data.


	2. Observers: Subscribing to the Stock Price Stream
		stockPriceObservable.subscribe(newPrice -> updateScreen(newPrice));
		Here, updateScreen(newPrice) is called automatically each time a new stock price appears in the stream. 
		We don’t have to check for new prices — we just react when they arrive.

	3. Operators: Transforming the Stream
	   stockPriceObservable
		.filter(newPrice -> Math.abs(newPrice - previousPrice) > 1)
		.subscribe(newPrice -> updateScreen(newPrice));


	4. Scheduler: Controls which threads handle the filtering and screen updates.


Traditional Polling Approach (Non-Reactive) vs Reactive Programming Solution (Event-Driven)
-----------------------------------
In a non-reactive setup:
	Polling: You might set up a loop to call the API every second or few seconds, checking if the price has changed.
	Updating the Screen: If there's a change, the app updates the screen.

In a reactive setup:
	Reactive programming, by contrast, is event-driven — it reacts to new data as soon as it arrives, 
	without needing constant polling. In this approach:
	Data Push Model: The system (e.g., stock price API) pushes updates whenever there is a change, instead of the app 
		asking (polling) for updates. This way, new prices arrive immediately without unnecessary requests.
	Observables: You create an Observable that represents the price stream, which "pushes" updates automatically 
		when there’s a new price.
	Automatic Screen Update: Whenever the Observable receives new data, the Observer (the screen) reacts and updates automatically.


Reactive programmeing approach like Kfka:(Kafka vs Reactive)
	Kafka:
		When you need reliable event storage or replay.
		When many services/clients need to consume the data.
		If you need to process data asynchronously (e.g., analytics, delayed reactions).
		If your data stream is high throughput and scalable.
		When the app can tolerate some delay in data reception.
		Use Push APIs (WebSockets/SSE)

	Reactive:
		When updates need to be reflected in real time.
		For 1-to-1 or limited connections needing real-time data.
		For immediate actions on every data change.
		For low-latency, lightweight updates (e.g., notifications).
		For immediate UI updates (e.g., live stock tickers).




Java Summary of Annotation:
=================================================
Target				ElementType					Example
Class/Interface		ElementType.TYPE			@Entity class MyClass {}
Method				ElementType.METHOD			@Test public void myMethod() {}
Field				ElementType.FIELD			@NotNull private String name;
Constructor			ElementType.CONSTRUCTOR		@Inject public Example() {}
Parameter			ElementType.PARAMETER		public void setName(@NotNull String n)
Local Variable		ElementType.LOCAL_VARIABLE	@SuppressWarnings("unused") int x;
Package				ElementType.PACKAGE			package-info.java
Annotation			ElementType.ANNOTATION_TYPE	Custom meta-annotations
Type Use			ElementType.TYPE_USE		@NonNull String name;
Module				ElementType.MODULE			module-info.java



Custom annotations can be defined on three levels:
	Class Level
	Field Level
	Method Level

Types of Annotation
	There are three types of annotations.
	Marker Annotation
	Single-Value Annotation
	Multi-Value Annotation



Points to remember for java custom annotation signature:
	Method should not have any throws clauses
	Method should return one of the following: primitive data types, String, Class, enum or array of these data types.
	Method should not have any parameter.
	We should attach @ just before interface keyword to define annotation.
	It may assign a default value to the method.



Built-in Annotations used in custom annotations in java:
	@Target
	@Retention
	@Inherited
	@Documented


@Target(ElementType.TYPE)
This specifies where the annotation can be applied.
	ElementType.TYPE means this annotation can be applied to:
	Classes
	Interfaces
	Enums
	It cannot be applied to methods, fields, parameters, or other elements.





=================================================
##doc-java
=================================================

Jave Free or Paid
=================================================
Free Options: OpenJDK and various vendor distributions (like Amazon Corretto, Red Hat OpenJDK, etc.) are available for free.
Paid Option: Oracle JDK is free for development but may require a paid subscription for commercial use.



Java vs Other language Comparison
-------------------------------------------------
Comparison:Java "write once, run anywhere" vs PHP or Python
	Java offers a more robust and consistent cross-platform execution model compared to Python and PHP, 
	which depend more heavily on the specific interpreter environment.


Consistency Across Platforms:
	Java provides a more consistent execution environment through the JVM, which abstracts away many 
	platform-specific differences.
	This means that Java applications are less likely to encounter compatibility issues when moving between 
	environments, as long as the JVM version supports the bytecode.

	In contrast, Python and PHP, while capable of cross-platform development, may require more management of 
	the execution environment, which can lead to potential discrepancies and increased maintenance efforts.





==============================================
##Collection Framework | collection framework
==============================================
Java Collection Framework (JCF) is a set of classes and interfaces in the java.util package designed to handle collections of objects. 
It provides data structures and algorithms to manipulate, store, and retrieve data efficiently. 


Key Components of the Collection Framework:
	Interfaces (Blueprints for collections):
		Collection: Root interface for most collection types.
		List: Ordered, allows duplicates. (e.g., ArrayList, LinkedList)
		Set: No duplicates. (e.g., HashSet, TreeSet)
		Map: Stores key-value pairs. (e.g., HashMap, TreeMap)
		Queue: Elements processed in FIFO order. (e.g., PriorityQueue)

	Classes (Concrete implementations):
		ArrayList: Resizable array, good for random access.
		LinkedList: Doubly linked list, good for frequent insertions/deletions.
		HashSet: Unordered, unique elements.
		HashMap: Key-value storage, allows fast lookups.

	Algorithms:
		Sorting: Sort elements (e.g., Collections.sort()).
		Searching: Find elements (e.g., binarySearch()).


Why Interface and Classes:
	Interface like List defines the contract for ordered collections, but it does not specify how elements should be stored or accessed. 
	Concrete implementations like ArrayList, LinkedList, and Vector provide flexibility, efficiency, 
	and thread-safety options, empowering developers to choose the best-fit implementation for their specific requirements.
Same for all other Interface List: Set, Map.

Why Multiple Implementations:
	Performance trade-offs: Depending on whether insertion order, sorting, or fast lookups are more important, developers can choose the appropriate implementation.
	Memory usage: TreeSet might use more memory than HashSet due to the tree structure.
	Functional differences: LinkedHashSet offers insertion order while TreeSet provides sorting, which might not be interchangeable.






Hierarchy Diagram
-----------------------------------------------
Collection
  |-- List
  |     |-- ArrayList
  |     |-- LinkedList
  |     |-- Vector
  |
  |-- Set
  |     |-- HashSet
  |     |-- LinkedHashSet
  |     |-- TreeSet
  |
  |-- Queue
        |-- PriorityQueue
        |-- ArrayDeque

Map
  |-- HashMap
  |-- LinkedHashMap
  |-- TreeMap
  |-- Hashtable




1. List
	Definition: Ordered collection of elements; allows duplicates.
	Key Features:
		Maintains insertion order.
		Can access elements by index.
	Use Case: When you need to maintain the order of elements or allow duplicates.
	Examples:
		Thread-Safe: Vector, CopyOnWriteArrayList.
		Non-Thread-Safe: ArrayList, LinkedList.

2. Set
	Definition: Collection of unique elements; no duplicates allowed.
	Key Features:
		Does not maintain order (except LinkedHashSet and TreeSet).
		Efficient for checking existence of an element.
	Use Case: When you need unique elements or need to perform operations like union, intersection, etc.
	Examples:
		Thread-Safe: CopyOnWriteArraySet, ConcurrentSkipListSet.
		Non-Thread-Safe: HashSet, TreeSet.

3. Map
	Definition: Key-value pairs; keys must be unique.
	Key Features:
		Allows fast lookup by key.
		Keys must be unique, but values can be duplicated.
	Use Case: When you need to map keys to values, like a dictionary.
	Examples:
		Thread-Safe: Hashtable, ConcurrentHashMap, ConcurrentSkipListMap.
		Non-Thread-Safe: HashMap, TreeMap.
		.




Java Collections Beyond List, Set, and Map:
-----------------------------------------------
1. Queue
	FIFO Order: Processes elements in the order they were added.
	Examples: LinkedList, PriorityQueue.
	Use: Task scheduling.
2. Deque (Double-Ended Queue)
	Both Ends: Add/remove from both ends.
	Examples: ArrayDeque, LinkedList.
	Use: Stack (LIFO) or Queue (FIFO) replacement.
3. Stack
	LIFO Order: Last-in, first-out.
	Examples: Legacy Stack, modern Deque.
	Use: Undo, expression evaluation.
4. Navigable Collections
	Sorted and Navigable: Traverse in sorted order or find ranges.
	Examples: TreeSet, TreeMap, ConcurrentSkipListMap.
	Use: Sorted storage, range queries.
5. Specialized Collections, For specific performance or memory needs.
	WeakHashMap: Keys are garbage-collected.
	IdentityHashMap: Compares keys by reference.
	EnumSet/EnumMap: Optimized for enums.

Utilities:
	Collections Class: Provides utility methods (e.g., sort, reverse, synchronizedList, etc.).
	Arrays Class: Used for working with arrays (e.g., converting to lists, sorting).
	Stream API: Part of Java 8+ for functional-style operations (e.g., filtering, mapping, reducing).




Internal data structures of Java Collections Framework:
=======================================================
--------------------------------------------------------------------------------------------
Class           | InternalDataStructure              | OptimizedFor
--------------------------------------------------------------------------------------------
ArrayList       | Resizable Array                    | Fast random access and iteration.
--------------------------------------------------------------------------------------------
LinkedList      | Doubly Linked List                 | Frequent insertions/deletions.
--------------------------------------------------------------------------------------------
HashSet         | Hash Table (via HashMap)           | Fast lookups and no duplicates.
--------------------------------------------------------------------------------------------
TreeSet         | Red-Black Tree                     | Sorted elements.
--------------------------------------------------------------------------------------------
HashMap         | Hash Table + Linked List/TreeMap   | Fast key-based lookups.
--------------------------------------------------------------------------------------------
TreeMap         | Red-Black Tree                     | Sorted key-value pairs.
--------------------------------------------------------------------------------------------
PriorityQueue   | Binary Heap                        | Priority-based processing.
--------------------------------------------------------------------------------------------
ArrayDeque      | Circular Array                     | Efficient double-ended operations.
--------------------------------------------------------------------------------------------


Details:
-----------------------------------------------------|
1. ArrayList
============
	Internal Data Structure: Resizable Array.
		If the number of elements exceeds the capacity of the array, the ArrayList creates a new, larger array and copies all the elements from the old array to the new one.
		This process makes the ArrayList dynamic, as it can grow in size automatically.

	Fast Random Access to Elements (O(1)):
		Random access means you can access any element in the list using its index without needing to traverse the list.
		Arrays store elements in contiguous memory locations.
		When you access an element at index i, the system computes the memory address as: 
			base_address + (i * size_of_element)
		This is why retrieving an element by index is fast and does not depend on the size of the list.

VisualRepresentations:
----------------------
Initial State (Empty ArrayList):

	ArrayList: [null, null, null, null, null, null, null, null, null, null]
	Capacity: 10
	Size: 0 (no elements yet)

Adding Elements:
list.add("Apple");

	ArrayList: ["Apple", null, null, null, null, null, null, null, null, null]
	Capacity: 10
	Size: 1

AccessingElement:
list.get(1)

ArrayList: ["Apple", "Banana", null, null, null, null, null, null, null, null]
Index:       0        1
String fruit = list.get(1); // Returns "Banana"


Exmaple:
	ArrayList<String> list = new ArrayList<>();
	list.add("Apple");
	list.add("Banana");
	list.add("Cherry");
	System.out.println(list.get(1)); // Accesses "Banana" in O(1) time


Performance Impact of Resizing:
	Resizing is a relatively expensive operation because it involves:
	Allocating a new array.
	Copying all existing elements to the new array.





2. LinkedList
=============
Internal Data Structure: Doubly Linked List
	A doubly linked list is a sequence of nodes where:
	Each node contains:
		Data: The value stored in the node.
		Next: A pointer/reference to the next node in the sequence.
		Previous: A pointer/reference to the previous node in the sequence.
	The LinkedList has:
		Head: Points to the first node.
		Tail: Points to the last node


Visualization of a Doubly Linked List:
Head -> [null <- Node1(Data: "A") -> Node2] <-> [Node1 <- Node2(Data: "B") -> Node3] <-> [Node2 <- Node3(Data: "C") -> null] <- Tail

null represents the absence of a reference at the start or end.
Each node links to both its predecessor and successor.

Oops:
Efficient for Frequent Insertions/Deletions (O(1) in some cases):
	Adding or removing elements at the start or end is very efficient:
		Update the pointers of the affected nodes.
	Insertions/deletions in the middle:
		Locate the target node (O(n) for traversal).
		Update pointers without shifting other elements

	Example:
	LinkedList<String> list = new LinkedList<>();
	list.add("A"); // Add to the end (efficient)
	list.addFirst("B"); // Add to the start (efficient)
	list.add(1, "C"); // Add at index 1 (locate and insert)

Sequential Access (No Random Access):
	LinkedList does not support constant time random access like ArrayList.
	Accessing an element by index requires traversal:
	Start from the head for the first half of the list.
	Start from the tail for the second half of the list.

	Example:
	System.out.println(list.get(2)); // Traverses the list to find the 2nd index

Dynamically Sized:
	Similar to ArrayList, it can grow or shrink dynamically.
	Unlike ArrayList, it does not require resizing or memory copying since it doesn't rely on an underlying array.


Example Visualization:
----------------------
Initial Empty List
	Head -> null
	Tail -> null

Add Elements:
	list.add("A");
	list.add("B");
	list.addFirst("C");
Head -> [null <- Node(C) -> Node(A)] <-> [Node(C) <- Node(A) -> Node(B)] <-> [Node(A) <- Node(B) -> null] <- Tail

Remove an Element:
list.remove("A");
Head -> [null <- Node(C) -> Node(B)] <-> [Node(C) <- Node(B) -> null] <- Tail



-----------------------------------------------------------------------------------------
Operation                  | Time Complexity | Explanation
---------------------------|-----------------|-------------------------------------------
Add at the start (addFirst)| O(1)           | Update pointers of the head node.
Add at the end (addLast)   | O(1)           | Update pointers of the tail node.
Add at a specific index    | O(n)           | Traverse to the position and update pointers (O(1)).
Remove at the start        | O(1)           | Update head pointer and detach the first node.
(removeFirst)              |                |
Remove at the end          | O(1)           | Update tail pointer and detach the last node.
(removeLast)               |                |
Remove at a specific index | O(n)           | Traverse to the position and update pointers.
Access an element by index | O(n)           | Traverse the list from the head or tail to reach the desired index.
Iterate through the list   | O(n)           | Requires visiting each node sequentially.




3. HashSet
=============
A HashSet is a collection in Java that ensures no duplicate elements and is fast for adding, removing, and checking elements.
Internally, a HashSet uses a Hash Table via a HashMap.
It calculates a hash code to decide where to store the element.
It uses equals() to ensure no duplicate elements are added.
Internal Data Structure: Hash Table (via HashMap)


HashSet uses a Hash Table via a HashMap: 
	it means that the internal working of a HashSet is based on a HashMap.

How Does HashSet Work with HashMap?
	A HashSet does not maintain its own separate data structure; instead, it relies on a HashMap to store its elements. Here's how:

	Every Element in a HashSet is a Key in a HashMap:
		When you add an element to a HashSet, it is stored as a key in an internal HashMap.
		The corresponding value in the HashMap is a dummy object (often Boolean.TRUE).

	Hash Codes and Buckets:
		The HashMap uses the hash code of the key (the element in the HashSet) to decide which bucket to use.
		This mechanism ensures efficient storage and retrieval.

	Ensuring Uniqueness:
		Because a HashMap cannot have duplicate keys, the HashSet automatically ensures that duplicate elements are not adde.


Bucket Visualization:
Suppose we have 5 buckets (array size = 5):
Buckets: [0]  [1]  [2]  [3]  [4]
          ↑    ↑    ↑    ↑    ↑

Adding Objects:
	Add "Apple". hashCode("Apple") % 5 = 3, so "Apple" goes into bucket [3].
	Add "Banana". hashCode("Banana") % 5 = 1, so "Banana" goes into bucket [1].
	Add "Orange". hashCode("Orange") % 5 = 3, so "Orange" goes into bucket [3] (collision handled).
After adding, it looks like:
Buckets: [0]  [1: Banana]  [2]  [3: Apple -> Orange]  [4]


What Happens When Adding Elements?
	Add "Apple":
	HashSet calls HashMap.put("Apple", Boolean.TRUE).
	A hash code for "Apple" is computed.
	"Apple" is stored in the appropriate bucket.

Add "Banana":
	HashSet calls HashMap.put("Banana", Boolean.TRUE).
	A hash code for "Banana" is computed.
	"Banana" is stored in another bucket.

Add Duplicate "Apple":
	HashSet calls HashMap.put("Apple", Boolean.TRUE) again.
	HashMap finds that "Apple" already exists (using equals() and hash code).
	"Apple" is not added again.


How hashCode() and equals() Work Together:
	hashCode(): Determines the bucket (the location in the hash table).
		Two objects with the same hash code end up in the same bucket.
	equals(): Compares two objects within the same bucket to check if they are the same element logically 
	(even if they have the same hash code).
		Only if the objects have the same hash code and equals() returns false, the new element is added.




Features of HashSet:
===================================================================================
Feature                | Explanation
-----------------------|-----------------------------------------------------------
Unique Elements        | Ensures no duplicate elements by checking hashCode() and equals().
Unordered Collection   | Does not guarantee any specific order of elements.
Efficient Operations   | Add, remove, and search operations are average O(1) (constant time), assuming a good hash function.
Null Support           | Allows a single null element since null has its own hash code and equality rules.


Operations and Their Complexity:
====================================================================================================
Operation                   | Time Complexity | Explanation
----------------------------|-----------------|--------------------------------------------------------
Add an element (add)        | O(1) (average)  | Calculates the hash, finds the bucket, and inserts the key.
Remove an element (remove)  | O(1) (average)  | Calculates the hash, finds the bucket, and removes the key.
Check if exists (contains)  | O(1) (average)  | Calculates the hash, finds the bucket, and checks for existence.
Iterate through elements    | O(n)            | Iterates over all the buckets and their elements.



4. TreeSet
======================
	Internal Data Structure: Red-Black Tree (Self-Balancing Binary Search Tree)
	Elements are stored in sorted order.
	Operations like add, remove, and search maintain the tree's balance.




5. HashMap
======================
Internally uses a hash table (an array of buckets).
Each bucket is a container for storing key-value pairs, and the location of the bucket is determined by the hash code of the key.

Buckets: [0]  [1: Banana]  [2]  [3: Apple -> Orange]  [4] thias way

	Internal Data Structure: Hash Table + Linked List (or TreeMap for collision handling)
		A HashMap stores key-value pairs where each key is associated with a value.
		These pairs are organized in buckets, and each bucket's location is determined by a hash code.

Adding a Key-Value Pair:
	Let's say you add "A" -> 1 to the HashMap:
	The hashCode() method calculates a hash value for "A".
	The hash value is used to determine the bucket index.
	If the bucket at that index is empty, the key-value pair is placed there.
	If the bucket already has a key-value pair (collision), the equals() method is used to check if the existing key is the same as the new key. If not, the new key-value pair is added.

Summary of Key Concepts:
	Hash Table: Stores key-value pairs in buckets based on their hash code.
	Buckets: Containers for key-value pairs, indexed by a hash value.
	Collisions: Occur when multiple keys map to the same bucket.
	Handling Collisions:
			Before Java 8: Linked List.
			After Java 8: TreeMap when the bucket exceeds a threshold.
		Efficiency:
			Before Java 8: Collisions were handled with linear search (Linked List).
			After Java 8: TreeMap improves search efficiency with logarithmic time complexity.

Keys in a HashMap must be unique.
Values can be duplicate, i.e., multiple keys can have the same value.
If you try to insert a duplicate key, the value will be overwritten with the new one.


Example:
	import java.util.HashMap;

	public class Main {
		public static void main(String[] args) {
			HashMap<String, Integer> map = new HashMap<>();
			
			map.put("A", 1);  // Adds key "A" with value 1
			map.put("B", 2);  // Adds key "B" with value 2
			map.put("A", 10); // Updates the value for key "A" to 10

			System.out.println(map); // Output: {A=10, B=2}
		}
	}







VisualRepresentations: HashMap (with collisions)

Bucket[0]: Node(key1, value1) -> Node(key2, value2)
Bucket[1]: Node(key3, value3)
Bucket[2]: Empty




6. TreeMap
======================
	Internal Data Structure: Red-Black Tree
	Keys are sorted based on their natural ordering or a custom comparator.

VisualRepresentations:
-------------------------

       10
      /  \
     5   20
    / \    \
   3   7    25



7. PriorityQueue
======================
	Internal Data Structure: Binary Heap (Min-Heap by default)
	Elements are arranged to maintain the heap property:
		The smallest (or highest priority) element is at the root.
		Child nodes have a value greater than or equal to their parent.

VisualRepresentations:
-------------------------

8. ArrayDeque
	Internal Data Structure: Resizable Array
	Uses a circular array to implement a double-ended queue.
	Automatically resizes when full.





Thread Ops in Collections:
==========================
In the Java Collection Framework, some classes are thread-safe, while others are not thread-safe. Here's a categorized breakdown:

1. Non-Thread-Safe Collections
	ArrayList	: Non-thread-safe alternative to Vector.
	LinkedList	: Non-thread-safe list implementation.
	HashMap		: Non-thread-safe key-value store.
	HashSet		: Non-thread-safe set implementation.
	TreeMap		: Non-thread-safe sorted map.
	TreeSet		: Non-thread-safe sorted set.


2. Thread-Safe Collections
Legacy Thread-Safe Classes
	Vector: Thread-safe alternative to ArrayList.
	Stack: Extends Vector and provides LIFO operations.
	Hashtable: Thread-safe alternative to HashMap.

Synchronized Wrappers:
You can make a collection thread-safe using the Collections.synchronizedXXX methods:
	Collections.synchronizedList(List list): Thread-safe wrapper for ArrayList, LinkedList, etc.
	Collections.synchronizedMap(Map map): Thread-safe wrapper for HashMap.
	Collections.synchronizedSet(Set set): Thread-safe wrapper for HashSet.

Concurrent Collections (Modern Thread-Safe Classes):
Introduced in the java.util.concurrent package, these classes are optimized for performance in multithreaded environments:
	CopyOnWriteArrayList: Thread-safe list with better performance for read-heavy workloads.
	CopyOnWriteArraySet: Thread-safe set similar to CopyOnWriteArrayList.
	ConcurrentHashMap: Thread-safe alternative to HashMap with finer-grained locking.
	ConcurrentSkipListMap: Thread-safe map with sorted keys.
	ConcurrentSkipListSet: Thread-safe set with sorted elements.
	BlockingQueue (e.g., LinkedBlockingQueue, ArrayBlockingQueue, PriorityBlockingQueue): Thread-safe queues for producer-consumer scenarios.




Thread-Safe(In a short):
	List:
		Vector (Legacy).
		CopyOnWriteArrayList (Modern, better for reads).
		Collections.synchronizedList(List) (Wrapper).
	Set:
		CopyOnWriteArraySet (Modern, better for reads).
		Collections.synchronizedSet(Set) (Wrapper).
		ConcurrentSkipListSet (Sorted, thread-safe).
	Map:
		Hashtable (Legacy).
		ConcurrentHashMap (Modern, highly efficient).
		Collections.synchronizedMap(Map) (Wrapper).
		ConcurrentSkipListMap (Sorted, thread-safe).


Non-Thread-Safe(In a short):
	List:
		ArrayList.
		LinkedList.
	Set:
		HashSet.
		TreeSet.
	Map:
		HashMap.
		TreeMap.





Stream api | stream-api
=================================================
The Java Stream API is a part of the java.util.stream package introduced in Java 8. It provides a functional 
programming approach to process collections of data in a concise, readable, and flexible way. 
The Stream API allows for operations like filtering, mapping, reducing.


No Built-in Speed Advantage in Sequential Mode:
The Stream API doesn't magically make collection processing faster by itself.

In sequential mode, the Stream API performs operations in a similar way to regular loops (for, forEach). 
It doesn't have any inherent performance advantage for small datasets.
In fact, streams may introduce a slight overhead because of their functional nature and internal pipeline creation.


Benefits of Stream API:
	Simplifies Complex Operations:
		Declarative style: Stream pipelines make multi-step operations like filtering, mapping, and reducing easier 
		to write and read compared to nested loops or manual iteration.

	Built-in Parallelism for Large Datasets:
		Streams offer parallelStream(), which automatically divides the data and processes it across multiple threads.

	Lazy Evaluation for Efficiency:
		Streams process data lazily, meaning intermediate operations (filter, map) are not executed until a 
		terminal operation (collect, forEach) is called.

	Code Conciseness and Clarity:
		For complex tasks involving multiple transformations, a stream pipeline is often cleaner and more expressive 
		than nested loops or manual iteration.
		Example: Filtering and transforming collections can be done in a single chain rather than multiple nested loops.


When to Use Streams:
	When processing a collection involves multiple steps (e.g., filtering, mapping, reducing).
	When working with large datasets that may benefit from parallel processing.
	When striving for clean, functional, and maintainable code.

When Not to Use Streams:
	For small datasets where performance overhead isn't justified.
	When readability is compromised for simple operations (e.g., basic iteration).
	When debugging or tracing complex stream pipelines becomes difficult.




Exception Handling
===================================================
Key Concepts in Exception Handling
Exception: An object that represents an error or unexpected behavior in a program.
Types of Exceptions:
	Checked Exceptions: Exceptions that must be declared in the method signature or handled using a try-catch block.
	Example: IOException, SQLException

	Unchecked Exceptions: Runtime exceptions that do not need to be declared or caught. They usually indicate programming errors.
	Example: NullPointerException, ArrayIndexOutOfBoundsException

	Error
	Definition: An error is a serious problem that a typical application should not try to catch. 
	It indicates unrecoverable conditions, usually related to the environment or system.

	Examples:
	OutOfMemoryError: Thrown when the Java Virtual Machine (JVM) cannot allocate memory for an object.
	StackOverflowError: Thrown when the stack depth exceeds its limit, typically due to deep or infinite recursion.
	InternalError: Thrown when an internal error in the JVM occurs.



Basic Syntax for Exception Handling:
	Try-Catch Block: Used to catch exceptions.
	try {
		// Code that may throw an exception
	} catch (ExceptionType e) {
		// Code to handle the exception
	}

	Finally Block: A block that executes after the try-catch block, regardless of whether an exception was thrown or caught. 
	It's typically used for resource cleanup.
	finally {
		// Code that always executes
	}


	Throw Statement: Used to explicitly throw an exception.
	throw new ExceptionType("Error message");


	Throws Keyword: Indicates that a method may throw a particular exception, allowing the caller to handle it.
	public void method() throws ExceptionType {
		// Method code
	}





=================================================
##Jakarta
=================================================
Jakarta is a collection of open-source APIs and technologies for building enterprise-level Java applications. 
It is not part of the JDK (Java Development Kit).
Jakarta EE is the new name for Java EE (after Oracle donated Java EE to the Eclipse Foundation).

Is Jakarta Part of JDK 17 or JDK 21/23? No, Jakarta is not part of the JDK.
	The JDK is the standard Java Development Kit that includes the Java SE (Standard Edition) libraries and tools for general-purpose programming.
	Jakarta EE provides additional libraries for enterprise-level application development, which are not bundled with the JDK.



How to Use Jakarta in Your Application?
<dependency>
    <groupId>jakarta.validation</groupId>
    <artifactId>jakarta.validation-api</artifactId>
    <version>3.0.2</version>
</dependency>


Runtime Libraries:
	To run Jakarta EE applications, you need a compatible application server like:
	Apache Tomcat
	WildFly
	Payara Server
	Jakarta-compatible runtimes like Eclipse GlassFish

Key Jakarta APIs and Their Uses:

Jakarta Servlet:			For web applications and HTTP handling	<artifactId>jakarta.servlet-api</artifactId>
Jakarta Persistence (JPA):	For database operations using ORM	<artifactId>jakarta.persistence-api</artifactId>
Jakarta Validation:			For validating bean properties and method arguments	<artifactId>jakarta.validation-api</artifactId>


wtih Spring Boot:
	Spring Boot abstracts Jakarta EE APIs: The starters already include and configure the Jakarta EE libraries that are 
	required for enterprise functionality.
	Spring Boot manages versions: The Jakarta EE versions are pre-configured in the Spring Boot BOM (Bill of Materials), 
	so you don't need to manually specify or manage them.









Java Memory Management: Key Areas
=================================================
Heap Memory
	Definition: Area for dynamic memory allocation for objects and arrays.
	Characteristics:
		Managed by garbage collection.
		Shared among threads.
		Default Behavior: Size can be set with -Xms (initial) and -Xmx (maximum).

Stack Memory
Definition: Used for method execution, storing local variables and method call information.
Characteristics:
	Fixed size per thread.
	Follows a LIFO structure (Last In, First Out).
	Default Behavior: Local variables are automatically deallocated after method execution.

Method Area (Metaspace in Java 8+)
Definition: Stores class metadata, method data, and constant pool information.
Characteristics:
	Shared across threads.
	In Java 8+, dynamically allocated from native memory.
	
Native Memory
Definition: Memory allocated outside the Java heap and stack, often for JNI calls.
	Characteristics: Not managed by Java's garbage collector.




=================================================
Default bahavor of jvm and java-app
=================================================
Default JVM Memory Management:

Initial and Maximum Heap Sizes:
	Initial Heap Size (-Xms): Typically defaults to 1/64th of the physical memory. On a 32GB system, this would be around 512MB.
	Maximum Heap Size (-Xmx): Typically defaults to 1/4th of the physical memory. On a 32GB system, this would be around 8GB.



The default heap size settings of the JVM (Java Virtual Machine) apply to each individual Java application instance. 
This means that each Java application you run on your host machine will have its own separate heap memory, 
and the default settings will be applied individually to each application.

Example: app1.jar and app2.jar run in a host machine with 32GB ram with out any vm option:
	Running Applications Without Specified Heap Sizes:
Application 1:
	Initial Heap: 512MB
	Maximum Heap: 8GB

Application 2:
	Initial Heap: 512MB
	Maximum Heap: 8GB

Memory Allocation:
Each application (myapp1.jar and myapp2.jar) will have an initial heap size of around 512MB.
Each application can grow its heap up to a maximum of around 8GB.



When use Swap memory by java:
---------------------------------------
Swap usage despite available RAM can occur due to historical memory pressure, swappiness settings, long-running processes, 
and memory fragmentation.
Adjust the swappiness value to control swap usage.
Clear swap space by disabling and re-enabling it if necessary.
Optimize Java applications to ensure efficient memory usage.
Regularly monitor system memory and swap usage to identify any abnormal patterns or processes consuming excessive memory.



=>cat /proc/sys/vm/swappiness
current swappiness value:

=>sudo sysctl vm.swappiness=10
set swappindess:


Clear Swap Space:
sudo swapoff -a
sudo swapon -a




=================================================
Approaches to Track Threads in a Java Application
=================================================
Find the Process ID (PID):
=>jps -v

Get Thread Dump:
=>jcmd <PID> Thread.print > thread_dump.txt

Thread.dump provides detailed information about all threads, their states (e.g., RUNNING, BLOCKED), and stack traces.
Analyze the dump for high memory-consuming threads or blocked threads.





GC process
-----------------------------------------
1. Young Generation Collection:
Allocation: New objects are allocated in the Young Generation. This area is further divided into three spaces: Eden and two Survivor spaces (S0 and S1).

Minor Garbage Collection (Minor GC): When the Young Generation fills up, a minor GC is triggered. During this phase:


2. Old Generation Collection:
Promotion: Objects that survive multiple minor GCs are eventually promoted to the Old Generation.

Major Garbage Collection (Major GC or Full GC): The Old Generation collection is more expensive but occurs less frequently. During a major GC:

Live objects in the Old Generation are identified.
Unused (garbage) objects are collected, and memory is reclaimed.
Compaction may occur to reduce fragmentation and ensure efficient memory usage.




JVM performance tuning for large applications:  benchmark, Benchmark, BENCHMARK!




=================================================
##thread | Java Thread Pool Optimization
=================================================
MediumLink:
https://dip-mazumder.medium.com/how-to-determine-java-thread-pool-size-a-comprehensive-guide-4f73a4758273


A Java Thread is like a virtual CPU that can execute your Java code - inside your Java application. 
when a Java application is started its main() method is executed by the main thread - a special thread that is created by 
the Java VM to run your application. 
From inside your application you can create and start more threads which can execute parts of your 
application code in parallel with the main thread.




The Concept Of Multitasking:
-------------------------------------
Operating System accommodates users the privilege of multitasking, where users can perform multiple actions simultaneously 
on the machine. This Multitasking can be enabled in two ways: 
	Process-Based Multitasking 
	Thread-Based Multitasking 

1. Process-Based Multitasking (Multiprocessing)
	In this type of Multitasking, processes are heavyweight and each process was allocated by a separate memory area. 
	And as the process is heavyweight the cost of communication between processes is high and it takes a long time for 
	switching between processes as it involves actions such as loading, saving in registers, updating maps, lists, etc. 

2. Thread-Based Multitasking 
	As we discussed above Threads are provided with lightweight nature and share the same address space, and the cost 
	of communication between threads is also low. 
	Thread communication between multiple threads at a Low Cost contributing to effective multi-tasking within 
	a shared memory environment. 



Life Cycle Of Thread:
	New State
	Active State
	Waiting/Blocked State
	Timed Waiting State
	Terminated State


	New: 
		By default, a Thread will be in a new state,  in this state, code has not yet been run and the execution 
		process is not yet initiated. 
	Active State:
		A Thread that is a new state by default gets transferred to Active state when it invokes the start() method, 
		his Active state contains two sub-states namely:
			Runnable State: In This State, The Thread is ready to run at any given time and it’s the job of the 
				Thread Scheduler to provide the thread time for the runnable state preserved threads.
			Running State: When The Thread Receives CPU allocated by Thread Scheduler, it transfers from the “Runnable” 
				state to the “Running” state. and after the expiry of its given time slice session, 
				it again moves back to the “Runnable” state and waits for its next time slice.
	Blocked/Waiting: 
		The thread is alive but paused, waiting for a resource or a signal.
	Timed Waiting: 
		The thread is paused for a specific time, like in sleep() or wait(timeout).
	Terminated: 
		The thread completes its task and dies.A terminated Thread means it is dead and no longer available.


Example a thread's life cycle:
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread is running...");
        try {
            Thread.sleep(1000); // Thread enters Timed Waiting state
        } catch (InterruptedException e) {
            System.out.println("Thread interrupted");
        }
        System.out.println("Thread finished execution.");
    }
}

public class ThreadLifecycleExample {
    public static void main(String[] args) {
        MyThread thread = new MyThread(); // Thread is in New state
        thread.start();                   // Thread enters Runnable state
        try {
            thread.join();                // Main thread waits for this thread to finish
        } catch (InterruptedException e) {
            System.out.println("Main thread interrupted");
        }
        System.out.println("Main thread finished.");
    }
}
The thread goes through New, Runnable, Timed Waiting (during sleep()), and Terminated states.
The main thread uses join() to wait, showing a typical use of the Waiting state



In Java, threads can be either daemon or non-daemon:
	Non-daemon threads ensure that MyThread continues to run independently of the main thread.
	Daemon threads depend on the main thread's life cycle and terminate when it does.

	In this example, MyThread is non-daemon, so the JVM will keep it running even after the main thread finishes:
		MyThread thread = new MyThread();
		thread.start();  // MyThread is a non-daemon thread by default

	However, if you set MyThread as a daemon thread by calling thread.setDaemon(true); 
	before start(), it will terminate when the main thread completes:
		MyThread thread = new MyThread();
		thread.setDaemon(true);  // Now MyThread will stop when the main thread finishes
		thread.start();




How thread work:
=============================================
Thread-safe:
	Thread-safe in Java means that a piece of code, object, or class can be safely accessed or modified by 
	multiple threads simultaneously without leading to race conditions or data corruption. 
	Thread-safety ensures consistency and correctness in a multithreaded environment by implementing proper synchronization mechanisms.
Thread-Safe Prevents data corruption in a multithreaded environment using synchronization, atomic variables, or concurrent collections.

Non-thread-safe:
	Non-thread-safe means that an object or code does not have built-in mechanisms to prevent concurrent access issues. 
	If multiple threads access or modify such an object simultaneously, it can result in unpredictable behavior, 
	data inconsistencies, or program crashes.
Non-Thread-Safe  May cause unpredictable behavior or errors when accessed by multiple threads simultaneously.

Use Cases: Thread safety is critical in concurrent programming but incurs a performance cost due to synchronization overhead. 
Only use it when necessary.


Race condition:
	A race condition happens when two or more threads access and change the same resource. 
	As a result, all threads experience data loss or an unexpected state of the resource. 
	Race conditions are something that must be avoided, especially when we want to build applications related to banking.



Thread-Safe Mechanisms:
1. Synchronization
	Synchronization ensures that only one thread can access a critical section of code or a shared resource at a time.
	Synchronized Methods: A synchronized method locks the entire object, ensuring only one thread can execute
	any synchronized method on the object at a time.
	Synchronized Blocks: More fine-grained control by locking only a specific block of code or resource.
	Static Synchronization: Used for class-level synchronization.

2. Volatile Keyword
The volatile keyword ensures visibility of changes to a variable across threads without locking.

3. Atomic Variables
Classes in the java.util.concurrent.atomic package (e.g., AtomicInteger, AtomicLong) provide low-level thread-safe 
operations without explicit synchronization.

4. Lock Mechanism
Locks provide explicit control over thread synchronization, allowing more flexibility than synchronized.

5. Thread-Safe Collections
Collections in java.util.concurrent (e.g., ConcurrentHashMap, CopyOnWriteArrayList) are designed for concurrent access 
by multiple threads.

Example: ConcurrentHashMap
	Allows multiple threads to read and write without blocking each other.
	Uses bucket-level locking (a fine-grained locking mechanism) for better performance.

6. Immutable Objects
Immutable objects are inherently thread-safe because their state cannot be changed after creation.

7. Thread Coordination
Thread coordination ensures threads work in harmony using constructs like:
wait(), notify(), and notifyAll(): These methods enable threads to communicate and synchronize actions.


How It Works:
	When a thread enters a synchronized block/method, it acquires a lock (monitor) on the object.
	Other threads trying to access synchronized code must wait until the lock is released.
	This prevents concurrent modifications and ensures data consistency.

Summary:
	Without Thread Safety: Simultaneous modifications to a List by multiple threads can cause data inconsistencies and runtime exceptions.
	Thread-Safe Solutions:
	Use Collections.synchronizedList for basic synchronization.
	Use CopyOnWriteArrayList for better performance in read-heavy situations.






There are two ways to create a thread:
	By extending Thread class
	By implementing Runnable interface.

	Thread thread = new Thread();
	thread.start();

This example doesn't specify any code for the thread to execute. Therfore the thread will stop again right away after it is started.
There are two ways to specify what code the thread should execute. 

The first is to create a subclass of Thread and override the run() method. 
The second method is to pass an object that implements Runnable (java.lang.Runnable to the Thread constructor.

Thread Subclass:
------------------------------------------
	public class MyThread extends Thread {
		public void run(){
		System.out.println("MyThread running");
		}
	}
	MyThread myThread = new MyThread();
	myTread.start();

You can also create an anonymous subclass of Thread like this:
  Thread thread = new Thread(){
    public void run(){
      System.out.println("Thread Running");
    }
  }

  thread.start();

The start() call will return as soon as the thread is started. It will not wait until the run() method is done. 
The run() method will execute as if executed by a different CPU.



Runnable Interface Implementation:
----------------------------------------------
public interface Runnable() {
    public void run();
}

There are three ways to implement the Runnable interface:
	Create a Java class that implements the Runnable interface.
	Create an anonymous class that implements the Runnable interface.
	Create a Java Lambda that implements the Runnable interface.


Java Class Implements Runnable
  public class MyRunnable implements Runnable {

    public void run(){
       System.out.println("MyRunnable running");
    }
  }

Anonymous Implementation of Runnable

Runnable myRunnable =
    new Runnable(){
        public void run(){
            System.out.println("Runnable running");
        }
    }


Java Lambda Implementation of Runnable	

Runnable runnable =
        () -> { System.out.println("Lambda Runnable running"); };



Starting a Thread With a Runnable:
	Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...
	Thread thread = new Thread(runnable);
	thread.start();





Thread Start Timing(Thread not folwo sequece as it write in code):
----------------------------------
Thread Scheduler:The JVM relies on the operating system's thread scheduler to manage thread execution.
When you call start() on a thread, it doesn’t immediately mean that the thread will begin executing right away. Instead, it transitions to the runnable state and waits for the JVM to allocate CPU time to it.
Thread 3 may not always start first because, after calling start() on it, the JVM may choose to run Thread 1 or Thread 2 first, depending on the current state of the system.






 Determining the number of CPU cores available on your server:
 int numOfCores = Runtime.getRuntime().availableProcessors();

 TwoType CPUTask:
 -CPU Intensive Tasks
 -I/O Intensive Tasks:


CPU-intensive tasks are those that require a lot of processing power, such as performing complex calculations or running simulations. These tasks are often limited by the speed of the CPU, rather than the speed of the I/O device.
	Encoding or decoding audio or video files
	Compiling and linking software
	Running complex simulations
	Performing machine learning or data mining tasks
	Playing video games
	Optimization:
	Multi-threading and parallelism: Parallel processing is a technique used to divide a larger task into smaller subtasks and distribute these subtasks across multiple CPU cores or processors to take advantage of concurrent execution and improve overall performance


IO-intensive tasks are those that interact with storage devices (e.g., reading/writing files), network sockets (e.g., making API calls), or user input (e.g., user interactions in a graphical user interface).
	Reading or writing large files to disk (e.g., saving a video file, loading a database)
	Downloading or uploading files over the network (e.g., browsing the web, watching a streaming video)
	Sending and receiving email
	Running a web server or other network service
	Performing database queries
	Web servers handling incoming requests.
	Optimization:
	Caching: Cache frequently accessed data in memory to reduce the need for repeated I/O operations.
	Load balancing: Distribute I/O-bound tasks across multiple threads or processes to handle concurrent I/O operations efficiently.
	Use of SSDs: Solid-state drives (SSDs) can significantly speed up I/O operations compared to traditional hard disk drives (HDDs).
	Use efficient data structures, such as hash tables and B-trees, to reduce the number of I/O operations required.
	Avoid unnecessary file operations, such as opening and closing files multiple times.






Determining Number Of Threads:
----------------------------------------------
For CPU Intensive Tasks:

	For CPU-bound tasks, You want to maximize CPU utilization without overwhelming the system with too many threads, 
	which can lead to excessive context switching. A common rule of thumb is to use the number of CPU cores available

	Real-Life Example: Video Encoding
	Imagine you’re developing a video processing application. Video encoding is a CPU-bound task where you need to apply complex algorithms to compress a video file. You have a multi-core CPU available.

	Determining the Number of Threads for CPU-Bound Tasks:
	Count Available CPU Cores: Use Runtime.getRuntime().availableProcessors() in Java to determine the number of available 
	CPU cores. Let's say you have 8 cores.
	Create Thread Pool: Create a thread pool with a size close to or slightly less than the number of available CPU cores. 
	In this case, you might choose 6 or 7 threads to leave some CPU capacity for other tasks and system processes.



import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class VideoEncodingApp {
    public static void main(String[] args) {
        int availableCores = Runtime.getRuntime().availableProcessors();
        int numberOfThreads = Math.max(availableCores - 1, 1); // Adjust as needed

        ExecutorService threadPool = Executors.newFixedThreadPool(numberOfThreads);

        // Submit video encoding tasks to the thread pool.
        for (int i = 0; i < 10; i++) {
            threadPool.execute(() -> {
                encodeVideo(); // Simulated video encoding task
            });
        }

        threadPool.shutdown();
    }

    private static void encodeVideo() {
        // Simulate video encoding (CPU-bound) task.
        // Complex calculations and compression algorithms here.
    }
}



For I/O Intensive Tasks:
	For I/O-bound tasks, the optimal number of threads is often determined by the nature of the I/O operations and the expected latency. You want to have enough threads to keep the I/O devices busy without overloading them. The ideal number may not necessarily be equal to the number of CPU cores.

	Real-Life Example: Web Page Crawling
	Consider building a web page crawler that downloads web pages and extracts information. This involves making HTTP requests, which are I/O-bound tasks due to network latency.

	Determining the Number of Threads for I/O-Bound Tasks:
	Analyze I/O Latency: Estimate the expected I/O latency, which depends on the network or storage. For example, if each HTTP request takes around 500 milliseconds to complete, you may want to accommodate for some overlap in I/O operations.
	Create Thread Pool: Create a thread pool with a size that balances parallelism with the expected I/O latency. You don’t necessarily need one thread per task; instead, you can have a smaller pool that efficiently manages I/O-bound tasks.


import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class WebPageCrawler {
    public static void main(String[] args) {
        int expectedIOLatency = 500; // Estimated I/O latency in milliseconds
        int numberOfThreads = 4; // Adjust based on your expected latency and system capabilities

        ExecutorService threadPool = Executors.newFixedThreadPool(numberOfThreads);

        // List of URLs to crawl.
        String[] urlsToCrawl = {
            "https://example.com",
            "https://google.com",
            "https://github.com",
            // Add more URLs here
        };

        for (String url : urlsToCrawl) {
            threadPool.execute(() -> {
                crawlWebPage(url, expectedIOLatency);
            });
        }

        threadPool.shutdown();
    }

    private static void crawlWebPage(String url, int expectedIOLatency) {
        // Simulate web page crawling (I/O-bound) task.
        // Perform HTTP request and process the page content.
        try {
            Thread.sleep(expectedIOLatency); // Simulating I/O latency
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}


Can We Follow a Concrete Formula?
The formula for determining thread pool size can be written as follows:
	Number of threads = Number of Available Cores * Target CPU utilization * (1 + Wait time / Service time)
	Number of Available Cores: This is the number of CPU cores available to your application. It is important to note that this is not the same as the number of CPUs, as each CPU may have multiple cores.


Target CPU utilization: This is the percentage of CPU time that you want your application to use. If you set the target CPU utilization too high, your application may become unresponsive. If you set it too low, your application will not be able to fully utilize the available CPU resources.
Wait time: This is the amount of time that threads spend waiting for I/O operations to complete. This can include waiting for network responses, database queries, or file operations.

Service time: This is the amount of time that threads spend performing computation.

Blocking coefficient: This is the ratio of wait time to service time. It is a measure of how much time threads spend waiting for I/O operations to complete relative to the amount of time they spend performing computation.



Example Usage:
	Suppose you have a server with 4 CPU cores and you want your application to use 50% of the available CPU resources.

	Your application has two classes of tasks: I/O-intensive tasks and CPU-intensive tasks.

	The I/O-intensive tasks have a blocking coefficient of 0.5, meaning that they spend 50% of their time waiting for I/O operations to complete.

	Number of threads = 4 cores * 0.5 * (1 + 0.5) = 3 threads

	The CPU-intensive tasks have a blocking coefficient of 0.1, meaning that they spend 10% of their time waiting for I/O operations to complete.

	Number of threads = 4 cores * 0.5 * (1 + 0.1) = 2.2 threads

	In this example, you would create two thread pools, one for the I/O-intensive tasks and one for the CPU-intensive tasks. The I/O-intensive thread pool would have 3 threads and the CPU-intensive thread pool would have 2 threads.





=================================================
# jdk | Version | feature                                      
================================================= 

All jdk features
-------------------------------------------------

Java 23
Memory Optimizations: Better memory management.
Virtual Threads Enhancements: Improved stability for lightweight threads.
Scoped Values: Safely share data across threads.
String Templates (Preview): Simplify string interpolation.
Vector API Improvements: Faster mathematical operations.

Java 21 (LTS)
Virtual Threads: Lightweight, production-ready threads.
Pattern Matching for switch: Easier, concise switch logic.
Record Patterns: Extract data more cleanly from records.
Sequenced Collections API: Operations for ordered collections.
Deprecate Finalization: Moving away from the old finalize() method.

Java 17 (LTS)
Sealed Classes: Control which classes can extend others.
Pattern Matching for instanceof: Automatic type casting after checks.
Records: Immutable, concise data classes.
Switch Expressions: Switch with return values and multiple labels.
Enhanced Random Generators: Faster and more flexible random number generation.
Deprecation of Security Manager: Marked for removal in future releases.
ZGC Improvements: Low-latency garbage collection.



#Java 23 (Planned)
Memory Management Optimizations: Better handling of memory.
Virtual Threads Enhancements: More stable and refined virtual threads.

#Java 22
Scoped Values: Safely share data across threads.

#Java 21 (LTS)
Virtual Threads: Lightweight threads for faster concurrency.
Pattern Matching for switch: Cleaner and easier switch statements.
Record Patterns: Extract data easily from record objects.
Sequenced Collections API: New ways to manage ordered collections.


#Java 20
No new stable features (focused on previews and testing).

#Java 19
No stable features (introduced many experimental features).



#Java 18 Features:
- UTF-8 by Default
- Simple Web Server
- Code Snippets in Java API Doc
- Reimplement Core Reflection with Method Handles
- Vector API
- Internet-Address Resolution SPI
- Foreign Function & Memory API
- Pattern Matching for switch

#Java 17 Features:
- Restore Always-Strict Floating-Point Semantics
- Enhanced Pseudo-Random Number Generators
- New macOS Rendering Pipeline
- macOS/AArch64 Port
- Deprecate the Applet API for Removal
- Strongly Encapsulate JDK Internals
- Pattern Matching for switch

#Java 16 Features:
- Vector API
- Enable C++14 Language Features
- Migrate from Mercurial to Git
- Migrate to GitHub
- Concurrent Thread-Stack Processing
- Unix-Domain Socket Channels
- Alpine Linux Port
- Elastic Metaspace
- Windows/AArch64 Port

#Java 15 Features
- Sealed Classes and Interfaces
- EdDSA Algorithm
- Hidden Classes
- Pattern Matching for instanceof
- Removed Nashorn JavaScript Engine
- Reimplement the Legacy DatagramSocket API
- Records (Second Preview)
- Text Blocks become a standard feature

#Java 14 Features
– Pattern Matching for instanceof
– Text Blocks
– Helpful NullPointerExceptions
– Records
– Switch Expressions
– Packaging Tool
– NUMA-Aware Memory Allocation for G1
– JFR Event Streaming
– Non-Volatile Mapped Byte Buffers
– Remove the Pack200 Tools and API

#Java 13 Features:
– Text Blocks (Preview)
– Switch Expressions Enhancements (Preview)
– Reimplement the Legacy Socket API
– Dynamic CDS Archive
– ZGC: Uncommit Unused Memory
– FileSystems.newFileSystem() Method
– DOM and SAX Factories with Namespace Support

# Java 12 Features:
- Collectors.teeing() in Stream API
- String API Changes
- Files.mismatch(Path, Path)
- Compact Number Formatting
- Support for Unicode 11
- Switch Expressions (Preview)

#Java 11 Features:
- HTTP Client API
- Launch Single-File Programs Without Compilation
- String API Changes
- Collection.toArray(IntFunction)
- Files.readString() and Files.writeString()
- Optional.isEmpty()

Java 10 Features:
- Local Variable Type Inference
- Time-Based Release Versioning
- Garbage-Collector Interface
- Parallel Full GC for G1
- Heap Allocation on Alternative Memory Devices
- Consolidate the JDK Forest into a Single Repository

#Java 9 Features:
- Java platform module system
- Interface Private Methods
- HTTP 2 Client
- JShell
- Platform and JVM Logging
- Process API Updates
- Collection API Updates
- Improvements in Stream API
- Multi-release JAR Files
- @Deprecated Tag Changes
- Stack Walking

Java 8 Features:
- Lambda expression
- Stream API
- Functional interface
- Default and static methods
- Optional class
- Nashorn – JavaScript runtime engine
- Annotation on Java Types
- Unsigned Integer Arithmetic
- Repeating annotations
- New Date and Time API











































=================================================
##spring | spring boot | Spring Framework                                         
================================================= 
https://github.com/eazybytes/spring


Spring Shared Libraries Are Not Scanned by Default:
 When you move ApplicationFilter to a library, it will no longer be scanned unless you:

Explicitly include its package in @ComponentScan (not ideal for reusable libraries).
Use Spring's @Bean registration in an @Configuration or @AutoConfiguration class.



When @Component Alone is Enough:
	If you still want to rely solely on @Component, you need to ensure that Spring can scan the library package. For example:
	@SpringBootApplication
	@ComponentScan(basePackages = {"com.example.logging", "your.application.package"})
	public class YourApplication {
	}







#  SPRING SOAP SERVICE                                          
================================================= 
https://medium.com/@extio/developing-soap-web-services-with-spring-boot-a-comprehensive-guide-1d4f89bc3127


http://localhost:8080/user-soap-service/user.wsdl
http://localhost:8080/imranmadbar/ws/calculatorDemo.wsdl





Create Soap Service:
-------------------------------------
Setp1: Define Request Response xml 
setp2: Create .xsd file for validateion Request/response xml file
Step3: For generate Java Pojo class for req/response from as .xsd file add JAXB library in pom file



Simple Soap Request:
--------------------------------------

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
xmlns:cal="http://imranmadbar.com/types/calculator">
	<soapenv:Header/>
	<soapenv:Body>
		<cal:SubtractionInput>
			<cal:number1>10</cal:number1>
			<cal:number2>4</cal:number2>
		</cal:SubtractionInput>
	</soapenv:Body>
</soapenv:Envelope>

<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:inh="http://com.imranmadbr/">
   <soapenv:Header/>
   <soapenv:Body>
      <inh:opManager>
         <!--Optional:-->
         <version>2.0</version>
         <service>xxx</service>
         <method>xxx</method>
         <param>xxxxxx</param>
         <numberofparam>1</numberofparam>
         <userid>xxxxxxx</userid>
         <password>xxxxx</password>
         <failclause>xxxx</failclause>
      </inh:opManager>
   </soapenv:Body>
</soapenv:Envelope>



<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:us="http://imranmadbar.com/spring-boot-soap-service">
    <soapenv:Header/>
    <soapenv:Body>
        <us:getUserRequest>
            <us:name>imran</us:name>
        </us:getUserRequest>
    </soapenv:Body>
</soapenv:Envelope>
		
Simple Soap Response:
-------------------------------------

<SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
  <SOAP-ENV:Header/>
  <SOAP-ENV:Body>
	  <ns2:output xmlns:ns2="http://imranmadbar.com/types/calculator">
		  <ns2:result>6</ns2:result>
	  </ns2:output>
  </SOAP-ENV:Body>
</SOAP-ENV:Envelope>







#Cloud | Gateway                                      
=================================================

Ratelimiting
-------------------------------------------------
  # Redis connection details
  host: localhost  # Replace with your Redis server hostname/IP
  port: 6379     # Replace with your Redis server port

  # Define rate limit configurations (example for both users and clients)
  user-rate-limit:
    replenishRate: 10   # Replenish 10 tokens per second
    burstCapacity: 20  # Allow a burst of 20 requests initially
  client-rate-limit:
    replenishRate: 5    # Replenish 5 tokens per second (different limit for clients)
    burstCapacity: 15  # Allow a burst of 15 requests initially (different limit for clients)


 routes:
  - id: user-service  # Route for user requests
    uri: lb://user-service  # Replace with your user service URI in Eureka
    predicates:
      - Path=/user/**  # Match requests starting with /user/
    filters:
      - RequestRateLimiter  # Apply rate limiting filter
        keyResolver: userKeyResolver  # Define custom key resolver (explained later)

  - id: customer-info  # Route for customer information requests
    uri: lb://customer-info-service  # Replace with your customer service URI
    predicates:
      - Path=/customer/**  # Match requests starting with /customer/
    filters:
      - RequestRateLimiter  # Apply rate limiting filter
        keyResolver: clientKeyResolver  # Define custom key resolver (explained later)


Java
@Component
public class UserKeyResolver implements RequestRateLimiter.KeyResolver {

  @Override
  public String resolve(ServerWebExchange exchange) {
    // Extract username from Keycloak token (assuming access token is present)
    String username = extractUsernameFromToken(exchange.getRequest().getHeaders().get("Authorization"));
    return "user:" + username;
  }

  // Implement logic to extract username from Keycloak token 
  private String extractUsernameFromToken(List<String> authorization) {
    // ... (your logic to parse token and extract username)
  }
}





spring-cloud gateway filter
--------------------------------



import com.google.common.collect.ImmutableList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;


@Component
public class RequestIntercept implements WebFilter, Ordered {
    private static Logger LOGGER = LoggerFactory.getLogger(RequestIntercept.class);
    public static final ImmutableList<String> HEADERS_LIST =
            ImmutableList.of(
                    "Host",
                    "User-Agent" );
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        StringBuilder logData = new StringBuilder();
        HEADERS_LIST.forEach((hedName)-> {
            logData.append(hedName+": "+exchange.getRequest().getHeaders().getFirst(hedName)+" ");
        });
        LOGGER.info(logData.toString());
        return chain.filter(exchange);
    }
    @Override
    public int getOrder() {
        return 1;
    }

}




=================================================
#FeignClient
=================================================


import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

import feign.Response;

@FeignClient(name = "exampleClient", url = "https://api.example.com")
public interface ExampleClient {

    @GetMapping("/resource")
    Response getResource();
}


================================================


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import feign.Response;
import feign.Util;

@Service
public class ExampleService {

    @Autowired
    private ExampleClient exampleClient;

    public String fetchDataFromExternalService() {
        Response response = exampleClient.getResource();
        try {
            if (response != null && response.body() != null) {
                // Consume the response body
                String responseBody = Util.toString(response.body().asReader());
                
                // Do something with the response body
                return responseBody;
            } else {
                // Handle the case where response or response body is null
                return "Error: Response or response body is null";
            }
        } finally {
            // Close the response to release the connection
            if (response != null) {
                response.close();
            }
        }
    }
}


===============


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import feign.Response;
import feign.Util;

@Service
public class ExampleService {

    @Autowired
    private ExampleClient exampleClient;

    public String fetchDataFromExternalService() {
        try (Response response = exampleClient.getResource()) {
            if (response != null && response.body() != null) {
                // Consume the response body
                String responseBody = Util.toString(response.body().asReader());
                
                // Do something with the response body
                return responseBody;
            } else {
                // Handle the case where response or response body is null
                return "Error: Response or response body is null";
            }
        } catch (IOException e) {
            // Handle IOException if any
            e.printStackTrace();
            return "Error: IOException occurred";
        }
    }
}

===================================


import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@SpringBootApplication
@Slf4j
public class FallbackApplication {

    public static void main(String[] args) {
        SpringApplication.run(FallbackApplication.class, args);
    }

    @Autowired
    private FeignClientTest feignClientTest;

    @Bean
    public ApplicationRunner test() {
        return args -> {
            String fromFakeUrl = feignClientTest.getFromFakeUrl();
            log.info("{}", fromFakeUrl);
        };
    }

    @FeignClient(name = "feignClientTest", url = "invalid.url", fallback = FallbackTest.class)
    public interface FeignClientTest {

        @RequestMapping(method = RequestMethod.GET, value = "/fake/url")
        String getFromFakeUrl();
    }

    @Component
    public class FallbackTest implements FeignClientTest {

        @Override
        public String getFromFakeUrl() {
            log.debug("Fallback occurred for getFromFakeUrl");
            return "Fallback";
        }
    }
}










DataJqp custom sequenceName
========================================

CREATE SEQUENCE custom_sequence START WITH 1 INCREMENT BY 1;



import javax.persistence.*;

@Entity
@Table(name = "your_entity_table")
public class YourEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "custom_sequence_generator")
    @SequenceGenerator(name = "custom_sequence_generator", sequenceName = "custom_sequence", allocationSize = 1)
    private Long id;

    // Other entity attributes and methods...
}













spring-doc:
=================================================
Spring Framework is a powerful, open-source framework for building Java-based applications. 

Key Features of Spring Framework:
	Dependency Injection (DI): Manages dependencies automatically to ensure loose coupling.
	AOP (Aspect-Oriented Programming): Separates cross-cutting concerns like logging and security.
	Transaction Management: Handles transactions declaratively without boilerplate code.
	Spring MVC: Simplifies web development with the Model-View-Controller pattern.
	Spring Boot: Speeds up setup with embedded servers and minimal configuration.
	Data Access: Integrates with JDBC, JPA, Hibernate, and NoSQL databases.
	Security: Offers authentication and authorization with Spring Security.
	Spring Cloud: Provides tools for microservices, including service discovery and API gateways.


Spring to build hybrid desktop applications where backend logic (e.g., data access, service management) is 
handled by Spring, and the frontend is built with JavaFX or Swing.



Spring Boot
---------------------------------------
Spring Boot builds on Spring Framework to provide a faster, easier way to develop applications with minimal setup.

Spring Boot simplifies Java application development by providing auto-configuration, 
embedded servers, and production-ready tools to accelerate the process.


Key Features of Spring Boot
	Auto-Configuration:
		Automatically configures beans and settings based on project dependencies.
		Reduces the need for manual configuration.

	Starter Dependencies:
		Pre-built starters simplify dependency management (e.g., spring-boot-starter-web).
		Include all required libraries with minimal setup.

	Embedded Servers:
		Comes with embedded servers like Tomcat, Jetty, or Undertow.
		Allows running applications without external server deployment.

	Production-Ready Features:
		Provides health checks, metrics, and logging via Spring Boot Actuator.
		Simplifies monitoring and maintenance.




Main Projects in the Spring Ecosystem:
	Spring Framework – Core framework for DI and AOP.
	Spring Boot – Simplifies app setup with auto-configuration and embedded servers.
	Spring Cloud – Tools for building microservices and cloud-native apps.
	Spring Security – Authentication and authorization support (OAuth2, JWT).
	Spring Data – Simplifies database access for SQL and NoSQL.
	Spring Batch – Handles batch processing and ETL jobs.
	Spring Integration – Supports enterprise application integration.



Annotations in Spring Boot
----------------------------------------
In Spring Boot, an annotation is a special form of metadata that provides information about how the 
framework should handle classes, methods, or fields at runtime.


Spring Boot annotations with brief descriptions:

@SpringBootApplication
Marks the main class of a Spring Boot application and combines @Configuration, @EnableAutoConfiguration, and @ComponentScan.

@RestController
Combines @Controller and @ResponseBody to create RESTful web services.

@GetMapping / @PostMapping / @PutMapping / @DeleteMapping
Used to map HTTP methods (GET, POST, PUT, DELETE) to controller methods.

@RequestMapping
General-purpose mapping annotation for defining paths and HTTP methods for controllers.

@Autowired
Injects dependencies automatically where required.

@Component
Marks a class as a Spring-managed bean. Used for general components.

@Service
Marks a class as a service, a specialized @Component.
From a functional perspective, @Component and @Service are identical—both register the class as a 
Spring-managed bean in the application context.

@Repository
Indicates that a class is responsible for data access, typically interacting with a database.
@Repository not only marks a class as a Spring bean, but also enables exception(SQLException) translation to convert 
database exceptions into Spring’s DataAccessException.



@Entity
Marks a class as a JPA entity to represent a table in a database.

@Transactional
Used to manage transactions at the method or class level.

@Configuration
Marks a class to define beans and configurations.
It tells Spring to scan the class for @Bean methods and register those beans in the application context.

@Value
Injects values from application properties or environment variables into fields.

@PathVariable
Extracts values from URI path parameters.

@RequestParam
Extracts query parameters from HTTP requests.

@RequestBody
Maps the request body to a Java object.

@ResponseBody
Converts Java objects to HTTP responses, typically in JSON or XML.

@Bean
Defines a Spring-managed bean in a @Configuration class.
Used to manually create and configure beans (e.g., for third-party libraries or when complex 
logic is needed for initialization).


@EnableAsync
Enables asynchronous method execution.

@EnableScheduling
Activates scheduled tasks in the application.

@CrossOrigin
Enables cross-origin resource sharing (CORS) for a controller or method.



@Bean crate imp**:
----------------------------
Best Practice: Always define @Bean methods inside a @Configuration class to ensure proper singleton handling and 
lifecycle management.
If you place @Bean outside @Configuration (e.g., in a @Component or @Service), be aware that multiple instances may
 be created, which could lead to unexpected behavior.



Scope and lifecycle behavior of @Configuration, @Component, @Service, and @Repository.
-------------------------------------------------------------------------------------
@Configuration:

Always treated as a singleton.
Uses CGLIB proxying to ensure beans are shared properly.
@Component, @Service, @Repository:
Singleton by default.
Can be configured with other scopes like prototype, request, or session depending on the need.


@Controller
Purpose:
Marks a class as a Spring MVC controller responsible for handling HTTP requests and returning views (e.g., HTML).
Scope:
Singleton by default (like @Component).


@RestController
Purpose:
Specialized version of @Controller that combines @Controller + @ResponseBody.
It is used to handle RESTful APIs by returning JSON/XML directly instead of rendering views.
Scope:
Singleton by default (like other Spring-managed beans).




@Entity
Purpose:
	Marks a Java class as a JPA entity, meaning it represents a table in a relational database.
	Each instance of this class corresponds to a row in the database.
Scope:
	Not a Spring-managed bean by default.
	Instances are managed by JPA/Hibernate, not the Spring container.




@Transactional
==============================================
The @Transactional annotation in Spring Boot is used to manage transactions. 
It ensures that a group of operations (like multiple database queries) are executed within a transaction 
boundary — either all of them succeed or all of them fail (rollback).


@Transactional works at both method level and class level, and the differences between them.


1. @Transactional at Method Level
	When applied at the method level, the transaction applies only to that specific method.

2. @Transactional at Class Level
	When applied at the class level, all public methods of the class will be wrapped in a transaction by default.
	Private, protected, or package-private methods within the class will not be transactional unless explicitly marked.


Important Considerations using @Transactional:
	Proxy Mechanism in Spring:
		Spring uses AOP proxies to manage transactions.
		If you call a method within the same class, it won’t trigger the transactional behavior unless it 
		is invoked from an external caller (because the proxy won't intercept internal calls).

	Rollback Behavior:
		By default, only unchecked exceptions (RuntimeException) cause a rollback.
		You can customize the rollback behavior:
			@Transactional(rollbackFor = Exception.class)
			public void someMethod() {
				// This will rollback even for checked exceptions.
			}



Important Rules for Rollback:
---------------------------------------------
Unchecked Exceptions (RuntimeExceptions) Cause Rollback:
	By default, only unchecked exceptions (like RuntimeException or its subclasses) will trigger a rollback.
	If someDatabaseCall() throws a checked exception (like IOException), the transaction will not roll back 
	unless explicitly configured.

Solution:
@Transactional(rollbackFor = Exception.class)
public void updateEmployeeInfo(Employee employee) {
    employeeRepository.save(employee);
    anotherService.someDatabaseCall();  // Even if this throws a checked exception, rollback will occur.
}


@Entity read only model
----------------------------------
@Entity
@Table(name = "your_view_name") // Name of your database view
@Immutable // Indicate that this entity is read-only

@Immutable Annotation: This tells Hibernate that this entity is not intended to be modified. 
While it doesn't enforce read-only behavior on the database level, it helps in signaling your intent, and 
Hibernate may optimize access accordingly.

@Transactional(readOnly = true): This annotation specifies that the method is read-only, which can improve performance
 by avoiding unnecessary flushing of the persistence context.



with out readOnly
	Performance:
	There may be additional overhead due to state management, including dirty checking and flushing changes to the database.

With-Read only:
	Performance:
	Can provide performance benefits as Hibernate may skip certain operations, like dirty checking and flushing the 
	persistence context.
	Reduces overhead in managing the state of the entity.








=================================================
#batch | spring batch processing
=================================================
Spring Batch is a spring framework module for execution of batch job. 



Database required:
	In Spring Batch, a database (either in-memory or a real one) is not strictly required:

	Database-backed: Required for long-running jobs or when tracking job instances, especially in production environments.
	A database is optional for basic batch jobs but becomes essential if you want robust job tracking, 
	restartability, and chunk processing with checkpointing.



Explanation of Components:
	Job: Defines the batch job named inMemoryJob.
	Step: Defines a single step named inMemoryStep with a chunk size of 2 (processes two items at a time).
	Tasklet: A Tasklet in Spring Batch is a simple interface with a single execute method, 
			 which allows you to define a single task or operation without separating it into reader, 
			processor, and writer components.
	ItemReader: Reads a list of names in memory.
	ItemProcessor: Converts each name to uppercase.
	ItemWriter: Writes each processed name to the console.


Separation of Concerns (Best Practice)
	ItemReader: Handles only reading data (input). In our example, it reads names from an in-memory list.
	ItemProcessor: Isolates the logic for processing (transformation), converting names to uppercase.
	ItemWriter: Manages writing the output, here printing names to the console.

also  Chunk Processing and Error Handling
Why This Matters: If your job reads 1,000 records and you set chunk(100), then even if 1 item in a chunk fails, 
the others can be processed without re-running the entire job.


If your steps only involve reading and processing data without complex single-use tasks, 
you can avoid Tasklets and stick to ItemReader, ItemProcessor, and ItemWriter configurations.



Alternative: Using Multiple Steps Without Tasklets:
	You can create a Job using only Steps, as you showed in your example. 
	This approach is perfectly valid in Spring Batch and doesn’t always require Tasklets. Each Step can independently 
	execute its logic, either using Tasklets or by defining the logic with ItemReader, ItemProcessor, and ItemWriter components.


Example Without Tasklets and R/P/W:
	@Bean
	public Job secondJob() {
		return new JobBuilder("MySecondJob", jobRepository)
				.incrementer(new RunIdIncrementer())
				.start(myJobInitStep())   // Step 1
				.next(myJobMainStep())    // Step 2
				.next(myJobFinalStep())   // Step 3
				.build();
	}

Example Without Tasklets:
	@Bean
	public Job exampleJob(JobRepository jobRepository, StepBuilderFactory stepBuilderFactory) {
		return new JobBuilder("ExampleJob", jobRepository)
				.incrementer(new RunIdIncrementer())
				.start(stepBuilderFactory.get("step1")
						.<String, String>chunk(10)
						.reader(myReader())
						.processor(myProcessor())
						.writer(myWriter())
						.build())
				.next(stepBuilderFactory.get("step2")
						.<String, String>chunk(10)
						.reader(anotherReader())
						.processor(anotherProcessor())
						.writer(anotherWriter())
						.build())
				.build();
	}








=================================================
#scheduler | spring schecdular
=================================================
Spring Boot Task Scheduling allows you to run tasks at specific intervals or times in a simple, 
declarative way. It’s commonly used for scheduled tasks like cleaning up data, sending reminders, or 
updating information periodically.


To enable it, you annotate your Spring Boot application with @EnableScheduling, and then use @Scheduled on methods 
to specify the schedule. 

You can set schedules using:
	Fixed delay: Run a task with a delay after the previous execution finishes.
	Fixed rate: Run a task at regular intervals, regardless of how long each task takes.
	Cron expression: Run a task based on cron-like expressions, allowing for complex scheduling.


Example1:
	@EnableScheduling
	@SpringBootApplication
	public class MyApplication {
		public static void main(String[] args) {
			SpringApplication.run(MyApplication.class, args);
		}

		@Scheduled(fixedRate = 5000) // runs every 5 seconds
		public void scheduledTask() {
			System.out.println("Task executed at " + System.currentTimeMillis());
		}
	}



@Async approach
	To avoid blocking the execution of task1() due to the potentially long-running task2(), 
	you can configure them to run in separate threads. 
	You can achieve this by setting the @Async annotation on the methods. 


import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class MyScheduledTasks {
    @Scheduled(cron = "*/1 * * * * *") // Execute every 1 second
    @Async // Execute in a separate thread
    public void task1() {
        // Task logic goes here
        System.out.println("Task 1 executed.");
    }

    @Scheduled(cron = "*/5 * * * * *") // Execute every 5 seconds
    @Async // Execute in a separate thread
    public void task2() {
        // Task logic goes here
        System.out.println("Task 2 executed.");
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            // Handle interrupted exception
            e.printStackTrace();
        }
    }
}



A Alternative or @Scheduled we can use custome:Custom Configuration of ThreadPoolTaskExecutor:

@Async vs ThreadPoolTaskExecutor:
------------------------------------------
@Async:
	@Async Annotation: Best suited for simple scenarios where quick setup and minimal configuration are sufficient. 
	However, careful attention is needed to avoid potential memory leaks due to default Executor settings.

ThreadPoolTaskExecutor:
	Custom Configuration of ThreadPoolTaskExecutor: Provides more control and flexibility, making it suitable for 
	applications with specific resource management requirements. Although it requires more configuration overhead, 
	it offers better resource utilization and scalability in the long run.













Overall Spring Boot Architecture
==============================================
	Tomcat:
	Acts as the web server and servlet container, managing incoming HTTP requests and routing them to the appropriate Spring components.

	Spring Framework:
	Manages the Java beans, their lifecycle, and dependencies. It operates within the JVM, allowing for efficient memory and resource management.

	JVM:
	Provides the runtime environment for Java applications, handling memory allocation, garbage collection, and thread management.





How Singleton Beans Handle Multiple Requests
----------------------------------------------------------------------------------
Singleton Beans:
	Even though controllers and services are singletons, Spring handles concurrent requests by creating a new thread for each request.
	Each request gets its own stack space to store local variables, ensuring thread safety.

Local Variables and Method Parameters:
	These are inherently thread-safe because they are isolated to each request’s thread.



Scenario:
	Two users, User A and User B, request employee info for ID 1 and ID 2 simultaneously.
	Flow:
		Spring assigns a separate thread for each request.
		getEmployeeInfo(id) method is called with different IDs in separate threads.
		Each request gets its own local variables (id and employee).
		No data is shared between requests, ensuring thread safety.

Spring’s built-in thread-per-request model ensures concurrent requests are handled properly without data conflicts.




@Scope("session") // Each user gets their own instance:
----------------------------------------------
Each user will have their own instance of UserSession, allowing them to set and get their username without affecting other users.
This ensures data isolation and avoids concurrency issues.



How to handel Concurrent requst 
-------------------------------------
Spring Boot creates a new thread for each incoming request, and all processing for that request (controller, service, repository) occurs within that single thread.
This architecture ensures that each request is isolated and that operations performed in one thread do not affect another thread's operations.
For any shared data or state, be cautious and use appropriate scopes (like request or session) to ensure thread safety and data isolation.



Spring Boot application, the creation, management, memory allocation, and CPU usage of threads are primarily handled by the underlying 
web server (like Tomcat, Jetty, or Undertow) and the Java Thread Pool. 


Memory Allocation:
	Each thread consumes a certain amount of memory for its stack (used for method calls and local variables).
	The JVM allocates memory for each thread when it is created, including space for its stack and any other data structures required for thread management.

CPU Usage:
	The operating system (OS) scheduler manages the allocation of CPU resources among threads.
	Each thread will be scheduled by the OS based on priority and availability, allowing it to run when CPU resources are available.



Configuring Thread Limits:
	Web servers have default configurations that limit the number of threads. You may need to adjust these based on your application’s workload.
Threads are created by the web server from a thread pool to handle incoming requests.
Memory allocation and CPU usage are managed by the JVM and the operating system.
The maximum number of threads is determined by server configuration and system resources, and there are inherent limitations based on JVM and OS capabilities.
Proper tuning and monitoring are essential to optimize thread usage in a Spring Boot application.





Spring Bean Scope
==========================================
What is Bean Scope?
Bean scope defines the lifecycle and visibility of a bean within the Spring container. 
It determines how many instances of a bean should be created and how long they should be available. 


Bean Scopes:
	Singleton Scope:In this scope, only one instance of the bean is created for the entire application.
	Prototype: A new instance of the bean is created each time it's requested.   
	Request: A new instance of the bean is created for each HTTP request.   
	Session: A new instance of the bean is created for each HTTP session.   
	Application: A single instance of the bean is created per web application runtime.
	WebSocket: A new instance of the bean is created for each WebSocket session.   


All Spring beans are Singleton by default.
Beans with Non-Singleton Scope Without Explicit Developer Specification:
-----------------------------------------------
Request Scope (@RequestScope):
@ControllerAdvice
Lifecycle: A new instance is created for every HTTP request.
Example:
	@RestController
	public class MyController {
		@Autowired
		private HttpServletRequest request; // This is request-scoped
	}


Session Scope (@SessionScope):
Lifecycle: A new instance is created for each HTTP session.
Example:
@RestController
public class MyController {
    @Autowired
    private HttpSession session; // This is session-scoped
}


Application Scope:
Scenario: Spring components like ServletContext beans are bound to the Application scope automatically.
Lifecycle: These beans last for the lifetime of the web application.
Example:
@RestController
public class MyController {
    @Autowired
    private ServletContext servletContext; // Application-scoped
}

Prototype Scope with Proxies:
Example:
@Service
@Scope("prototype")
public class PrototypeService {
    public void doSomething() {
        System.out.println("Prototype instance");
    }
}


Specialized Spring Beans with Non-Singleton Scopes:
@RequestMapping and @RestController Parameters
Parameters like @RequestParam or @PathVariable in controller methods are request-scoped by default.
Example:
	@GetMapping("/greet")
	public String greet(@RequestParam String name) {
		return "Hello " + name; // 'name' is request-scoped
	}


@Configuration:
Application-level scope: This annotation marks a class as a Spring configuration class.
Beans defined within this class are typically singletons, meaning a single instance is created and shared throughout the application.
	@Configuration
	public class MySecAddpter extends WebSecurityConfigurerAdapter {
		// Custom configurations
	}

Most beans like WebSecurityConfigurerAdapter, WebMvcConfigurer, and security handlers (BCryptPasswordEncoder, 
CustomAuthenticationFailureHandler, CustomAccessDeniedHandler) are Singleton by default, 
as they typically don't need to change across requests.
This means a single instance of each class is created and used throughout the entire application's lifecycle.


 Singleton vs Application Scope
 ------------------------------------
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+
| Aspect                | Singleton Scope                                       | Application Scope                                     |
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+
| Definition            | Creates one instance per Spring Application Context.  | Creates one instance per ServletContext (broader     |
|                       |                                                       | than Spring).                                         |
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+
| Managed By            | The Spring container (Spring Application Context).    | The web application context (ServletContext).        |
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+
| Use Case              | Used for Spring-managed beans, default for most       | Used in Java EE or hybrid environments where a bean  |
|                       | Spring applications.                                  | needs to align with the entire web application       |
|                       |                                                       | lifecycle.                                           |
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+
| Accessibility         | Accessible globally within the Spring Application     | Accessible globally across the entire web            |
|                       | Context.                                              | application (even outside Spring).                   |
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+
| Lifecycle             | Tied to the Spring Application Context lifecycle.     | Tied to the ServletContext lifecycle.                |
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+
| Default in Spring?    | Yes, it is the default scope for all Spring beans     | No, it must be explicitly defined using              |
|                       | unless explicitly changed.                            | `@Scope("application")`.                             |
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+
| Context Dependency    | Purely Spring-dependent, no need for ServletContext.  | Requires a ServletContext (broader than Spring).     |
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+
| How to Define         | Default, or explicitly via `@Scope("singleton")`.     | Explicitly defined using `@Scope("application")`.    |
+-----------------------+-------------------------------------------------------+-------------------------------------------------------+




ScopeSummary:
===========================================
+---------------------+---------------------------------------------+-----------+---------------------------------------------------------------+
| Scope               | Example Components                          | Explicit | Notes                                                          |
+---------------------+---------------------------------------------+-----------+---------------------------------------------------------------+
| Singleton (default) | @Controller, @Service, @Repository          | No        | Default for all Spring-managed beans unless explicitly changed|
+---------------------+---------------------------------------------+-----------+---------------------------------------------------------------+
| Request             | HttpServletRequest, @RequestMapping params  | No        | Automatically bound to the HTTP request lifecycle.            |
+---------------------+---------------------------------------------+-----------+---------------------------------------------------------------+
| Session             | HttpSession, @SessionAttributes             | No        | Automatically bound to the HTTP session lifecycle.            |
+---------------------+---------------------------------------------+-----------+---------------------------------------------------------------+
| Application         | ServletContext                              | No        | Automatically bound to the application context.               |
+---------------------+---------------------------------------------+-----------+---------------------------------------------------------------+
| Prototype           | Manual setup, but proxies may trigger this  | Yes       | New instance created per method call when injected into       |
|                     |                                             |           | singletons.                                                   |
+---------------------+---------------------------------------------+-----------+---------------------------------------------------------------+
| Lazy                | @Lazy annotation                            | Yes       | Not scope but defers initialization.                          |
+---------------------+---------------------------------------------+-----------+---------------------------------------------------------------+







A Http Request process: Responsibilities at Each Step (With JVM Status):
+----------------------------+---------------------------------------------------------------+-----------------------------------------------------------+
| Component                  | Responsibility                                                | JVM Status                                                |
+----------------------------+---------------------------------------------------------------+-----------------------------------------------------------+
| Client (Browser/Postman)   | Sends an HTTP GET request to the server.                      | N/A – Outside JVM                                         |
| Tomcat Server              | Receives the request and delegates to DispatcherServlet.      | Thread allocated from pool (Runnable).                    |
| DispatcherServlet (Spring) | Matches the request to the appropriate controller.  			 | Uses Spring context (Singleton beans) from heap.          |
| Controller                 | Handles the request and calls the service layer.    			 | Temporary HTTP request/response objects created.          |
| Service Layer              | Contains business logic and interacts with the repository.	 | Service bean reused, objects held in JVM heap.            |
| Repository (JPA)           | Converts method calls into SQL queries using JPA.    		 | JPA session creates short-lived query objects in heap.    |
| Hibernate                  | Translates between SQL and Java objects.           		     | Query cache checked if enabled; new entities stored.      |
| MySQL Database             | Executes the SQL query and returns the result set.  			 | JVM thread waits/block until query completes.             |
| Service Layer              | Receives the employee object from the repository.   			 | Employee object allocated in heap.                        |
| Controller                 | Sends the response back to the DispatcherServlet.   			 | JSON serialization creates short-lived objects.           |
| Tomcat Server              | Sends the final HTTP response back to the client.   			 | Thread terminated or returned to pool. GC collects temporary objects. |
+----------------------------+---------------------------------------------------------------+-----------------------------------------------------------+



Detailed Communication Flow: Tomcat → DispatcherServlet
-------------------------------------------------------------
1. HTTP Request Received by Tomcat:
   - Tomcat listens on a specific port (default: 8080) for incoming HTTP requests.
   - Each request is processed in a separate thread (from Tomcat's thread pool).

2. Request Handling in Tomcat:
   - Tomcat wraps the HTTP request into an HttpServletRequest object, which follows the Java Servlet API specification.

3. Dispatching to Spring's DispatcherServlet:
   - Tomcat identifies the target servlet (in this case, DispatcherServlet) by analyzing the URL mapping.
   - Spring Boot registers DispatcherServlet as the default servlet when the application starts.
   - Tomcat forwards the request to DispatcherServlet by invoking the service() method defined in the HttpServlet class.
   - Tomcat forwards requests to Spring's DispatcherServlet using Java Servlet API mechanisms.

4. DispatcherServlet Processes the Request:
   - DispatcherServlet inspects the request URL, selects the appropriate controller, and returns the response to Tomcat.

5. Tomcat Sends the Response Back:
   - After the controller processes the request, the response is returned to Tomcat.
   - Tomcat sends the final HTTP response back to the client (e.g., browser or API consumer).




DispatcherServlet registration is essential in both embedded and external Tomcat setups because it serves as the entry point for all HTTP requests in Spring.
In embedded Tomcat, registration is done automatically by Spring Boot using programmatic bean registration.
In external Tomcat, registration must be defined manually in web.xml or by extending SpringBootServletInitializer.
Whether embedded or external, Tomcat and Spring work together inside the JVM to route requests and process them properly.




How Tomcat Manages Multiple Applications (WAR Files)?
-----------------------------------------------------------
By default, Tomcat runs all applications on the same port (e.g., 8080). 
All applications run on the same port (default: 8080).
Each application is distinguished by its context path (like /app1, /app2).

Example:
	Place app1.war in /webapps/ → Available at http://localhost:8080/app1.
	Place app2.war in /webapps/ → Available at http://localhost:8080/app2.











=================================================
#Data Structures and Algorithms | java  
=================================================

https://github.com/rasmus4200/algorithms101

https://gale.udemy.com/course/learn-data-structures-algorithms-java/learn/lecture/29590934#overview
https://gale.udemy.com/course/complexity-analysis/
https://gale.udemy.com/course/java-data-structures-and-algorithms-masterclass/learn/lecture/24821130#overview
https://gale.udemy.com/course/data-structures-and-algorithms-bootcamp/learn/lecture/9486480#overview

https://gale.udemy.com/course/data-structures-and-algorithms-java/learn/lecture/28602150#overview




Data Structures and Algorithms:
	Data Structures and Algorithms (DSA) is a fundamental part of Computer Science that teaches you 
	how to think and solve complex problems systematically.
	Using the right data structure and algorithm makes your program run faster, especially when working with lots of data.


Then, you will learn more about complex data structures like trees and graphs, study advanced sorting and searching algorithms, 
explore concepts like time complexity, and space complexity.



In Computer Science there are two type DSA:
	1)Primitive Data Structures are basic data structures provided by programming languages to represent single values, 
	such as integers, floating-point numbers, characters, and booleans.

	2)Abstract Data Structures are higher-level data structures that are built using primitive data types and provide more 
	complex and specialized operations. Some common examples of abstract data structures include arrays, 
	linked lists, stacks, queues, trees, and graphs.



What are DA?
Data Structures is about how data can be stored in different structures.
Algorithms is about how to solve different problems, often by searching through and manipulating data structures.

What are Algorithms?
An algorithm is a set of step-by-step instructions to solve a given problem or achieve a specific goal.




Algorithm examples:
	Finding the fastest route in a GPS navigation system
	Navigating an airplane or a car (cruise control)
	Finding what users search for (search engine)
	Sorting, for example sorting movies by rating


By understanding DSA, you can:
	Decide which data structure or algorithm is best for a given situation.
	Make programs that run faster or use less memory.
	Understand how to approach complex problems and solve them in a systematic way.
For managing large amounts of data, such as in a social network or a search engine.
For scheduling tasks, to decide which task a computer should do first.
For planning routes, like in a GPS system to find the shortest path from A to B.
For optimizing processes, such as arranging tasks so they can be completed as quickly as possible.
For solving complex problems: From finding the best way to pack a truck to making a computer 'learn' from data.


Term	            Description
---------------------------------------
Algorithm			A set of step-by-step instructions to solve a specific problem.
Data Structure		A way of organizing data so it can be used efficiently. Common data structures include arrays, linked lists, and binary trees.
Time Complexity		A measure of the amount of time an algorithm takes to run, depending on the amount of data the algorithm is working on.
Space Complexity	A measure of the amount of memory an algorithm uses, depending on the amount of data the algorithm is working on.
Big O Notation		A mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. Used in this tutorial to describe the time complexity of an algorithm.
Recursion			A programming technique where a function calls itself.
Divide and Conquer	A method of solving complex problems by breaking them into smaller, more manageable sub-problems, solving the sub-problems, and combining the solutions. Recursion is often used when using this method in an algorithm.
Brute Force			A simple and straight forward way an algorithm can work by simply trying all possible solutions and then choosing the best one.






#Array
=================================================
Fixed size, can't grow.
Get and Set random specifice value is arrays unique feature.
	We can get and set any value any time in array.

ArrayList
-----------------
CollectionApi bhilt in top of array.
new apis, insert/remove, isEmpty
Handel resizing, and its DynamicArray.




#LinkList
=================================================
We can not access rendomly value from a linkList.
Link list pointing one to anohter node, last element pointing to null;

Super fast insert/delete, can grow incrementally



#StackQueue
=================================================
Stack: LIFO  
Queue: FILO



#HashTable
=================================================
Super fast



#Binary tree
=================================================
Depath and Breadth serch
Can search too first
Binary tree works with Order and recurisve call.








#PointerInJava
=================================================




#PointerInJava
=================================================




#PointerInJava
=================================================












































































































































































































































































f a variable pointing to other value, then previeous value will remove by GC.





#Recursive Programming
-------------------------------------------------
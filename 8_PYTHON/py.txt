#################################################
#                 PYTHON                        #
#################################################
=>where python
=>where pip

=>python --version
=>pip --version
=>pip list
=>pip show packageName

=>pip uninstall requests





=================================================
##Basic                                          
=================================================
TextFromImage:
import pytesseract
from PIL import Image

# Load the image
image_path = "/mnt/data/image.png"
image = Image.open(image_path)

# Extract text using Tesseract OCR
extracted_text = pytesseract.image_to_string(image)

# Show extracted text
extracted_text







##doc
=================================================
pip is the python dependency/package manager as maven/npm.
location to package manage: userHome/lib/pythonVerson/packageName
/lib/python2.7


pip (Package Installer for Python) is the default package manager for Python.
It allows you to install, upgrade, and manage Python libraries from the Python Package Index (PyPI).

Common pip commands:
    Install a package: pip install package_name
    Upgrade a package: pip install --upgrade package_name
    Uninstall a package: pip uninstall package_name
    List installed packages: pip list
    Check outdated packages: pip list --outdated
    Show package details: pip show package_name




=================================================
##LearnPython
=================================================


https://docs.python.org/3/tutorial/index.html

Python Programming Concepts 
Basic Syntax and Structure 
Object-Oriented Programming (OOP) 
Control Flow 
Working with Data 
Functions 
Advanced Concepts 
Data Structures & Algorithms 
Libraries and Frameworks 
Modules and Packages 
Testing and Debugging 
File Handling 
Version Control 
Error Handling 
Best Practices 


Details
------------------------------
Basic Syntax and Structure:
   Variables and Data Types
   Operators (arithmetic, comparison, logical, etc.)
   Comments and Docstrings
Control Flow:
   Conditional Statements (if, elif, else)
   Loops (for, while)
   Loop Control (break, continue, pass)
Functions:
   Defining and Calling Functions
   Arguments and Parameters
   Return Values
   Lambda Functions
   Scope (local, global)


Data Structures & Algorithm:
   Lists
   Tuples
   Dictionaries
   Sets
   List Comprehensions
   Dictionary Comprehensions
Modules and Packages:
   Importing Modules
   Standard Library Modules
   Installing and Using Third-Party Packages (pip)
File Handling:
      Reading and Writing Files
      Working with File Paths
      Time Complexity
      Space Complexity
      Sorting algorithms
      Linked list
      Stack
      Queue

Error Handling:
   Exceptions (try, except, finally)
   Raising Exceptions
   Custom Exceptions
Object-Oriented Programming (OOP):
   Classes and Objects
   Methods and Attributes
   Inheritance
   Polymorphism
   Encapsulation
Working with Data:
   Strings (manipulation and formatting)
   Regular Expressions
   Dates and Times

Advanced Concepts:
   Decorators
   Generators and Iterators
   Context Managers
   Metaclasses
Libraries and Frameworks:
   Common Libraries (e.g., NumPy, pandas, matplotlib)
   Web Development (Flask, Django)
   Web Scraping (BeautifulSoup, Selenium, Scrapy)
   Data Science and Machine Learning (scikit-learn, TensorFlow, PyTorch)
Testing and Debugging:
   Writing Tests (unittest, pytest)
   Debugging Tools and Techniques




##Datails:
=============================================

Python Indentation:
---------------------------------------------
if 5 > 2:
  print("Five is greater than two!")

print("Hello, World!")


Variable & Input/Output Function
Strings Basic Concept 
String Methods 
Data Types in Python
Python Operators (Part-1)

The number of spaces is up to you as a programmer, the most common use is four, but it has to be at least one.
if 5 > 2:
 print("Five is greater than two!") 
if 5 > 2:
   #This is a comment
   print("Hello, World!")

OR
"""
This is a comment
written in
more than just one line
"""
print("Hello, World!")


Variable & Input/Output Function
Strings Basic Concept 
String Methods 
Data Types in Python
Python Operators (Part-1)


Comment:
-----------------------------
   #This is a comment
   print("Hello, World!")

OR
"""
This is a comment
written in
more than just one line
"""
print("Hello, World!")


Variable & Input/Output Function
====================================
Variables do not need to be declared with any particular type, and can even change type 
after they have been set.

Example:
x = 4       # x is of type int
x = "Sally" # x is now of type str
print(x)


You can get the data type of a variable with the type() function.
x = 5
y = "John"
print(type(x))
print(type(y))



Python allows you to assign values to multiple variables in one line:
Make sure the number of variables matches the number of values, or else you will get an error.

x, y, z = "Orange", "Banana", "Cherry"
print(x)
print(y)
print(z)


If you have a collection of values in a list, tuple etc. 
Python allows you to extract the values into variables. This is called unpacking.

fruits = ["apple", "banana", "cherry"]
x, y, z = fruits
print(x)
print(y)
print(z)


In the print() function, you output multiple variables, separated by a comma:

x = "Python"
y = "is"
z = "awesome"
print(x, y, z)



Global Variables:
Variables that are created outside of a function (as in all of the examples in the previous pages) are 
known as global variables.

x = "awesome"
def myfunc():
  print("Python is " + x)
myfunc()



The global Keyword:
Normally, when you create a variable inside a function, that variable is local, 
and can only be used inside that function.
If you use the global keyword, the variable belongs to the global scope:

def myfunc():
  global x
  x = "fantastic"

myfunc()

print("Python is " + x)



PythonBuilt-in Data Types:
----------------------------------
In programming, data type is an important concept.

Variables can store data of different types, and different types can do different things.
In Python, the data type is set when you assign a value to a variable:
Python has the following data types built-in by default, in these categories:

Text Type:	        str
Numeric Types:	    int, float, complex
Sequence Types:	    list, tuple, range
Mapping Type:	    dict
Set Types:	        set, frozenset
Boolean Type:	    bool
Binary Types:	    bytes, bytearray, memoryview
None Type:	        NoneType


You can get the data type of any object by using the type() function:
x = 5
print(type(x))


Setting the Specific Data Type:
If you want to specify the data type, you can use the following constructor functions:
Example:	
    x = str("Hello World")	
    x = int(20)	
    x = float(20.5)



Python Casting:
Casting in python is therefore done using constructor functions:
x = int(1)   # x will be 1
y = int(2.8) # y will be 2
x = float(1)     # x will be 1.0
y = str(2)    # y will be '2'



Strings Basic Concept 
---------------------------
print("It's alright")
print("He is called 'Johnny'")
print('He is called "Johnny"')

Multiline Strings
a = """Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua."""
print(a)

Strings are Arrays:
a = "Hello, World!"
print(a[1])

Looping Through a String
for x in "banana":
  print(x)


Check String:
txt = "The best things in life are free!"
print("free" in txt)

txt = "The best things in life are free!"
if "free" in txt:
  print("Yes, 'free' is present.")

txt = "The best things in life are free!"
print("best" not in txt)


Slicing:
Get the characters from position 2 to position 5 (not included):
b = "Hello, World!"
print(b[2:5])

Slice From the Start
b = "Hello, World!"
print(b[:5])

Slice To the End
b = "Hello, World!"
print(b[2:])


Modify Strings:
----------------------
a = "Hello, World!"
print(a.upper())

a = "Hello, World!"
print(a.lower())

The replace() method replaces a string with another string:
a = "Hello, World!"
print(a.replace("H", "J"))

The split() method splits the string into substrings if it finds instances of the separator:
a = "Hello, World!"
print(a.split(",")) # returns ['Hello', ' World!']


String Concatenation
a = "Hello"
b = "World"
c = a + b
print(c)



Escape Character:
txt = "We are the so-called \"Vikings\" from the north."
print(txt) 


Python Operators:
-------------------
Python divides the operators in the following groups:
    Arithmetic operators
    Assignment operators
    Comparison operators
    Logical operators
    Identity operators
    Membership operators
    Bitwise operators


Python Collections (Arrays)
------------------------
There are four collection data types in the Python programming language:
    List is a collection which is ordered and changeable. Allows duplicate members.
    Tuple is a collection which is ordered and unchangeable. Allows duplicate members.
    Set is a collection which is unordered, unchangeable*, and unindexed. No duplicate members.
    Dictionary is a collection which is ordered** and changeable. No duplicate members.

Lists are used to store multiple items in a single variable.
Lists are one of 4 built-in data types in Python used to store collections of data, the other 3 are 
Tuple, Set, and Dictionary, all with different qualities and usage.





List Items:
    List items are ordered, changeable, and allow duplicate values.
    List items are indexed, the first item has index [0], the second item has index [1] etc.

thislist = ["apple", "banana", "cherry"]
print(thislist)

type()
<class 'list'>


thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]
thislist.sort()
print(thislist)


Join Two Lists
list1 = ["a", "b", "c"]
list2 = [1, 2, 3]
list3 = list1 + list2
print(list3)


Loop Through a List
--------------------------
thislist = ["apple", "banana", "cherry"]
for x in thislist:
  print(x)

thislist = ["apple", "banana", "cherry"]
for i in range(len(thislist)):
  print(thislist[i])


Using a While Loop:
thislist = ["apple", "banana", "cherry"]
i = 0
while i < len(thislist):
  print(thislist[i])
  i = i + 1


List Comprehension:
List comprehension offers a shorter syntax when you want to create a new list based on the values of an existing list.

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = [x for x in fruits if "a" in x]
print(newlist)


List Condition:
The condition is like a filter that only accepts the items that evaluate to True.

Only accept items that are not "apple":

fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = [x for x in fruits if x != "apple"]
print(newlist)


Iterable:
newlist = [x for x in range(10)]
print(newlist)


Expression:
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = [x.upper() for x in fruits]
print(newlist)


Python Tuples
==============================
Tuples are used to store multiple items in a single variable.
Tuple is one of 4 built-in data types in Python used to store collections of data, the other 3 are List, Set, and Dictionary, 
all with different qualities and usage.
A tuple is a collection which is ordered and unchangeable.
Tuples are written with round brackets.

Example:
tuple1 = ("apple", "banana", "cherry")
tuple2 = (1, 5, 7, 9, 3)
tuple3 = (True, False, False)

type()
<class 'tuple'>

Access Tuple Items:
thistuple = ("apple", "banana", "cherry")
print(thistuple[1])


thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(thistuple[:4])

thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(thistuple[2:])


Add Items
Since tuples are immutable, they do not have a built-in append() method, but there are other ways to add items to a tuple.
Example
Convert the tuple into a list, add "orange", and convert it back into a tuple:

thistuple = ("apple", "banana", "cherry")
y = list(thistuple)
y.append("orange")
thistuple = tuple(y)




Update:
x = ("apple", "banana", "cherry")
y = list(x)
y[1] = "kiwi"
x = tuple(y)

print(x)



packing a Tuple:
When we create a tuple, we normally assign values to it. This is called "packing" a tuple:
fruits = ("apple", "banana", "cherry")
print(fruits)


Unpacking a tuple:
But, in Python, we are also allowed to extract the values back into variables. This is called "unpacking":
Example
fruits = ("apple", "banana", "cherry")
(green, yellow, red) = fruits
print(green)
print(yellow)
print(red)


Loop Through a Tuple:
thistuple = ("apple", "banana", "cherry")
for x in thistuple:
  print(x)


Join two tuples:
tuple1 = ("a", "b" , "c")
tuple2 = (1, 2, 3)
tuple3 = tuple1 + tuple2
print(tuple3)


Python Sets:
========================
A set is a collection which is unordered, unchangeable*, and unindexed.
Once a set is created, you cannot change its items, but you can add new items.
Duplicate values will be ignored:

thisset = {"apple", "banana", "cherry", "apple"}
print(thisset)


thisset = {"apple", "banana", "cherry"}
for x in thisset:
  print(x)

Check:
thisset = {"apple", "banana", "cherry"}
print("banana" in thisset)



Python Dictionaries:
-----------------------------------
Dictionaries are used to store data values in key:value pairs.
Dictionaries are written with curly brackets, and have keys and values:
A dictionary is a collection which is ordered*, changeable and do not allow duplicates.
As of Python version 3.7, dictionaries are ordered. In Python 3.6 and earlier, dictionaries are unordered.

thisdict =	{
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(thisdict)


type()
<class 'dict'>

Dictionary Items:
Dictionary items are ordered, changeable, and do not allow duplicates.
Dictionary items are presented in key:value pairs, and can be referred to by using the key name.
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(thisdict["brand"])


Duplicate values will overwrite existing values:
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964,
  "year": 2020
}
print(thisdict)


Adding Items
Adding an item to the dictionary is done by using a new index key and assigning a value to it:
Example:
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict["color"] = "red"
print(thisdict)

Remove:
The pop() method removes the item with the specified key name:
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.pop("model")
print(thisdict)



Conditional statement
-----------------------------

a = 200
b = 33
if b > a:
  print("b is greater than a")
else:
  print("b is not greater than a")



Short Hand If:
a = 200
b = 33
if a > b: print("a is greater than b")

a = 2
b = 330
print("A") if a > b else print("B")


One line if else statement, with 3 conditions:
a = 330
b = 330
print("A") if a > b else print("=") if a == b else print("B")



Python For Loops
-----------------------
fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)

fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
  if x == "banana":
    break


Print all numbers from 0 to 5, and print a message when the loop has ended:
for x in range(6):
  print(x)
else:
  print("Finally finished!")


Nested Loops:
adj = ["red", "big", "tasty"]
fruits = ["apple", "banana", "cherry"]
for x in adj:
  for y in fruits:
    print(x, y)



The while Loop
--------------------
i = 1
while i < 6:
  print(i)
  i += 1


i = 1
while i < 6:
  print(i)
  if i == 3:
    break
  i += 1


Python Functions:
=====================
A function is a block of code which only runs when it is called.
You can pass data, known as parameters, into a function.
In Python a function is defined using the def keyword:
A function can return data as a result.

def my_function():
  print("Hello from a function")
my_function()



Arguments:
Information can be passed into functions as arguments.
Arguments are specified after the function name, inside the parentheses. You can add as many arguments as you want, just separate them with a comma.
The following example has a function with one argument (fname). When the function is called, we pass along a first name, which is used inside the function to print the full name:

def my_function(fname):
  print(fname + " Refsnes")

my_function("Emil")
my_function("Tobias")
my_function("Linus")





Passing a List as an Argument
You can send any data types of argument to a function (string, number, list, dictionary etc.), and it will be treated as the same data type inside the function.
E.g. if you send a List as an argument, it will still be a List when it reaches the function:
def my_function(food):
  for x in food:
    print(x)

fruits = ["apple", "banana", "cherry"]

my_function(fruits)



Arbitrary Arguments, *args
If you do not know how many arguments that will be passed into your function, add a * before the parameter name in the function definition.
def my_function(*kids):
  print("The youngest child is " + kids[2])
my_function("Emil", "Tobias", "Linus")


Python Lambda
=======================
A lambda function is a small anonymous function.
A lambda function can take any number of arguments, but can only have one expression.
The expression is executed and the result is returned:

x = lambda a: a + 10
print(x(5))


Summarize argument a, b, and c and return the result:
x = lambda a, b, c : a + b + c
print(x(5, 6, 2))



Python Arrays
========================
Python does not have built-in support for Arrays, but Python Lists can be used instead.
This page shows you how to use LISTS as ARRAYS, however, to work with arrays in Python you 
will have to import a library, like the NumPy library.

cars = ["Ford", "Volvo", "BMW"]
print(cars)




Python Classes and Objects
==============================
class MyClass:
  x = 5
print(MyClass)

Object:
class MyClass:
  x = 5

p1 = MyClass()
print(p1.x)




The __init__() Function:
----------------------------
The examples above are classes and objects in their simplest form, and are not really useful in real life applications.
To understand the meaning of classes we have to understand the built-in __init__() function.
All classes have a function called __init__(), which is always executed when the class is being initiated.
Use the __init__() function to assign values to object properties, or other operations that are necessary to do when the object is being created:


class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

p1 = Person("John", 36)

print(p1.name)
print(p1.age)




Object Methods
-------------------------
Objects can also contain methods. Methods in objects are functions that belong to the object.
Let us create a method in the Person class:

class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def myfunc(self):
    print("Hello my name is " + self.name)

p1 = Person("John", 36)
p1.myfunc()


The self Parameter:
The self parameter is a reference to the current instance of the class, and is used to access variables that belong to the class.
It does not have to be named self, you can call it whatever you like, but it has to be the first parameter of any function in the class:

class Person:
  def __init__(mysillyobject, name, age):
    mysillyobject.name = name
    mysillyobject.age = age

  def myfunc(abc):
    print("Hello my name is " + abc.name)

p1 = Person("John", 36)
p1.myfunc()



Modify Object Properties:
class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def myfunc(self):
    print("Hello my name is " + self.name)

p1 = Person("John", 36)

p1.age = 40
print(p1.age)



Delete Object Properties:
You can delete properties on objects by using the del keyword:

class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def myfunc(self):
    print("Hello my name is " + self.name)

p1 = Person("John", 36)
del p1.age
print(p1.age)



Delete Objects:
You can delete objects by using the del keyword:

class Person:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def myfunc(self):
    print("Hello my name is " + self.name)

p1 = Person("John", 36)
del p1
print(p1)


The pass Statement
class definitions cannot be empty, but if you for some reason have a class definition with no content, put in the pass statement to avoid getting an error.
class Person:
  pass



Python Inheritance
-------------------------
Inheritance allows us to define a class that inherits all the methods and properties from another class.
Parent class is the class being inherited from, also called base class.
Child class is the class that inherits from another class, also called derived class.


Create a Parent Class:
class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

#Use the Person class to create an object, and then execute the printname method:

x = Person("John", "Doe")
x.printname()


Create a Child Class:
Create a class named Student, which will inherit the properties and methods from the Person class:
 Use the pass keyword when you do not want to add any other properties or methods to the class.
class Student(Person):
  pass


complete:
class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

class Student(Person):
  pass

x = Student("Mike", "Olsen")
x.printname()



Add Methods:
-----------------------
class Person:
  def __init__(self, fname, lname):
    self.firstname = fname
    self.lastname = lname

  def printname(self):
    print(self.firstname, self.lastname)

class Student(Person):
  def __init__(self, fname, lname, year):
    super().__init__(fname, lname)
    self.graduationyear = year

  def welcome(self):
    print("Welcome", self.firstname, self.lastname, "to the class of", self.graduationyear)

x = Student("Mike", "Olsen", 2024)
x.welcome()




Python Modules:
=========================
Consider a module to be the same as a code library.
A file containing a set of functions you want to include in your application.

Create a Module:
To create a module just save the code you want in a file with the file extension .py:
Save this code in a file named mymodule.py

def greeting(name):
  print("Hello, " + name)


Use a Module
Now we can use the module we just created, by using the import statement:
Import the module named mymodule, and call the greeting function:

import mymodule
mymodule.greeting("Jonathan")


Variables in Module
The module can contain functions, as already described, but also variables of all types (arrays, dictionaries, objects etc):
Save this code in the file mymodule.py
person1 = {
  "name": "John",
  "age": 36,
  "country": "Norway"
}


Import the module named mymodule, and access the person1 dictionary:
import mymodule
a = mymodule.person1["age"]
print(a)


Re-naming a Module:
Create an alias for mymodule called mx:

import mymodule as mx
a = mx.person1["age"]
print(a)


Built-in Modules:
import platform
x = platform.system()
print(x)



Using the dir() Function:
There is a built-in function to list all the function names (or variable names) in a module. The dir() function:
import platform
x = dir(platform)
print(x)


Import From Module:
You can choose to import only parts from a module, by using the from keyword.

The module named mymodule has one function and one dictionary:

def greeting(name):
  print("Hello, " + name)

person1 = {
  "name": "John",
  "age": 36,
  "country": "Norway"
}

from mymodule import person1

print (person1["age"])




Python Datetime
=======================
import datetime

x = datetime.datetime.now()
print(x)



Python Math
=========================
x = min(5, 10, 25)
y = max(5, 10, 25)

print(x)
print(y)




Python JSON
=========================

import json

# some JSON:
x =  '{ "name":"John", "age":30, "city":"New York"}'

# parse x:
y = json.loads(x)

# the result is a Python dictionary:
print(y["age"])


Convert from Python to JSON:
import json

# a Python object (dict):
x = {
  "name": "John",
  "age": 30,
  "city": "New York"
}

# convert into JSON:
y = json.dumps(x)

# the result is a JSON string:
print(y)



Python RegEx
===========================
A RegEx, or Regular Expression, is a sequence of characters that forms a search pattern.

RegEx can be used to check if a string contains the specified search pattern.

RegEx Module
Python has a built-in package called re, which can be used to work with Regular Expressions.
Import the re module


import re
txt = "The rain in Spain"
x = re.search("^The.*Spain$", txt)


Python PIP
=====================================
PIP is a package manager for Python packages, or modules if you like.
If you have Python version 3.4 or later, PIP is included by default.
A package contains all the files you need for a module.
Modules are Python code libraries you can include in your project.




Python Try Except
============================================
The try block lets you test a block of code for errors.
The except block lets you handle the error.
The else block lets you execute code when there is no error.
The finally block lets you execute code, regardless of the result of the try- and except blocks.

try:
  print(x)
except NameError:
  print("Variable x is not defined")
except:
  print("Something else went wrong")


try:
  print(x)
except:
  print("Something went wrong")
finally:
  print("The 'try except' is finished")



Python User Input
============================
Python allows for user input.
That means we are able to ask the user for input.
The method is a bit different in Python 3.6 than Python 2.7.
Python 3.6 uses the input() method.


username = input("Enter username:")
print("Username is: " + username)




File Handling
======================================
The key function for working with files in Python is the open() function.
The open() function takes two parameters; filename, and mode.

There are four different methods (modes) for opening a file:
    "r" - Read - Default value. Opens a file for reading, error if the file does not exist
    "a" - Append - Opens a file for appending, creates the file if it does not exist
    "w" - Write - Opens a file for writing, creates the file if it does not exist
    "x" - Create - Creates the specified file, returns an error if the file exists

In addition you can specify if the file should be handled as binary or text mode
    "t" - Text - Default value. Text mode
    "b" - Binary - Binary mode (e.g. images)


Syntax:
To open a file for reading it is enough to specify the name of the file:
f = open("demofile.txt")
The code above is the same as:

f = open("demofile.txt", "rt")
Because "r" for read, and "t" for text are the default values, you do not need to specify them.
Note: Make sure the file exists, or else you will get an error.



ReadFile:
------------------
demofile.txt

Hello! Welcome to demofile.txt
This file is for testing purposes.
Good Luck!


To open the file, use the built-in open() function. 
The open() function returns a file object, which has a read() method for reading the content of the file:
f = open("demofile.txt", "r")
print(f.read())

If the file is located in a different location, you will have to specify the file path, like this:
f = open("D:\\myfiles\welcome.txt", "r")
print(f.read())



By default the read() method returns the whole text, but you can also specify how many characters you want to return:
f = open("demofile.txt", "r")
print(f.read(5))



Read Lines:
You can return one line by using the readline() method:
f = open("demofile.txt", "r")
print(f.readline())

By calling readline() two times, you can read the two first lines:
f = open("demofile.txt", "r")
print(f.readline())
print(f.readline())


By looping through the lines of the file, you can read the whole file, line by line:
f = open("demofile.txt", "r")
for x in f:
  print(x)


It is a good practice to always close the file when you are done with it.
f = open("demofile.txt", "r")
print(f.readline())
f.close()



Write to an Existing File
-------------------------------
To write to an existing file, you must add a parameter to the open() function:
"a" - Append - will append to the end of the file
"w" - Write - will overwrite any existing content
Note: the "w" method will overwrite the entire file.

Create a New File
To create a new file in Python, use the open() method, with one of the following parameters:
"x" - Create - will create a file, returns an error if the file exists
"a" - Append - will create a file if the specified file does not exists
"w" - Write - will create a file if the specified file does not exists



f = open("demofile2.txt", "a")
f.write("Now the file has more content!")
f.close()

#open and read the file after the appending:
f = open("demofile2.txt", "r")
print(f.read())



Python Delete File
==============================
To delete a file, you must import the OS module, and run its os.remove() function:
import os
os.remove("demofile.txt")


import os
if os.path.exists("demofile.txt"):
  os.remove("demofile.txt")
else:
  print("The file does not exist")


To delete an entire folder, use the os.rmdir() method:
import os
os.rmdir("myfolder")



===========================================
Python Modules
===========================================





##NumPy Tutorial
==========================================
https://github.com/numpy/numpy

NumPy is a Python library.
NumPy is used for working with arrays.
NumPy is short for "Numerical Python".
It also has functions for working in domain of linear algebra, fourier transform, and matrices.


Why Use NumPy?
In Python we have lists that serve the purpose of arrays, but they are slow to process.
NumPy aims to provide an array object that is up to 50x faster than traditional Python lists.
The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy.
Arrays are very frequently used in data science, where speed and resources are very important.


=>pip install numpy

import numpy as np
arr = np.array([1, 2, 3, 4, 5])
print(arr)
print(type(arr))

Rs:
[1 2 3 4 5]
`<class 'numpy.ndarray'>`



Check how many dimensions the arrays have:
import numpy as np

a = np.array(42)
b = np.array([1, 2, 3, 4, 5])
c = np.array([[1, 2, 3], [4, 5, 6]])
d = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])

print(a.ndim)
print(b.ndim)
print(c.ndim)
print(d.ndim)


Higher Dimensional Arrays:
import numpy as np
arr = np.array([1, 2, 3, 4], ndmin=5)
print(arr)
print('number of dimensions :', arr.ndim)


Access 2-D Arrays:
import numpy as np
arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])
print('2nd element on 1st row: ', arr[0, 1])

Negative Indexing:
import numpy as np
arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])
print('Last element from 2nd dim: ', arr[1, -1])



Slicing arrays:
    Slicing in python means taking elements from one given index to another given index.
    We pass slice instead of index like this: [start:end].
    We can also define the step, like this: [start:end:step].
    If we don't pass start its considered 0
    If we don't pass end its considered length of array in that dimension
    If we don't pass step its considered 1

import numpy as np
arr = np.array([1, 2, 3, 4, 5, 6, 7])
print(arr[1:5])



Data Types in NumPy:
    NumPy has some extra data types, and refer to data types with one character, like i for integers, u for unsigned integers etc.
    Below is a list of all data types in NumPy and the characters used to represent them.

i - integer
b - boolean
u - unsigned integer
f - float
c - complex float
m - timedelta
M - datetime
O - object
S - string
U - unicode string
V - fixed chunk of memory for other type ( void )


Create an array with data type 4 bytes integer:
import numpy as np

arr = np.array([1, 2, 3, 4], dtype='i4')

print(arr)
print(arr.dtype)


NumPy Array Copy vs View:
The main difference between a copy and a view of an array is that the copy is a new array, and the view is just a view of the original array.
The copy owns the data and any changes made to the copy will not affect original array, and any changes made to the original array will not affect the copy.
The view does not own the data and any changes made to the view will affect the original array, 
and any changes made to the original array will affect the view.




Get the Shape of an Array:
NumPy arrays have an attribute called shape that returns a tuple with each index having the number of corresponding elements.

import numpy as np
arr = np.array([[1, 2, 3], [5, 6, 7]])
print(arr.shape)



NumPy Array Reshaping:
By reshaping we can add or remove dimensions or change number of elements in each dimension.

Convert the following 1-D array with 12 elements into a 2-D array.
The outermost dimension will have 4 arrays, each with 3 elements:
import numpy as np

arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])

newarr = arr.reshape(4, 3)

print(newarr)


Reshape From 1-D to 3-D:
import numpy as np
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
newarr = arr.reshape(2, 3, 2)
print(newarr)



NumPy Array Iterating:
import numpy as np
arr = np.array([1, 2, 3])
for x in arr:
  print(x)



Joining NumPy Arrays:
import numpy as np
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6]
arr = np.concatenate((arr1, arr2))
print(arr)


Splitting NumPy Arrays:
import numpy as np
arr = np.array([1, 2, 3, 4, 5, 6])
newarr = np.array_split(arr, 3)
print(newarr)




Searching Arrays:
You can search an array for a certain value, and return the indexes that get a match.
To search an array, use the where() method

import numpy as np
arr = np.array([1, 2, 3, 4, 5, 4, 4])
x = np.where(arr == 4)
print(x)



Sort the array:
import numpy as np
arr = np.array([3, 2, 0, 1])
print(np.sort(arr))



Filtering Arrays:
import numpy as np
arr = np.array([41, 42, 43, 44])
filter_arr = arr > 42
newarr = arr[filter_arr]
print(filter_arr)
print(newarr)

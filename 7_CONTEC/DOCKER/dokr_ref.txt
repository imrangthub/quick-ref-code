#################################################
#                 DOCKER                        #
#################################################
Human->DockerClient->RestServer->DockerDeamon->ContainerD->RunC->Kernal

=>docker --version
=>docker info
=>docker login
=>docker logout

=>systemctl start docker
=>systemctl stop docker
=>systemctl stop docker.socket
=>systemctl status docker

=>docker run -d ubuntu sleep 100
=>sudo docker run -ti --rm ubuntu /bin/bash
=>docker run imranmadbar/hello-world-java
=>docker run --name containerName -p 8080:8080 -d imageName:tagName
=>docker run --name SpringBootWebApp -p 8080:8080 -d imranmadbar/hello-world-java-maven-web-spring-boot

=>docker stop conId
=>docker start contId

=>docker logs -f conId
=>ps -eaf | grep 8080
=>ps -eaf | grep docker
=>docker top containerId
=>docker exec containerId ls
=>docker exec -it containerId sh

=>docker cp contId:/etc/cassandra/cassandra.yaml C:/Z_MY_COMPUTER
=>docker cp C:/Z_MY_COMPUTER/1MD_IMRAN_HOSSAIN/JAVA/SimpleJavaApplicatio.java contId:/home

=>docker stop $(docker ps -a -q)
=>docker rm $(docker ps -a -q)
=>docker container rm -f $(docker container ls -aq)
=>docker image rm -f $(docker image ls -q)

=================================================
#                  Basic                                          
================================================= 
=>cat /etc/hosts
=>docker history imageName
Show image layers

=>ps -eaf                   #This command inside container
=>ps -eaf | grep docker     #This is command exect in hostmachine
Show host machine pId

=>docker ps 
=>docker ps -a
=>docker images
=>docker container ls

=>docker container ls -aq
List of container id

=>docker rm contId
=>docker rmi img
=>docker system prune --all
Delete all image

=>docker search hadoop
Search for a docker image on dockerhub with the name mentioned in the command.

=>docker inspect containerId
=>docker -f logs 09ca6feb6efc


=>docker diff containerId
Check the different history in container


=================================================
#Debug
=================================================
=>curl http://localhost:5000/v2/


=================================================
#Image | image | docker image
=================================================

=>docker rmi fce289e99eb9
Remove the docker image with the docker image id mentioned in the command


=>docker commit -m "commitMsg" -a "authorName" containerId newImageName



#Build Images
-------------------------------------------------
=>docker build -t myubunty:v1 .
=>docker image build -t imranmadbar/bas-config-server .

=>docker image build -t imranmadbar/docker-spring-boot-restcall-consumer .
=>docker image build -t imranmadbar/docker-spring-boot-restcall-producer .
List all the docker images pulled on the system with image details such as TAG/IMAGE ID/SIZE etc.

Retag the image with a version number:
=>docker image build -t imranmadbar/docker-spring-security-mysql-mvc-prod:1.0.0.RELEASE .
=>docker image build -t imranmadbar/hello-world-java-maven-web-spring-boot:1.0.0.RELEASE .


Create a ubuntu
-------------------------------------------------
#syntax=docker/dockerfile:1
FROM ubuntu:20.04
MAINTAINER madbarsoft.com
COPY system-status-and-time-logs.sh /app/myscript.sh
WORKDIR /app
RUN chmod +x myscript.sh
ENTRYPOINT ["/bin/bash", "myscript.sh"]



# Pull Images | download Images
-------------------------------------------------
=>docker pull imranmadbar/docker-spring-boot-mysql

Pull image with a version number:
=>docker pull imranmadbar/docker-spring-security-mysql-mvc-prod:2.0.0.RELEASE


# Run Images as container
-------------------------------------------------
=>docker run imranmadbar/hello-world-java
=>docker run --name containerName -p 8080:8080 -d imageName:tagName
=>docker run --name cassandradb -d -p 9042:9042 cassandra:3.11

=>docker run --name oauth2-authorization-server-api -p 8081:8081 imranmadbar/oauth2-authorization-server-api:1.0.0.RELEASE
=>docker run --name docker-spring-security-mysql-mvc-prod -p 8181:8181 imranmadbar/docker-spring-security-mysql-mvc-prod:2.0.0.RELEASE

=>docker container run --name producer -p 8080:8080 -d employee-producer
=>docker run --name docker-spring-boot-mysql -t --link mysql-dkr-contr-db:mysql-dkr-contr-db -d -p 8080:8181 imranmadbar/docker-spring-boot-mysql
=>docker run -d -p 3306:3306 --name=spring-boot-mysql-oauth2-db --env="MYSQL_ROOT_PASSWORD=root" --env="MYSQL_DATABASE=mysqloauth2db" -it mysql:5.7
=>docker run --name docker-spring-security-mysql-mvc-prod -t --link mysql-dkr-contr-db:mysql-dkr-contr-db -d -p 8080:8181 imranmadbar/docker-spring-security-mysql-mvc-prod:3.0.0.RELEASE
=>docker container run --network consumer-producer-net --name docker-spring-boot-restcall-producer -p 8080:8080 -d imranmadbar/docker-spring-boot-restcall-producer
=>docker container run --network consumer-producer-net --name docker-spring-boot-restcall-consumer -p 8282:8282 -d imranmadbar/docker-spring-boot-restcall-consumer

=>docker run --name arif-travel-agency-app --link mysqlschema:mysqlschema -t -p 8080:8080 imranmadbar/arif-travel-agency-app:1.0.0.RELEASE
=>docker run --name arif-travel-agency-app --link mysqlschema:mysqlschema -e MYSQL_HOST=mysqlschema -t -p 8080:8080 imranmadbar/arif-travel-agency-app:1.0.0.RELEASE

=>docker run --name SpringBootWebApp --cpus 3 -m 100m -p 8080:8080 -d imranmadbar/hello-world-java-maven-web-spring-boot
=>docker run --name SpringBootWebApp --cpus 3 --cpuset-cpus 1 -m 100m -p 8080:8080 -d imranmadbar/hello-world-java-maven-web-spring-boot
=>docker run --name SpringBootWebApp --cpus 0.2 --cpuset-cpus 1 -m 100m -p 8080:8080 -d imranmadbar/hello-world-java-maven-web-spring-boot



#Upload a docker Images 
-------------------------------------------------
=>docker push geekflare/httpd_image
Just make change, re-build image and push !

=>docker push imranmadbar/docker-swarm-spring-boot-consumer-api

With Version
=>docker push abiodunjames/example-node-app:v1
=>docker push imranmadbar/docker-spring-security-mysql-mvc-prod:1.0.1.RELEASE


=================================================
#Docker Container   
=================================================
=>docker exec -it 583c72a9b5e5 sh
Open Bash | CMD of Containers

=>docker start 09ca6feb6efc
=>docker rm 9b6343d3b5a0
=>docker restart 09ca6feb6efc
=>docker stop 09ca6feb6efc
=>docker container prune

=> docker kill 09ca6feb6efc
Stop the docker container immediately. Docker stop command stops the container gracefully, that’s the difference between a kill and stop commands.

=>docker cp contId:/etc/cassandra/cassandra.yaml C:/Z_MY_COMPUTER
=>docker cp C:/Z_MY_COMPUTER/MD_IMRAN_HOSSAIN/DB/CASSANDRA/cassandra.yaml contId:/etc/cassandra
Copy File From/To Container/Desktop


 
=================================================
#Mounting  | Volumes |  Bind mounts                                       
=================================================

=>docker volume create MyDataVol
=>docker volume ls
=>docker volume ls -f name=data
=>docker volume inspect MyDataVol

=>docker volume rm MyDataVol
=>docker volume prune


=>docker run --name SpringBootWebApp1 -dp 8080:8080 -v MyDataVol:/projectData containerId
=>echo "Simple Msg Written on volume" > /projectData/simple-msg.txt
Add data to volumn file inside from a container


=>docker run -it --rm -v MyDataVol:/vol busybox ls -l /vol
Check volume data with a temp container

=>docker run --name SpringBootWebApp1 -dp 8080:8080 -v C:\Z_MY_COMPUTER\1MD_IMRAN_HOSSAIN\DOCKER\MyBindMount:/MyBindMount d86b72bd0247
=>docker run --name SpringBootWebApp1 -dp 8080:8080 --mount type=bind,source=C:\Z_MY_COMPUTER\1MD_IMRAN_HOSSAIN\DOCKER\MyBindMount,target=/MyBindMount d86b72bd0247


To avoid losing data, Docker provides volumes and bind mounts, two mechanisms for persisting data in your Docker container.

#DockerVolumes
------------------------------------------------
Volumes are a great mechanism for adding a data persisting layer in your Docker containers.Docker volumes are completely handled by Docker itself and therefore independent of both your directory structure and the OS of the host machine.


#BindMounts
------------------------------------------------
Bind mounts will mount a file or directory on to your container from your host machine, which you can then reference via its absolute path.


=================================================
#Docker Network 
=================================================


=>docker exec 484bc9a71fea  ifconfig
=>docker network inspect netName

=> docker network ls
=>docker inspect bridge



#Create network (type Bridge)
-------------------------------------------------
=>docker network create consumer-producer-net
=>docker network create spring-security-mvc-net


#Run Container in a Network
--------------------------------------------------
=>docker container run --network employee-mysql --name employee-jdbc-container -p 8080:8080 -d employee-jdbc

#Run Container with a database
--------------------------------------------------
=>docker run --name docker-spring-security-mysql-mvc-prod3 -t --link mysql-dkr-contr-db:mysql-dkr-contr-db -d -p 8181:8181 imranmadbar/docker-spring-security-mysql-mvc-prod:3.0.0.RELEASE




#Create network (type Overlay)
-------------------------------------------------
=>docker network create --driver overlay producer-consumer-net


#Show IP add ress of Container
-------------------------------------------------
=>docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' container_name_or_id

#Delete docker network
-------------------------------------------------
=>docker network rm networkId



=>docker network create --driver bridge --subnet 182.18.0.1/24 --gateway 182.18.0.1 wp-mysql-network
Create a new network named wp-mysql-network using the bridge driver. Allocate subnet 182.18.0.1/24. Configure Gateway 182.18.0.1




=================================================
#Docker Compose  
=================================================
=>docker-compose --version




#Run Compose |  Up Compose
-------------------------------------------------
=>docker-compose up
=>docker-compose down
=>docker-compose up -d 

=>docker-compose up -d --no-recreate



=>docker-compose up -d --no-recreate

When you use docker-compose up, if there are any changes in the docker-compose.yml file that affects the containers, they will stopped and recreated.
But, you can force docker-compose not to stop and recreate the containers, you can use –no-recreate option as shown below during the docker-compose up. In other words, if the container already exits, this will not recreate it.


You also can do the opposite. The following will forcefully recreate the containers even if nothing in the docker-compose.yml is changed.




#You can also specify the timeout value
-------------------------------------------------
=>docker-compose up -d -t 30
Default value is 10 seconds, but the following command will use the time-out value of 30 seconds.



#The following are few additional options you can use along with “docker-compose up”
-------------------------------------------------
–no-deps This will not start any linked depended services.
–no-build This will not build the image, even when the image is missing
–abort-on-container-exit This will stop all the containers if any container was stopped. You cannot use this option with -d, you have to use this option by itself.
–no-color In the output, this will not show any color. This will display the monochrome output on screen.


#Set Container Name
---------------------------------------------------
mysql:
    image: mysql
    container_name: sf4_mysql




=================================================
#Docker Swarm  
=================================================

=>docker swarm init --advertise-addr 192.168.8.11
=>docker swarm join-token worker
=>docker swarm join-token manager

=>docker node ls

=>docker service create --replicas 2 --name mynginx -p 8080:80 nginx
=>docker service create --replicas 2 --name SpringBootWebApp -p 8080:8080 -d imranmadbar/hello-world-java-maven-web-spring-boot

=>docker service ls
=>docker service logs -f serviceId
=>docker service inspect --pretty serviceId

=>docker ps
=>docker service ps serviceId
see which nodes are running the service:


=>docker service scale serviceId=5
=>docker service rm serviceId


#Check Docker node-service
-------------------------------------------------
=>docker node ls

#Create a network of type overlay
-------------------------------------------------
=>docker network create --driver overlay producer-consumer-net

When using services in a swarm,need a network so that multiple docker instances can interact with each other. 
this time the network will be of type Overlay.


#Create docker service
-------------------------------------------------
=>docker service create --network producer-consumer-net --name docker-swarm-spring-boot-consumer-api -p 8282:8282 imranmadbar/docker-swarm-spring-boot-consumer-api
=>docker service create --network producer-consumer-net --name docker-swarm-spring-boot-producer-api -p 8181:8181 imranmadbar/docker-swarm-spring-boot-producer-api

#Stop a docker service
-------------------------------------------------
=>docker service scale [serviceName]=0
=>docker service scale docker-swarm-consumer-service=0
Will remove all running instances but still keep the service object alive.


#Deploy the stack to the swarm
-------------------------------------------------

=>docker stack deploy --compose-file docker-stack-swarm.yml bahsSwarmStack
=>docker stack deploy --compose-file docker-stack-swarm-net.yml bahsSwarmStack

=>docker stack ps bahsSwarmStack


=>docker stack rm bahsSwarmStack





#Play with Docker
---------------------------------------------------
CTRL + FN + E to copy
CTRL + SHIFT + v to paste

All dockerStack and dockerService commands must be run from a manager node.


=>scp some-service.zip ip172-180-11-b2dfdf.play.with.docker.com:~
Copy file to play with docker node
=================================================
#Docker Daemons 
=================================================

=>docker --version


#Windows issue
-------------------------------------------------

In the default daemon configuration on Windows, the docker client must be run elevated to connect

You can do this in order to switch Docker daemon, as elevated user:

With Powershell:

Open Powershell as administrator
Launch command: & 'C:\Program Files\Docker\Docker\DockerCli.exe' -SwitchDaemon
OR, with cmd:

Open cmd as administrator
Launch command: "C:\Program Files\Docker\Docker\DockerCli.exe" -SwitchDaemon




#Installing plugin
-------------------------------------------------
=> docker plugin install vieux/sshfs D
Install a docker plugin vieux/sshfs with debug environment set to 1.



=================================================
#Jenkins | jenkins 
=================================================
=>docker pull jenkins/jenkins
=>docker run -p 8080:8080 -p 50000:50000 --restart=on-failure jenkins/jenkins:lts-jdk11
=>docker run -d -v jenkins_home:/var/jenkins_home -p 8080:8080 -p 50000:50000 --restart=on-failure jenkins/jenkins:lts-jdk11





=================================================
#MySQL | Sql 
=================================================
=>netstat -tulpn
Check host machine running port

create table std_tbl(
   id INT NOT NULL AUTO_INCREMENT,
   name VARCHAR(100) NOT NULL,
   gender VARCHAR(40) NOT NULL,
   PRIMARY KEY ( id )
);
INSERT INTO std_tbl VALUES (1, 'IMRAN', 'MALE');

=>docker run -d -p 3306:3306 --name=mysqlschema --env="MYSQL_ROOT_PASSWORD=root" --env="MYSQL_DATABASE=simpledb" -it mysql:5.7.18
=>docker exec -it contId bash
=>mysql -uroot -proot
=>show databases/tables;

=>docker run --name mysqldb1 -d -e MYSQL_ROOT_PASSWORD=root --env="MYSQL_DATABASE=simpledb" --mount type=bind,dst=/var/lib/mysql,src=/home/imran/imranMadbar/dockerPROD/mySqlRef2 mysql
=>docker run --name mysqldb -d -e MYSQL_ROOT_PASSWORD=root --env="MYSQL_DATABASE=simpledb" -v /home/imran/imranMadbar/dockerPROD/mySqlRef:/var/lib/mysql mysql



=>docker run --network=wp-mysql-network -e DB_Host=mysql-db -e DB_Password=db_pass123 -p 38080:8080 --name webapp --link mysql-db:mysql-db -d kodekloud/simple-webapp-mysql
Deploy a web application named webapp using the kodekloud/simple-webapp-mysql image. Expose the port to 38080 on the host.

The application makes use of two environment variable:
1: DB_Host with the value mysql-db.
2: DB_Password with the value db_pass123.
Make sure to attach it to the newly created network called wp-mysql-network.



Also make sure to link the MySQL and the webapp container.




=================================================
#FFI
=================================================

=>docker info
=>docker help run
=>docker composer


=================================================
#Fix Docker Issue: (Permission denied)
=================================================

Create the docker group if it does not exist: sudo groupadd docker
See number of super users in the available system: grep -Po '^sudo.+:\K.*$' /etc/group
Export the user in linux command shell: export USER=demoUser
Add user to the docker group: sudo usermod -aG docker $USER
Run the following command/ Login or logout: newgrp docker
Check if docker runs ok or not: docker run hello-world
Reboot if you still get an error: reboot
If it does not work, run this command:
sudo chmod 660 /var/run/docker.sock



=================================================
#WorkTemp
=================================================

FROM openjdk:8-jdk-alpine
MAINTAINER imranmadbar@gmail.com
COPY target/arif-travel-agency-0.0.1-SNAPSHOT.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]

Ubuntu Image
---------------------------------------------------------------------------------------
=>docker run -it --entrypoint "/bin/bash" ubuntu:20.04
=>docker run -it ubuntu:14.04 /bin/bash

=>docker caontainer attach containerId



=================================================
# DCA | dca
=================================================

=>docker info
Shwo Basice information about docker



Build Images
-----------------------------------------------------------------------------------------
 =>docker build -f dockerfiles/Dockerfile.debug -t myapp_debug .
 =>docker build -f dockerfiles/Dockerfile.prod  -t myapp_prod .








#Documentation
===============
=>docker version --format '{{.Server.Version}}'
Get the server version

=>docker network disconnect
Disconnect a container from a network


=>docker exec -it <mysql-container-id> mysql -u root -p
Log in mysql



#Docker overview | Definition
-------------------------------------------------
Docker is an open platform for developing, shipping, and running applications. 
Docker enables you to separate your applications from your infrastructure so you can deliver software quickly. 


#The Docker platform | Container
-------------------------------------------------
Docker provides the ability to package and run an application in a loosely isolated environment called a container. 
The isolation and security allows you to run many containers simultaneously on a given host. 
Containers are lightweight and contain everything needed to run the application, so you do not need to rely on what is currently installed on the host.


#Docker architecture
-------------------------------------------------
Docker uses a client-server architecture. The Docker client talks to the Docker daemon, which does the heavy lifting of building, 
running, and distributing your Docker containers. 
The Docker client and daemon can run on the same system, or you can connect a Docker client to a remote Docker daemon. 
The Docker client and daemon communicate using a REST API, over UNIX sockets or a network interface. 
Another Docker client is Docker Compose, that lets you work with applications consisting of a set of containers.


#The Docker daemon
-------------------------------------------------
The Docker daemon (dockerd) listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes.
A daemon can also communicate with other daemons to manage Docker services.


#The Docker client
-------------------------------------------------
The Docker client (docker) is the primary way that many Docker users interact with Docker. 
When you use commands such as docker run, the client sends these commands to dockerd, which carries them out. 
The docker command uses the Docker API. The Docker client can communicate with more than one daemon.


#Images
-------------------------------------------------
An image is a read-only template with instructions for creating a Docker container. Often, an image is based on another image, 
with some additional customization. For example, you may build an image which is based on the ubuntu image, 
but installs the Apache web server and your application, as well as the configuration details needed to make your application run.




#Containers
-------------------------------------------------
A container is a runnable instance of an image. You can create, start, stop, move, or delete a container using the Docker API or CLI. 
You can connect a container to one or more networks, attach storage to it, or even create a new image based on its current state.

A container is a normal operating system process except that this process is isolated and has its own file system, 
its own networking, and its own isolated process tree separated from the host.

When you restart a container, it starts with the same flags or commands that it was originally started with.



#The underlying technology
-------------------------------------------------
Docker is written in the Go programming language and takes advantage of several features of the Linux kernel to deliver its functionality.
Docker uses a technology called namespaces to provide the isolated workspace called the container. 
When you run a container, Docker creates a set of namespaces for that container.
These namespaces provide a layer of isolation. 





#Dive into the volume
-------------------------------------------------
A lot of people frequently ask “Where is Docker actually storing my data when I use a named volume?” 
If you want to know, you can use the docker volume inspect command.


#Use Docker Compose
-------------------------------------------------
Docker Compose is a tool that was developed to help define and share multi-container applications. 
With Compose, we can create a YAML file to define the services and with a single command, can spin everything up or tear it all down.


#Docker’s swarm
-------------------------------------------------

Service:A Docker "service" is one or more containers with the same configuration running
under Docker’s swarm mode.

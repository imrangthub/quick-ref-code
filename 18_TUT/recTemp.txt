
=================================================
##7) Networking and Security
=================================================




Why do we actually need Docker networks?

Well, in real-world projects, 
system architecture is getting more complex every day especially with multi-tier 
applications and microservices.


You know..
Different services constantly need to talk to each other.

For example, your application server might need to communicate with a database server, 
authentication service, or other internal components.





Think about a typical multi-tier application.

In real-world systems,  frontend, backend, 
and database—often run in separate environments. 


so 
we really need a clear communication line here, right ?

Docker networks make this communication clean, secure.


Docker makes sure all these components can communicate with each other 
smoothly and securely.




Docker networking isn’t just about connecting containers; 
it’s also about controlling who can access what.



For example, you may want your database to be reachable only by the app server, 
not by the public network.


This is where Docker networks play a major 
role in keeping your architecture both functional and secure.







Let’s take a simple three-tier application as an example.




The frontend is deployed in a public network, where users can access it directly.



The application server sits in a secure network, away from public exposure.



And the database server lives in an even more restricted network, 
where only the app server is allowed to communicate with it.



This layered structure keeps everything organized, 
controlled, and secure—just like in a real production environment.





Docker networking works like normal networking on a host machine.
Docker creates a virtual Ethernet network, 
and every container gets its own IP address.




You might wonder...
we never created a network, but our containers still worked.
How....?

That’s because Docker automatically uses a default network called the bridge network.


If you don’t specify a network, your container joins this bridge network by default.




You can check all Docker networks using the docker network ls command.

This lists every network available, including the default ones.




docker inspect.

It gives you detailed info,
like the container’s network settings and which network it’s using.








9:30:
=================
Now let’s create our first Docker network.


to do that we gonna run docker network create command




If you don’t specify a driver, 
Docker will automatically use the default driver. 



Do you know what that is? It’s the bridge driver.


because bridge driver is the Docker’s default network.






Now
What is a network driver?

It’s the component that decides how containers 
communicate with each other and with the host machine.




By default, there are three network drivers available here.




Bridge:
Now let’s explore the bridge network.


The Docker bridge network driver creates an internal, 
private network on the host where containers can communicate with each other.



It’s the default driver for standalone containers 
and allows port mapping so outside clients can access 
services running inside containers.



Docker automatically assigns a subnet when you create a network, 
but you can also define your own custom subnet.


Every container connected to a network gets a unique IP address from that subnet, 
making each one individually reachable within the network.







Host driver:
With this driver, the container is directly connected to the host’s network.
It shares the host’s IP, so it doesn’t get its own.



For example, if your host machine’s IP is 192.168.1.10 
and you run a web server in a container, 
you can access it using the host’s IP directly—no extra networking needed.


This is handy when you want the container application 
Behave like it’s running directly on your machine.


Like when you need a MySQL server on your host machine for development work.






None driver:
On the other hand, the none driver completely isolates the container.

It has no network access, so it can’t communicate with other containers or the host.
This is useful if you just want to run a container 
for computation or testing, without exposing it to any network.










14:30
===================

Now let’s explore the bridge network a bit more.
First, we’ll check the IP address of our running container and see 
which network it’s connected to.


We can go inside the container using:
docker exec -it <container_name> bash



Once inside, you’ll be able to see its IP address and 
confirm which network it’s using.






Let’s check another container the same way.
Go inside using docker exec -it <container_name> bash and check its IP.









Now let’s create a custom Docker network.

After creating it, we can check it using:
docker network inspect <network_name>



You’ll see that it comes with a new subnet range, 
different from the default networks.

This allows us to control the IP addresses 
and structure of our containers more precisely.








Now let’s test communication using our new custom network.




We’ll run two services on this network.
Let’s say we have a database server and an application backned-service.




First, we’ll run the backend-service container without attaching it to custom network, 
and see what happens in that situation.





So right now, we have two containers—one for the database server 
and one for the application server.





You’ll notice that the DB server is running on our custom network, 


while the application server is still on the default network, 
because we didn’t specify a network when running it.






Now, these two containers are on different networks. 
Let’s check if they can communicate.





We’ll try using a curl request.
I have the IP addresses—right now I’m inside the DB server, 
so I can attempt to connect.




First, let’s check the DB server’s IP.
Now, let’s try to curl the application server from the DB server.






As expected, we don’t get any response, .
because the containers are on different networks and cannot communicate 
with each other.




This clearly shows why containers need to be on the same network 
if you want them to talk to each other.







Now let’s fix the issue.
We’ll run our backend service on the same network as the database server.





You can inspect the network using:
docker network inspect my_net
This will show how many containers are connected to it.




Let’s run our second container on this network.


Now, if we check the network again, 
you’ll see  the IP addresses of both containers.




Next, let’s test communication between the two services.
We’ll go inside one container and run a curl command.



Now you’ll see we get a response from the DB container, 
which means they can successfully communicate.



This is exactly how the bridge network works:


When multiple containers are on the same network, 
they can easily talk to each other.











29:00
============================


Host Network:
The host network connects the container directly to the host machine’s network, 
so you can access it using the host’s IP.

It’s not used very often, but you can find more details in the Docker documentation.


You can give it a try—I am gonna leave it up to you.




Overlay network:
Now let’s talk about the Overlay network.
The overlay network is designed for clustering multiple Docker nodes, 
like in a Docker Swarm.


It lets containers on different machines talk to each other as if 
they were on the same network.

making multi-node communication simple and seamless.









Custom subnet:

Now let’s create a network with a custom subnet.


In the previous steps, we used Docker’s default subnet.
Now, we’ll create a network with a custom subnet, 
which lets us define our own range of IP addresses and gateway.



First, let’s check the current networks we have.


This one we created earlier and 
we didn’t specify any subnet for this network, 
so Docker automatically assigned one.




Let’s create a custom network.
In the command, we’ll set the subnet, choose a gateway IP from that subnet, 
and give our network a name.




Once it’s created, we can check the details using:
docker network inspect <network_name>
This shows the assigned subnet, IP range, and gateway.





Now, if we run a container using this network, 
it will get an IP from our custom subnet.




Let’s try it.
We’ll name the network mynet2 and the container mydb3.




After running the container, we can check its IP with docker inspect.



You’ll notice that the container gets an IP from our custom subnet,
which shows that everything is set up correctly.









That’s it for todays video guys !

We’ve covered bridge, host, and overlay networks,
and seen how containers communicate with each other.

We also learned how to create custom networks with your own subnets.


So thats it....
Thanks for watching! If you found this helpful, like, comment, 
and subscribe for more Docker tips and tutorials.



See you in the next episode !









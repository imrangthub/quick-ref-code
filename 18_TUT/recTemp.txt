
=================================================
##6) Storage and Volumes
=================================================

Hello and welcome back!
In this episode, we gonna discussing Docker Storage and Volumes.


By default, all files created inside a container are stored in the container itself.


The Problem with the Default System:
    When the container is removed, all files will be gone.
    Storing too much data inside the container may slow down your app and make performance issues.


Like:
    Your app produces logs that you want to keep.
    Your application may write files that you want to save for future analysis.



To solve this issue, Docker provides two  main ways to keep data safe:
    Volumes and Bind-mounts.






For more details, You can check out Docker’s official documentation.
Lets explore this:


Let’s talk about Volumes:
    Volumes are stored by Docker and can only be accessed by containers, not by host processes, so they are secure.
    When you use a volume to store logs or other data, even if the container is removed, your data will still be safe in the volume.
    When a new container is created, it can reuse the same volume and access all the saved data.

You can check volume using DockerDesktop or cli as Image and contienr.

Volumes are stored inside Docker and can only be accessed by Docker containers, not by the host processes.
Volumes are the recommended and secure approach.



Now let’s talk about Bind Mounts:
    Bind mounts also keep data outside the container and outside Docker, anywhere on your host file system.
    This way, your container runs inside Docker, but the data is saved on the host where other apps can access it.
    For example, you can store logs in a bind mount and have Loki or Grafana read and process them.

Bind-mounts are useful when you need to perform analysis or allow other host machine processes 
to access data generated by the container, such as logs or reports.




So,
    If you don’t need to access container data outside Docker, go with Volumes — they’re secure and recommended.
    If you want to access or process container data from the host or other apps, use Bind Mounts.




tmpfs:
    It’s the fastest and most secure option for contianer data storage.
    tmpfs Data isn’t saved in any volume or on the host’s file system — it stays in the host’s RAM.
    tmpfs is ideal when you need high-performance,  most secure operation.















9:20mm
============================
Now, let's start with the basic Docker volume commands and practice with volumes.


Let's start with Nginx and see how we can use volumes with an application server.


My application is running now. Let’s modify it to update the default Nginx page.


We need to exec into the container to update its welcome HTML page.
Use docker exec
Inside the container, vi is not available, so I’ll use the echo command to update the page.

echo "Welcome to My Custom Nginx Page!" > /usr/share/nginx/html/index.html
Once we update the page, we refresh the browser, and we can see the update reflected on the page.


What happens when the container crashes ?
For thist Manually stop the container and remove it.


Observation:
This time, the default Nginx welcome page shows up again, and we lose the update we made 
just a few minutes ago.
This happens because the data was stored inside the container's filesystem. 
When the container stops or crashes, the data inside is lost. 
This is the default behavior of Docker containers.
To persist the changes made to the Nginx page, we can use Docker volumes.


16:00
============================
Now, let's fix the data loss issue by using Docker Volumes:

Steps to Fix Data Loss with Docker Volume
First, let’s check the existing volumes by running:
docker volume ls
As we haven’t created a volume yet, the list will be empty.

Now, let’s create a Docker volume using the following command:
docker volume create my_volume

Verify the Volume:
Once the volume is created, run docker volume ls again to see the volume we just created:
docker volume ls
You should see my_volume in the list of volumes.


Now, let’s run the Nginx container and mount the created volume to it. 
Use the following command to do this:
docker run -d -p 80:80 -v my_volume:/usr/share/nginx/html nginx

Here, -v my_volume:/usr/share/nginx/html tells Docker to mount the my_volume 
to the /usr/share/nginx/html directory inside the container.


Now, you can check the Nginx homepage in your browser. It should display the default Nginx welcome page.

Let’s update the index.html page again, but this time the changes will be persisted 
even if the container is restarted.

So, 
docker exec -it <container_name> /bin/bash
Update the index.html file using echo:
echo "Welcome to My Custom Nginx Page!" > /usr/share/nginx/html/index.html


You can verify the update by using the cat command to see the contents of the index.html file:
cat /usr/share/nginx/html/index.html

Once the update is made, refresh your browser, and you should see the updated page as expected.


Now If the container stops or is restarted, the changes to the index.html page will 
persist because the data is stored in the Docker volume (my_volume).

In Docker Desktop, you can also see the container and the volume being used.
Now we have successfully solved the data loss issue by using Docker volumes.





Let's assume the application crashed, and you stopped and deleted both the container and the image. 
In Docker Desktop, you can see that there is no container or image listed.

You can also verify this by running the following command:
docker ps -a  # to list all containers
docker images  # to list all images


Even if the container or image is deleted, the volume will still persist. 
You can check the volume by running:
docker volume ls
The volume we created earlier (my_volume) will still be listed.


Now, let's pull the Nginx image again and run a new container with the same volume. 
You can run the following command:
docker run -d -p 80:80 -v my_volume:/usr/share/nginx/html nginx


Once the container is up and running again, you can go to the browser and 
check if the previously updated index.html page is displayed (the one we updated before the crash).
The volume ensures that the data is preserved even after container restarts or deletions.


If you run a new Nginx container without mapping the volume,
 it will show the default Nginx page because it is not using the previous volume that 
 stored the updated index.html file.
docker run -d -p 80:80 nginx

Since we didn’t use the volume (my_volume) this time, the container is using the default Nginx data, 
and we won't see the updated index.html page.

Docker Volumes ensure that data is persistent even after the container is deleted or crashes. 




27:30
==================================

Hey everyone! Welcome back to the channel!
Now Bind Mounting !
So, what exactly is Bind Mounting?

With Bind Mounting, a file or directory on the host machine is mounted directly into a Docker container.
This allows you to share files and data between the host machine and the container.
It’s super useful when you need to update or manage files on your container from your local machine directly.


Here’s the syntax for bind mounting:
You can use the -v flag for a quick bind mount or the more explicit --mount option.

For Linux and Windows systems, the command looks like this:
Using -v (short version):
docker run -d -v /path/on/host:/path/in/container nginx
Or, the more explicit version using --mount:
docker run -d --mount type=bind,source=/path/on/host,target=/path/in/container nginx
The --mount approach is the recommended method because it’s more explicit and easier to understand.


Let’s see Bind Mounting in action!
We’re going to start by cleaning up our previous container:
docker rm -f <container_id>
Next, we’ll update our HTML file on the host machine and use bind mounting to reflect those 
changes directly into the Docker container.


Update the index.html file on our host machine.
Let’s add a simple change, like modifying the welcome text.

Run the Docker container with the bind mount:
docker run -d -v /path/to/host/index.html:/usr/share/nginx/html/index.html nginx
What we’ve done here is mount the file from our host machine to the container.



Now, let’s open our browser and refresh the page.
As you can see, we’ve got the expected update! The change we made to the file on the 
host machine was reflected directly inside the container.

That’s the magic of bind mounting!

Now, let’s update the index.html file once again on the host machine.
We’ll make a small tweak to the content, save it, and refresh the browser again.
And boom, we see our new update immediately in the container as well!



So, the key difference between bind mounting and volume mounting is that with bind mounting, 
we’re directly sharing and modifying a file or directory from the host machine to the container.


Now, let’s briefly touch on Tmpfs, another mounting option in Docker.

Tmpfs allows you to store data in memory instead of on disk. 
It’s a volatile storage solution, meaning that the data won’t persist if the container stops or crashes.

Here’s the basic syntax for Tmpfs mounting:
docker run -d --mount type=tmpfs,target=/path/in/container nginx
Tmpfs is generally rarely used and can be handy in specific scenarios where performance is critical, 
and the data doesn’t need to persist.

[Outro]
So, that’s an overview of Bind Mounting and Tmpfs in Docker.
See you in the next video!




34:30
=============================
 we'll explore Docker Volumes and how they can be used to persist data, 
 specifically using a MySQL database as a real-world example.

In this lecture, we'll cover why Docker containers lose data by default and how volumes 
can help solve this problem by storing data outside of the container's filesystem.


By default, Docker containers are ephemeral, which means that any data inside a container is 
lost once the container stops or is deleted. 
This behavior works great for temporary data, 
but it’s a huge problem when you need to store persistent data, such as a database.

Let’s take a simple MySQL container as an example. 
If we run a MySQL database inside a container and insert some data,
 once we stop or remove the container, all the data inside that container is gone. 
 So, if your MySQL container crashes or you delete it for some reason, you lose all the database records.


This is a problem if you want to store important data like customer records, 
transactions, or any type of persistent database information.


The solution to this problem is Docker volumes. 
A Docker volume is a special kind of storage that is managed by Docker itself, 
separate from the container’s filesystem. 
Volumes allow you to persist data even when the container stops, crashes, or is deleted.


Instead of storing data inside the container, Docker volumes are stored on the host system. 
This means that even if a container is removed, the volume persists, keeping your data safe.



When you use volumes with a container, you mount the volume to a specific path inside the container. 
For example, in the case of a MySQL container, 
you would mount a volume to the path where MySQL stores its data (/var/lib/mysql). 
This way, MySQL’s data is saved in the volume instead of inside the container.


Once a volume is created and linked to a container, you can stop, remove, and recreate the 
container without worrying about losing your data. 
The volume remains intact, and the next time the container starts, it will have access to the same data.


Imagine you are running a MySQL container, and you insert some data into the database. 
Without a volume, this data would be lost if the container is removed. 
But with a volume, the data is safely stored in the volume and can be reused even after 
the container is deleted and recreated.

To make this work, you create a Docker volume and mount it to the container’s data storage directory. 
Now, any changes you make to the database, 
like adding or modifying records, are stored in the volume, ensuring that the data persists.

When the container is stopped or deleted, you simply run a new container, 
mount the same volume, and the database will continue with the previous data intact.



The benefits of using Docker volumes include:
    Persistence: Data survives even after the container is deleted or crashes.
    Isolation: Volumes are separate from the container’s filesystem, reducing the risk of accidental data loss.
    Portability: You can easily back up or migrate volumes across different environments or machines.
    Data Sharing: Volumes allow multiple containers to share data without worrying about data 
    duplication or file conflicts.



There are other ways to manage data in Docker, such as bind mounts and tmpfs. 
However, volumes are typically the most reliable and efficient way to persist data.

Bind Mounts: These link a specific file or directory from the host system to the container. 
While they are useful for development or when you need access to host data inside a container, 
they are not as secure or portable as volumes.

tmpfs: This is an in-memory filesystem that is mounted inside the container, 
and data is lost when the container stops. It’s the fastest but not suitable for persistent data.
Volumes are recommended because they offer persistence, security, and flexibility.






Create a Volume: First, create a volume called mysql-data to store MySQL data. 
You can check if it’s created by listing the volumes with a simple command.

Run MySQL with Volume: Now, run a MySQL container while mounting the mysql-data volume. 
Once it’s running, log into the database, create a table, and insert some data.


Verify Data Insertion: Retrieve the data by running a SELECT query to ensure that everything is in place.

Volume Persistence: Docker volumes keep the data separate from the container, 
meaning if the container is deleted or crashes, 
the data is safe. You can see the volume details in Docker Desktop.


Delete and Restart the Container: Now, stop and delete the container. 
Afterward, restart the container with the same volume attached.


Verify Data After Restart: Use the same methods to check that your data is still intact after 
restarting the container. This proves that the data has been successfully persisted with Docker volumes.



Use Bind Mount: 
Next, let’s use a Bind Mount. Choose a directory on your host machine and bind mount it 
to the MySQL container.

Run MySQL with Bind Mount: Run the container with the host directory mounted to the container. 
This way, the container directly interacts with the files on the host machine.

Insert Data: Just like before, insert data into the MySQL container.

Verify Data: After inserting data, check the host machine’s directory. 
You should see the MySQL data being written directly to that path.

Delete and Restart the Container: Stop and delete the container again, 
and then run the container with the same bind mount to verify data persistence.

Check Data After Restart: After restarting the container, check the data to ensure it remains intact. 
This confirms that the data is properly persisted with bind mounting.


[Conclusion]
Thank you for watching! Don’t forget to like, subscribe, and click the bell for more tutorials!



=================================================
##8) Simple Example Project
=================================================


Hey everyone! Welcome back!

Today, we’re going to run several projects using Docker.



We’ll show you how to run projects using different programming languages 
like Java, Python, PHP, and Node.js.


and I’ll break it down into a super easy, step-by-step guide.



This episode going to be an interesting one.

Let’s jump into it !




GitHub Link: 
The source code for this project is available on GitHub. 

You can find the link in the description below.



You can access the code either 
by cloning the repository or downloading it directly as a ZIP file.




First, 
let's see how you can clone the repository using Git. 




Open your terminal and run the following command:
git clone [GitHub Repository URL]

This will clone the entire project into your local machine, 
and you can start working with it right away.



Alternatively,  you can download the project as a ZIP file. 

Just go to the GitHub page, and there will be an option to "Download ZIP" 
on the repository page.









1:30
==============

First, we’re going to run a PHP project using Docker.

Lets see how we can do it.



This project is super simple – just one file, index.php, like a Hello World.


Lets see the docker file how it looks like:


    FROM – sets up the PHP environment
    COPY – moves our file into the container
    EXPOSE – opens the port to access the project




Simple, right? Let’s run it!





4:10
=====================

Let’s open the terminal here,
you should see two files: Dockerfile and index.php




Let’s build Docker image for our PHP project. 

To do that, we use the following command:

docker build -t php-project .




This command will build the image based on the Dockerfile 
in the current directory, named php-project.







Now that we’ve built the image, 


let’s run the container using the following command:

docker run -d -p 8080:80 php-project



This command runs the php-project in detached mode.

and maps port 80 in the container to 8080 on your machine.




If everything is set up correctly, your project will be running.



Open your browser and go to port 8080 to see it in action!



We’re using just a single file here, 
but for bigger PHP projects with many files, 
make sure your project structure is organized and all files are 
copied to the right directories.











7:40
==========================



In the real world, most projects use a multi-tier setup with 
frontend, backend, and a database.





Now, we’re going to run a multi-tier application with the common three parts: 
frontend, backend, and database.



Each tier will run in a separate container, 
and we’ll use Docker networking to enable communication between them.



In a typical three-tier application, 
the frontend communicates with the backend, and the 
backend communicates with the database.



Here docker provide a dns for internal communication !


Docker’s default bridge network doesn’t include an internal DNS resolver, 
so containers can communicate using IP addresses, 
but not by container names. 




To fix this, we use Docker’s custom networks, 
which make dns-based communication easy.







Before we start creating our multi-tier application, 
let’s check which networks are already available. 



Run the following command to list all Docker networks:
docker network ls




Let’s test the default bridge network by running two containers. 



We’ll attempt to make them communicate, but since 
there’s no internal DNS resolver, 
they can only communicate using IP addresses, not container names.









Now, let’s create a custom network that includes Docker’s internal DNS resolver. 
This will allow us to use container names for communication.




To create a custom network, use the following command:
docker network create --driver bridge my_custom_network





Once our network is set up, we’ll run two new Nginx containers, 
ng3 and ng4, on this network. 





The idea here is to test how these containers can communicate with each other 
using DNS, rather than relying on IP addresses.






Next, we’ll inspect the network to check the current status. 
This will confirm that our two containers, 
ng3 and ng4, are running on the same custom network.






Now, let's check if it's possible for the two containers 
to communicate with each other by DNS.



First, we’ll test using IP addresses to see if the communication works. 

After that, we’ll test using DNS resolution.






Let’s take a look at what our three-tier application setup will look like. 





In this setup, we’ll have the frontend, backend, and database containers, 
all connected using the custom network we just created. 




This will allow each tier to communicate seamlessly, 
using DNS names instead of IP addresses.





Let’s start by running our database server.

We’ll use this command (you can check Docker docs for details 
on the environment options).




We’re going to use our custom network and also attach a volume 
to keep our data safe – you already know about Docker volumes.



Alright, let’s run it!


Okay, our database server is running!
Let’s check the tables and add some data.




We’ll create a table and then run a few INSERT commands to add some records.





30:10
==========================
Now, let’s see how to run a simple Python project in Docker 
and connect it to a database.





We’ll check out the source code and Dockerfile for this project.




First, looking at the python sorece code, 


Tt’s simple: 
we create a database connection and pass the hostname 

using an environment variable.





Now, let’s check the Dockerfile. 




As usual, we start with a Python base image.



then create a folder inside the container called app to hold our code.



Next, we install the required library and copy the source code into the container.



Finally, we use the CMD instruction to run the Python script.





Let’s now build the Docker image with the docker build command. 



Once the image is built, we’ll move on to running it.




Now, we’ll run the container using docker run.



We’ll make sure the Python project connects to the database and 
runs the query successfully.





We use the container name as DNS to connect to the MySQL server, 
and provide the database credentials and name.




Let’s run it…
And there you go! 
Our application is running successfully and reading data from the database.



Let’s capture a screenshot and add it to our documentation.




That’s it! 
We’ve built and run a Python application with MySQL in Docker.







40:10
===========================




Now 
We we’ll build and run a Java  application !





Lets check the docker file first.



Before running the Java application, we need to compile and build a JAR file.




We’ll use Maven for this.


Let’s see how to go from java source code to a JAR file. 


To do that ...
I’ll import the project into Eclipse IDE to make building the JAR easier.





Java is a bit different from other programming languages,
You always need to build a JAR before running the application.




This is a Spring Boot project, and here’s the pom.xml 
where you can see all the dependencies.



Here’s the source code.
Now, let’s build the required JAR file.





This is the Dockerfile—let’s check it out!





The steps are similar to what we did for the Python application:



Use a JDK as the base image.

Create a directory inside the container.

Copy the JAR file into the container.

Expose the necessary port.

Finally, run the JAR file.






Now, let’s build the Docker image for our Java Spring Boot app 
using the Docker build command.




Next, we’ll run the Java app inside a container on the same 
Docker network as our MySQL database.




Oops! We got a port conflict because our Python app is already using port 8080.





To fix this:
    We stop and remove the existing Python container.
    Now, we rerun the Java application container.




It runs successfully! Let’s take a screenshot and add it to our documentation.



Now, 
let’s open the browser and check http://localhost:8080.



Yes! We successfully get the data from the MySQL server.





To debug and monitor the application, we can check container logs:

Use the docker logs command to see past logs.


Use docker logs -f to view live logs in real time.




Now, our MySQL database and backend Java application 
are fully set up inside Docker.





The backend is ready! 
Now, we’ll proceed to running a Node.js frontend application in the next step.






53:30
=====================




First, 
let’s check the Node.js application source code.



Nothing fancy here!

The app makes an HTTP request to our backend service and gets the response.
Then, it maps the data to an HTML file to display it.





Now, let’s check the Dockerfile for our Node.js application.




The steps are similar to what we did before:

Define a base image for Node.js.


Copy the source files into the container.
Expose the port 3000 
Run the Node.js application.




Now, let’s build the Docker image for our Node.js frontend.


We run the Docker build command, 

and once it's done, we take a screenshot and add it to our documentation.





Next, we run the frontend container inside the 
same Docker network as the backend and database.



Now, let’s open the browser and check http://localhost:3000.


Great! The frontend is now successfully fetching 
and displaying data from our Java backend. 



Everything looks perfect !
Our three-tier app is fully set up and working as expected!





Database: MySQL
Middle Tier (Backend): Java Spring Boot
Frontend: Node.js



Let’s insert some data into the MySQL database manually.

The steps are very similar to what we did previously.


After refreshing the browser… voilà! 
The new data shows up in the frontend immediately.






 That’s it! We’ve successfully built and run a three-tier application inside Docker. 

 Thanks for watching!



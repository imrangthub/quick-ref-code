
=================================================
##6) Storage and Volumes
=================================================

Hello and welcome back!
In this episode, we gonna discussing Docker Storage and Volumes.


So, lets get start....
By default, all files created inside a container are stored in the container itself.


Like:
    Your app produces logs that you want to save for future analysis..
    Your application may write files that you want to keep.


The Problem with the Default System:
    When the container is removed, all files will be gone.
    Storing too much data inside the container may slow down your app and make performance issues.




To solve this issue, Docker provides two  main ways to keep data safe:
    Volumes and Bind-mounts.



For details about, You can check out Docker’s official documentation.
Lets explore this:




First:
Let’s talk about Volumes:

Volumes are storage waht is manage by Docker and can only be accessed by containers, 
not by host processes, so they are secure.

When you use a volume to store logs or other data, even if the container is removed, 
your data will still be safe in the volume.

When a new container is created, it can reuse the same volume and access all the saved data.



You can check volume using DockerDesktop or cli as Image and contienr.

Volumes are stored inside Docker and can only be accessed by Docker containers, not by the host processes.
This why..
Volumes are the recommended and secure approach.




Now let’s talk about Bind Mounts:

Bind mounts also keep data outside the container and outside Docker, anywhere on your host file system.


This way, your container runs inside Docker, but the data is saved on the host where other apps can access it.

For example, you can store logs in a bind mount and have Loki or Grafana read and process them.

Bind-mounts are useful when you need to perform analysis or allow other host machine processes 
to access data generated by the container, such as logs or reports.




So,
If you don’t need to access container data outside Docker, 
go with Volumes — they’re secure and recommended.

If you want to access or process container data from the host or other apps, use Bind Mounts.



tmpfs:
    It’s the fastest and most secure option for contianer data storage.
    tmpfs Data isn’t saved in any volume or on the host’s file system — it stays in the host’s RAM.
    tmpfs is ideal when you need high-performance,  most secure operation.













9:20mm
============================
Now, let's explore some of the basic Docker volume commands and get some hands-on practice! 


Let's start with Nginx and see how how volumes work with a real application .




Great — our application is up and running!  
Now, let’s update the default Nginx page.

To do that, we need to go inside the container.
I’m going to exec into the container so we can update its welcome HTML page.

We’ll use docker exec for this.

Since vi isn’t available inside the container, I’ll use the echo command to make the changes directly.



echo "Update from host machine" > /usr/share/nginx/html/index.html
Once the page is updated, we can refresh the browser and see our changes instantly reflected.



Now, what happens if the container crashes?
If we have to run it again, all our updates will be lost.

To see this in action, let’s manually stop the container and remove it.



Observation:
    This time, the default Nginx welcome page shows up again, and we lose the update we made 
    just a few minutes ago.

    This happens because the data was stored inside the container’s filesystem.

    When the container stops or crashes, the data inside is lost. 
    This is the default behavior of Docker containers.




Now, let's fix the data loss issue by using Docker Volumes:




First, let’s check the existing volumes by running:
docker volume ls
Since we haven’t created any volumes yet, the list will be empty..


Now, let’s create a new Docker volume with this command:
docker volume create my_ng_service_data


Verify the Volume:
docker volume ls
You should see my_ng_service_data in the list.




Now, let’s run the Nginx container and mount the created volume to it. 
Use the following command to do this:
docker run -d -p 80:80 -v my_ng_service_data:/usr/share/nginx/html nginx

Here, -v my_ng_service_data:/usr/share/nginx/html tells Docker to mount the my_ng_service_data 
to the /usr/share/nginx/html directory inside the container.




Now, you can check the Nginx homepage in your browser. 
It  display the default Nginx welcome page.



Let’s update the index.html page again, but this time the changes will be persisted 
even if the container is restarted.


So, 
docker exec -it <container_name> /bin/bash
Update the index.html file using echo:
echo "Welcome to My Custom Nginx Page!" > /usr/share/nginx/html/index.html


To verify the update i am gonna do cat  to see the index.html file:
cat /usr/share/nginx/html/index.html

Once the update is made, refresh your browser, and we should see the updated page as expected.






Now, if the container stops or is restarted, the changes we made to the index.html page will persist, 
because the data is stored in the Docker volume.

In Docker Desktop, you can even see the container and the volume that’s being used.





Let’s imagine the application crashed, 
In this case I am going to manually stopped and deleted both the container and image to simulate this scenario.

In Docker Desktop, you’ll notice that no container or image is listed anymore.

You can also verify this from the terminal by running:
    docker ps -a   # lists all containers
    docker images  # lists all images




Now, let’s pull the Nginx image again and run a new container using the same volume.

We can do this with the same command as before:
docker run -d -p 80:80 -v my_volume:/usr/share/nginx/html nginx

Once the container is up and running, open your browser and check — you should see the previously updated index.html page, 
the one we modified before the crash.


This is how the Docker volume preserves our data, even after container restarts or deletions.




If you run a new Nginx container without mapping the volume, it will show the default Nginx page, 
because it’s not using the volume that stored our updated index.html file.


Let's run one:
    docker run -d -p 80:80 nginx

Since we didn’t use the volume this time, the container only shows the default Nginx page, not our custom update.


This is why Docker volumes are so important,
they ensure that your data persists, even if the container is deleted or crashes.






Now Bind Mounting !
So, what exactly is Bind Mounting?

With Bind Mounting, a file or directory on the host machine is mounted directly into a Docker container.
This allows you to share files and data between the host machine and the container.

It’s super useful when you need to update or manage files on your container from your local machine directly.


Here’s the syntax for bind mounting:
You can use the -v flag for a quick bind mount or the more explicit --mount option.


Using -v Or, the more explicit version using --mount:
docker run -d --mount type=bind,        source=/path/on/host,       target=/path/in/container nginx
The --mount approach is the recommended method because it’s more explicit and easier to understand.




Let’s see Bind Mounting in action!

Let’s start by cleaning up our previous container.
We’ll delete the container and its volume, but keep the image, so we don’t have to download it again.



Next, we’ll update our HTML file on the host machine and use bind mounting to reflect those 
changes directly into the Docker container.


Update the index.html file on our host machine.
Let’s add a simple change, like modifying the welcome text.



Run the Docker container with the bind mount:
docker run -d -v /path/to/host/index.html:/usr/share/nginx/html/index.html nginx

What we’ve done here is mount the file from our host machine to the container.





Now, let’s open our browser and refresh the page.
As you can see, we’ve got the expected update! The change we made to the file on the 
host machine was reflected directly inside the container.


That’s the magic of bind mounting!



Now, let’s update the index.html file once again on the host machine.
We’ll make a small tweak to the content, save it, and refresh the browser again.
And boom, we see our new update immediately in the container as well!




So, the key difference between bind mounting and volume mounting is that with bind mounting, 
we’re directly sharing and modifying a file or directory from the host machine to the container.




Now, let’s briefly talk about Tmpfs, another way to mount data in Docker.

Tmpfs lets you store data in memory instead of on disk.
Since it’s volatile, the data won’t persist if the container stops or crashes.


The basic syntax looks like this:
docker run -d --mount type=tmpfs,target=/path/in/container nginx


Tmpfs isn’t used much, but it’s useful when you need fast performance and 
don’t care about keeping the data after the container stops.




















34:30
=============================
 we'll explore Docker Volumes and how they can be used to persist data, 
 specifically using a MySQL database as a real-world example.

In this lecture, we'll cover why Docker containers lose data by default and how volumes 
can help solve this problem by storing data outside of the container's filesystem.


By default, Docker containers are ephemeral, which means that any data inside a container is 
lost once the container stops or is deleted. 
This behavior works great for temporary data, 
but it’s a huge problem when you need to store persistent data, such as a database.

Let’s take a simple MySQL container as an example. 
If we run a MySQL database inside a container and insert some data,
 once we stop or remove the container, all the data inside that container is gone. 
 So, if your MySQL container crashes or you delete it for some reason, you lose all the database records.


This is a problem if you want to store important data like customer records, 
transactions, or any type of persistent database information.


The solution to this problem is Docker volumes. 
A Docker volume is a special kind of storage that is managed by Docker itself, 
separate from the container’s filesystem. 
Volumes allow you to persist data even when the container stops, crashes, or is deleted.


Instead of storing data inside the container, Docker volumes are stored on the host system. 
This means that even if a container is removed, the volume persists, keeping your data safe.



When you use volumes with a container, you mount the volume to a specific path inside the container. 
For example, in the case of a MySQL container, 
you would mount a volume to the path where MySQL stores its data (/var/lib/mysql). 
This way, MySQL’s data is saved in the volume instead of inside the container.


Once a volume is created and linked to a container, you can stop, remove, and recreate the 
container without worrying about losing your data. 
The volume remains intact, and the next time the container starts, it will have access to the same data.


Imagine you are running a MySQL container, and you insert some data into the database. 
Without a volume, this data would be lost if the container is removed. 
But with a volume, the data is safely stored in the volume and can be reused even after 
the container is deleted and recreated.

To make this work, you create a Docker volume and mount it to the container’s data storage directory. 
Now, any changes you make to the database, 
like adding or modifying records, are stored in the volume, ensuring that the data persists.

When the container is stopped or deleted, you simply run a new container, 
mount the same volume, and the database will continue with the previous data intact.



The benefits of using Docker volumes include:
    Persistence: Data survives even after the container is deleted or crashes.
    Isolation: Volumes are separate from the container’s filesystem, reducing the risk of accidental data loss.
    Portability: You can easily back up or migrate volumes across different environments or machines.
    Data Sharing: Volumes allow multiple containers to share data without worrying about data 
    duplication or file conflicts.



There are other ways to manage data in Docker, such as bind mounts and tmpfs. 
However, volumes are typically the most reliable and efficient way to persist data.

Bind Mounts: These link a specific file or directory from the host system to the container. 
While they are useful for development or when you need access to host data inside a container, 
they are not as secure or portable as volumes.

tmpfs: This is an in-memory filesystem that is mounted inside the container, 
and data is lost when the container stops. It’s the fastest but not suitable for persistent data.
Volumes are recommended because they offer persistence, security, and flexibility.






Create a Volume: First, create a volume called mysql-data to store MySQL data. 
You can check if it’s created by listing the volumes with a simple command.

Run MySQL with Volume: Now, run a MySQL container while mounting the mysql-data volume. 
Once it’s running, log into the database, create a table, and insert some data.


Verify Data Insertion: Retrieve the data by running a SELECT query to ensure that everything is in place.

Volume Persistence: Docker volumes keep the data separate from the container, 
meaning if the container is deleted or crashes, 
the data is safe. You can see the volume details in Docker Desktop.


Delete and Restart the Container: Now, stop and delete the container. 
Afterward, restart the container with the same volume attached.


Verify Data After Restart: Use the same methods to check that your data is still intact after 
restarting the container. This proves that the data has been successfully persisted with Docker volumes.



Use Bind Mount: 
Next, let’s use a Bind Mount. Choose a directory on your host machine and bind mount it 
to the MySQL container.

Run MySQL with Bind Mount: Run the container with the host directory mounted to the container. 
This way, the container directly interacts with the files on the host machine.

Insert Data: Just like before, insert data into the MySQL container.

Verify Data: After inserting data, check the host machine’s directory. 
You should see the MySQL data being written directly to that path.

Delete and Restart the Container: Stop and delete the container again, 
and then run the container with the same bind mount to verify data persistence.

Check Data After Restart: After restarting the container, check the data to ensure it remains intact. 
This confirms that the data is properly persisted with bind mounting.


[Conclusion]
Thank you for watching! Don’t forget to like, subscribe, and click the bell for more tutorials!





==========================================
##5) Docker Image and Containers
==========================================



Hello and welcome back!
In this episode, we will explore docker Image and Container in Details.
So, let's get started!




Image:
So, what exactly is an image?
 Image is ready-to-use package that includes everything an app needs to run, for example, a Java Application or MySql Servdr.


Think of image as a template for containers.
It’s like a blueprint,  when you run it, Docker creates a container based on that image.


As you can see in the document:
Here, we’re running two Java application from a single Java image, and three Redis Instance from a single Redis image.
 all running separately!

And The diagram shows that how we can reuse a single image to create as many containers as we want.



Now, where can we find an image for our application? What is the image source, or how can we create one?
Well,
    We can either build our own image using a Dockerfile or download a ready-made image from Docker Hub.






Alright, let’s explore Docker Hub!
    Here, We can find a list of images, both official and those created by individual developers.
    And guess what? We can also upload our own images here too!


Docker Hub is a public repository !
Public images are stored on Docker Hub, but if a company wants to keep things private, 
they can set up their own private registry and share images safely within the team.




Now, let’s explore some of the most common Docker image commands.

First:
docker image ls
This command shows all the available images on your Docker host.

You can also see them directly in Docker Desktop.

Repository – that’s the name of the image.
Tag – this shows the version of the image.




Let’s check out Docker Hub to explore this in action.
    For example, if we search for the Ubuntu image,
    we’ll see lots of different tags — each one representing a specific release version.



Alright, let’s talk a bit more about tags.
So, here I have one of my custom images — it comes with three different release versions, and each version is defined by a tag.


Now, let’s download an image using its tag version.
To do that, we just run:
docker image pull

Once the pull is complete, we can check it by running:
docker image ls

And that’s the image, it's ready to use!


By default, if we don’t mention any tag, Docker automatically downloads the image with the :latest tag.

But here’s something important to remember, the :latest tag doesn’t always mean it’s the newest version of the image.
Sometimes, it’s just the most stable or popular release.
So, there might be newer versions out there, even if they’re not marked as latest.


Let’s see what that really means.
    Here, we can see the Ubuntu image — it comes with many release versions as tags.
    Notice that the :latest tag points to version 22.04,
    but there’s actually a newer version, 23.10, available.

Interesting, right?
So always remember — the :latest tag doesn’t always mean the newest release of the image!



When running docker image ls, we see:
    Image ID: A unique auto-generated identifier for the image.
    Created Date: When the image was built.
    Size: The disk space used by the image.






Now, let's explore base images and how to build an image.

Every Docker image is created from another image called a base image.
A base image is the parent image for all images.





Let’s check the Nginx Dockerfile from Docker Hub.
    In the first line, we see the FROM directive, This defines the base image used to create this Nginx image.

Every image has a parent image from which it is derived.
All images are created on top of another image, forming a chain of dependencies.



Lets talk how to Choosing a Base Image for our CustomImages:

Do we choose a random base image? No!
We need to select a base image that is relevant to our custom image.

For example:
    If we are going to build a Java application, we should choose a JDK image with a specific version:
    FROM openjdk:17
This base image already includes Java, so we don’t need to install it manually.


We should always pick a base image that:
    ✔ Matches the type of application we are building.
    ✔ Meets the system requirements of our app.




Now, let’s explore the Scratch image and the FROM scratch tag.

    The Scratch image is the bare minimum and most basic image in Docker.
    It’s completely empty — no operating system, no tools, nothing at all.
    Every Docker image Starts from this Scratch image and builds layer by layer on top of it.









Let’s explore the MySQL Docker image.
    Looking at its Dockerfile, we see it is built on top of the Oracle Linux image.
    This means the Oracle Linux image is the base image for MySQL.



All images are built on top of another image.
For instance:
    The MySQL image starts with Oracle Linux.
    Then, it builds on top of that, adding necessary components.
    Finally, it adds the MySQL application.

This is how Docker images are constructed—step by step, layer by layer.



If you don't want to use ready-made images like the official Nginx image, you can also build your own image layer by layer.



For example, let’s say we want to create an Nginx image using a Linux image as the base.
The process is similar to setting up a traditional host.










Let’s take a closer look at the details of a Dockerfile.
A Dockerfile is a combination of instructions and arguments that define how an image is built.

Here’s an example of a Dockerfile:
    It starts with a base image like Ubuntu.
    Then, it updates the package list.
    Next, it installs a package like Nginx.

It also defines the default port for the container.
Finally, it includes a run command to start the application.



Once you’ve written the Dockerfile, you can build your image using the following command:
docker build -t image-name:tag .
This will create a Docker image based on the instructions in the Dockerfile.



As you can see, the commands are shown in the domument.





Now, let’s see how to create a Docker image from a Dockerfile in action.




Let's create a new file named index.html and add some basic information inside it.




It’s running now, so let’s check the default page.





We’ve just created our image using a single index.html file.
In future episodes, we’ll see how to create Docker images for real-world projects with larger source code using different programming languages like Java and PHP.




This is the Dockerfile and the commands we just used to build our image.
Now it’s your turn — try making your own image using the same steps.




You can create your own image using any package, such as JDK.
In this example, I used Nginx, but instead of Nginx, you can install any package to build an image for your specific purpose or application.

This way, you can customize your Dockerfile based on what your project needs.




This is another image used to run a Python application.
You can build and run your own Python application in the same way.





To see the details of a container, we can use the docker inspect command.





Now that you’ve created your image, you may want to share it with other team members, such as the QA or production team.
To do this, you can push the image to an image repository. For restricted access, use a private repository.

Alternatively, you can create a .tar file from the image using Docker commands, 
share it with other teams, and once they load it into their system, the image will be ready to use.




Let's try doing this.



As you can see, the commands are shown in the document.






We use the run command to create and start a container from an image.
The run command has many options that you can explore, such as -d, -p, and others.



I have mentioned some examples here that you can explore.
You should play around with these options to get comfortable.








That’s it for today’s video, guys.
In this video, we just covered the basics of Docker images and containers with some commands.
When we reach our example project episode, we’ll explore Docker images and containers in more detail with lots of hands-on practice.



